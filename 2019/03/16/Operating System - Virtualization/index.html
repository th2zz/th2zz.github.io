<!DOCTYPE html>
<html lang="en">

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Operating System - Virtualization |  th2zz
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/assets/torr3.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

</head>

</html>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-Operating System - Virtualization" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Operating System - Virtualization
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/03/16/Operating System - Virtualization/" class="article-date">
  <time datetime="2019-03-15T20:06:41.000Z" itemprop="datePublished">2019-03-15</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">24分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="cs537-operating-system-summary-part-1-virtualization"><a class="markdownIt-Anchor" href="#cs537-operating-system-summary-part-1-virtualization"></a> <strong>CS537 - Operating System Summary Part 1 Virtualization</strong></h1>
<h1 id="virtualization"><a class="markdownIt-Anchor" href="#virtualization"></a> Virtualization</h1>
<h2 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process</h2>
<h3 id="what-is-a-process"><a class="markdownIt-Anchor" href="#what-is-a-process"></a> What is a process</h3>
<ul>
<li>A running program is a process</li>
<li>Stream of executing instructions and their “context”</li>
</ul>
<h3 id="thread"><a class="markdownIt-Anchor" href="#thread"></a> Thread</h3>
<ul>
<li>Can have multiple threads within a single process</li>
<li>Lightweight process</li>
<li>Share an address space</li>
</ul>
<h3 id="why-do-we-need-processes"><a class="markdownIt-Anchor" href="#why-do-we-need-processes"></a> Why do we need processes?</h3>
<ul>
<li>Share CPU: Time sharing</li>
</ul>
<h3 id="os-scheduler"><a class="markdownIt-Anchor" href="#os-scheduler"></a> OS Scheduler</h3>
<ul>
<li>Scheduler save context when process is pause</li>
<li>Restore context on resumption</li>
</ul>
<h3 id="goals-for-cpu-virtualization"><a class="markdownIt-Anchor" href="#goals-for-cpu-virtualization"></a> Goals for CPU Virtualization</h3>
<ul>
<li>
<p>Policy goals</p>
<ul>
<li>Virtualize CPU resource using processes</li>
<li>Reschedule process for fairness? efficiency?</li>
</ul>
</li>
<li>
<p>Mechanism goals</p>
<ul>
<li>Efficiency: Time sharing should not add overhead</li>
<li>Control: OS should be able to intervene when required</li>
</ul>
</li>
</ul>
<h2 id="mechanism"><a class="markdownIt-Anchor" href="#mechanism"></a> Mechanism</h2>
<h3 id="system-call"><a class="markdownIt-Anchor" href="#system-call"></a> System call</h3>
<ul>
<li>
<p>User mode and kernel mode</p>
<ul>
<li>User processes run in user mode (restricted mode)</li>
<li>OS runs in kernel mode (not restricted)</li>
</ul>
</li>
<li>
<p>System call</p>
<ul>
<li>Separate user mode from kernel mode for security</li>
<li>Use system call to invoke kernel mode functions</li>
</ul>
</li>
<li>
<p>Procedure for calling read()</p>
<ol>
<li>Set system call table index to 6 <code>movl $6, %eax</code></li>
<li>Call trap with id 64 <code>int $64</code></li>
</ol>
</li>
</ul>
<p><img src="https://i.imgur.com/7hmjTrj.png" alt=""></p>
<h3 id="dispatch-mechanism"><a class="markdownIt-Anchor" href="#dispatch-mechanism"></a> Dispatch mechanism</h3>
<ul>
<li>
<p>Dispatch loop</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;	</span><br><span class="line">    run	process	A for some time-slice	</span><br><span class="line">    stop process A and save its context	</span><br><span class="line">    load context of another process B	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Cooperative Multi-tasking</p>
<ul>
<li>Trust process to relinquish CPU through traps</li>
<li>Provide special yield() system call</li>
<li>Processes can <strong>misbehave</strong></li>
</ul>
</li>
<li>
<p>Timer-based Multi-tasking</p>
<ul>
<li>Hardware generates timer interrupt (CPU or separate chip)</li>
<li>User must not be able to mask timer interrupt</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/eE325zz.png" alt=""></p>
<h2 id="policy"><a class="markdownIt-Anchor" href="#policy"></a> Policy</h2>
<h3 id="vocabulary"><a class="markdownIt-Anchor" href="#vocabulary"></a> Vocabulary</h3>
<ul>
<li>Workload: set of jobs (arrival time, run_time)</li>
<li>Job ~ Current execution of a process</li>
<li>Scheduler: Decides which ready job to run</li>
<li>Metric: measurement of scheduling quality</li>
<li>Turnaround time = completion time - arrival time</li>
<li>Response time = first run time - arrival time</li>
</ul>
<h3 id="fifo-first-in-first-out"><a class="markdownIt-Anchor" href="#fifo-first-in-first-out"></a> FIFO (First In, First Out)</h3>
<ul>
<li>Disadvantage: Turnaround time suffers when short jobs must wait for long jobs (Convoy Effect)</li>
</ul>
<img src="https://i.imgur.com/p6B5iuB.png" width="75%" style="margin:auto; display: block;">
<h3 id="sjf-shortest-job-first"><a class="markdownIt-Anchor" href="#sjf-shortest-job-first"></a> SJF (Shortest job first)</h3>
<ul>
<li>Disadvantage: Only schedule new job when previous job voluntarily relinquishes CPU</li>
</ul>
<img src="https://i.imgur.com/4L0JHF6.png" width="75%" style="margin:auto; display: block;">
<h3 id="stcf-shortest-time-to-completion-first"><a class="markdownIt-Anchor" href="#stcf-shortest-time-to-completion-first"></a> STCF (Shortest Time-to-Completion First)</h3>
<ul>
<li>Preemptive: Schedule different job by taking CPU away from running job</li>
<li>Always run job that will complete the quickest</li>
</ul>
<img src="https://i.imgur.com/F97B6qw.png" width="75%" style="margin:auto; display: block;">
<h3 id="round-robin"><a class="markdownIt-Anchor" href="#round-robin"></a> Round Robin</h3>
<ul>
<li>Goal: reduce response time</li>
<li>Trade-off: increase turnaround time</li>
</ul>
<img src="https://i.imgur.com/aNCUwiF.png" width="75%" style="margin:auto; display: block;">
<h3 id="io-aware-scheduling"><a class="markdownIt-Anchor" href="#io-aware-scheduling"></a> I/O Aware Scheduling</h3>
<ul>
<li>Goal: process won’t hold CPU when doing IO</li>
</ul>
<img src="https://i.imgur.com/S8TUga8.png" width="75%" style="margin:auto; display: block;">
<h3 id="multilevel-feedback-queue"><a class="markdownIt-Anchor" href="#multilevel-feedback-queue"></a> Multilevel Feedback Queue</h3>
<ul>
<li>
<p>Motivation: Run-time of each job is not known</p>
</li>
<li>
<p>Approach</p>
<ul>
<li>Multiple levels of round-robin</li>
<li>Each level has higher priority than lower level</li>
<li>Can preempt them</li>
</ul>
</li>
<li>
<p>Rules</p>
<ol>
<li>If priority(A) &gt; Priority(B), A runs</li>
<li>If priority(A) == Priority(B), A &amp; B run in RR</li>
<li>Processes start at top priority</li>
<li>If job uses whole slice, demote process (longer time slices at lower priorities)</li>
</ol>
</li>
<li>
<p>Avoid starvation</p>
<ul>
<li>Problem: Low priority job may never get scheduled</li>
<li>Solution: Periodically boost priority of all jobs (or all jobs thathaven’t been scheduled)</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/RL4PuJC.png" width="50%" style="margin:auto; display: block;">
<h1 id="memory-virtualization"><a class="markdownIt-Anchor" href="#memory-virtualization"></a> Memory Virtualization</h1>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<h3 id="goals"><a class="markdownIt-Anchor" href="#goals"></a> Goals</h3>
<ul>
<li><strong>Transparency</strong>: Process is unaware of sharing</li>
<li><strong>Protection</strong>: Cannot corrupt OS or other process memory</li>
<li><strong>Efficiency</strong>: Do not waste memory or slow down processes</li>
<li><strong>Sharing</strong>: Enable sharing between cooperating processes</li>
</ul>
<h3 id="address-space"><a class="markdownIt-Anchor" href="#address-space"></a> Address space</h3>
<ul>
<li>Stack: No fragmentation</li>
<li>Heap: Consists of allocated and free areas (holes)<br>
<img src="https://i.imgur.com/we79L5F.png" alt=""></li>
</ul>
<h3 id="memory-access-example"><a class="markdownIt-Anchor" href="#memory-access-example"></a> Memory Access Example</h3>
<table>
<thead>
<tr>
<th>Assembly</th>
<th>Access for Instruction</th>
<th>Access for Execution</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x10: movl 0x8(%rbp), %edi</code></td>
<td>Fetch instruction at 0x10</td>
<td>Load from 0x208</td>
</tr>
<tr>
<td><code>0x13: addl $0x3, %edi</code></td>
<td>Fetch instruction at 0x13</td>
<td>No memory access</td>
</tr>
<tr>
<td><code>0x19: movl %edi, 0x8(%rbp)</code></td>
<td>Fetch instruction at 0x19</td>
<td>Store to 0x208</td>
</tr>
</tbody>
</table>
<h2 id="basic-mechanisms"><a class="markdownIt-Anchor" href="#basic-mechanisms"></a> Basic Mechanisms</h2>
<h3 id="time-sharing"><a class="markdownIt-Anchor" href="#time-sharing"></a> Time Sharing</h3>
<ul>
<li>On process switch, save current process’s memory to disk and load another process’s memory from disk.</li>
<li>Ridiculously poor performance</li>
</ul>
<h3 id="static-relocation"><a class="markdownIt-Anchor" href="#static-relocation"></a> Static Relocation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>OS rewrites each program before loading it as a process in memory</li>
<li>Each rewrite for different process uses different addresses and pointers</li>
<li>Change jumps, loads of static data</li>
</ul>
</li>
<li>
<p>Disadvantage</p>
<ul>
<li>Process can destroy OS or other processes</li>
<li>No privacy</li>
<li>Cannot move address space after it has been placed</li>
<li>May not be able to allocate new process</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/840IDak.png" alt=""></p>
<h3 id="dynamic-relocation-introduction"><a class="markdownIt-Anchor" href="#dynamic-relocation-introduction"></a> Dynamic Relocation: Introduction</h3>
<ul>
<li>
<p>Goal: Protect processes from one another</p>
</li>
<li>
<p>Memory Management Unit (MMU)</p>
<ul>
<li>MMU dynamically changes process address at every memory reference</li>
<li>Process generates <strong>logical</strong> or <strong>virtual</strong> addresses (in their address space)</li>
<li>Memory hardware uses <strong>physical</strong> or <strong>real</strong> addresses</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/1rZVwO8.png" alt=""></p>
<ul>
<li>Two operating modes
<ul>
<li>
<p>Kernel mode</p>
<ul>
<li>Can manipulate contents of MMU</li>
<li>Allows OS to access all of physical memory</li>
</ul>
</li>
<li>
<p>User mode</p>
<ul>
<li>Perform translation of logical address to physical address</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="dynamic-relocation-base-register"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-register"></a> Dynamic Relocation: Base Register</h3>
<ul>
<li>Translation on every memory access of user process</li>
<li>MMU adds base register to logical address to form physical address</li>
<li>Store offset in base register</li>
<li>Each process has different value in base register</li>
<li>Dynamic relocation by changing value of base register.</li>
</ul>
<p><img src="https://i.imgur.com/Eika7Rs.png" alt=""></p>
<ul>
<li>
<p>Quiz</p>
<ul>
<li>What entity should do translation of addresses with base register? <strong>Hardware</strong></li>
<li>What entity should modify the base register? <strong>OS</strong></li>
</ul>
</li>
<li>
<p>Problem: No protection</p>
</li>
</ul>
<h3 id="dynamic-relocation-base-bounds"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-bounds"></a> Dynamic Relocation: Base + Bounds</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>limit the address space with a bounds register</li>
<li>Base register: smallest physical addr (or starting location)</li>
<li>Bounds register: size of this process’s virtual address space</li>
<li>OS kills process if process loads/stores beyond bounds</li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li>MMU compares logical address to bounds register</li>
<li>if logical address is greater, then generate error</li>
<li>MMU adds base register to logical address to form physical address</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/Qoqdgtb.png" alt=""></p>
<ul>
<li>
<p>Context switch</p>
<ol>
<li>Change to privileged mode</li>
<li>Save base and bounds registers of old process</li>
<li>Load base and bounds registers of new process</li>
<li>Change to user mode and jump to new process</li>
</ol>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Provides protection (both read and write) across address spaces</li>
<li>Supports dynamic relocation</li>
<li>Simple, inexpensive implementation: Few registers, little logic in MMU</li>
<li>Fast: Add and compare in parallel</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Each process must be allocated contiguously in physical memory</li>
<li>Must allocate memory that may not be used by process</li>
<li>No partial sharing: Cannot share limited parts of address space</li>
</ul>
</li>
</ul>
<h3 id="segmentation"><a class="markdownIt-Anchor" href="#segmentation"></a> Segmentation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>MMU contains Segment Table (per process)</li>
<li>Each segment has own base and bounds, protection bits</li>
<li>Example: 14 bit logical address, 4 segments;</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<p>Segment Table</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>Bounds</th>
<th>R W</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x2000</td>
<td>0x6ff</td>
<td>1 0</td>
</tr>
<tr>
<td>1</td>
<td>0x0000</td>
<td>0x4ff</td>
<td>1 1</td>
</tr>
<tr>
<td>2</td>
<td>0x3000</td>
<td>0xfff</td>
<td>1 1</td>
</tr>
<tr>
<td>3</td>
<td>0x0000</td>
<td>0x000</td>
<td>0 0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Translation</p>
<table>
<thead>
<tr>
<th>Logical address</th>
<th>Segment</th>
<th>Base</th>
<th>Physical address</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0240</td>
<td>0</td>
<td>0x2000</td>
<td>0x2240</td>
</tr>
<tr>
<td>0x1108</td>
<td>1</td>
<td>0x0000</td>
<td>0x1108</td>
</tr>
<tr>
<td>0x256c</td>
<td>2</td>
<td>0x3000</td>
<td>0x356c</td>
</tr>
<tr>
<td>0x3002</td>
<td>3</td>
<td>0x0000</td>
<td>Fail</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>No extra memory access</li>
<li>Enables sparse allocation of address space</li>
<li>Stack and heap can grow independently</li>
<li>Enables sharing of selected segments</li>
<li>Read-only status for code</li>
<li>Supports dynamic relocation of each segment</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Each segment must be allocated contiguously</li>
<li>May not have sufficient physical memory for large segments?</li>
<li>External Fragmentation</li>
</ul>
</li>
</ul>
<h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3>
<table>
<thead>
<tr>
<th>Description</th>
<th>Name of approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>One process uses RAM at a time</td>
<td>Time Sharing</td>
</tr>
<tr>
<td>Rewrite code and addresses before running</td>
<td>Static Relocation</td>
</tr>
<tr>
<td>Add per-process starting location to virt addr to obtain phys addr</td>
<td>Base</td>
</tr>
<tr>
<td>dynamic approach that verifies address is in valid range</td>
<td>Base + Bounds</td>
</tr>
<tr>
<td>Several base+bound pairs per process</td>
<td>Segmentation</td>
</tr>
</tbody>
</table>
<h2 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h2>
<h3 id="fragmentation"><a class="markdownIt-Anchor" href="#fragmentation"></a> Fragmentation</h3>
<ul>
<li>
<p>Definition</p>
<ul>
<li>Free memory that can’t be usefully allocated</li>
</ul>
</li>
<li>
<p>Types of fragmentation</p>
<ul>
<li>External: Visible to allocator (e.g., OS)</li>
<li>Internal: Visible to requester</li>
</ul>
</li>
</ul>
<h3 id="introduction-for-paging"><a class="markdownIt-Anchor" href="#introduction-for-paging"></a> Introduction for Paging</h3>
<ul>
<li>
<p>Goal</p>
<ul>
<li>Eliminate requirement that address space is contiguous</li>
<li>Eliminate external fragmentation</li>
<li>Grow segments as needed</li>
</ul>
</li>
<li>
<p>Idea</p>
<ul>
<li>Divide address spaces and physical memory into fixed-sized pages (usually 4KB)</li>
</ul>
</li>
</ul>
<h3 id="translation-of-page-addresses"><a class="markdownIt-Anchor" href="#translation-of-page-addresses"></a> Translation of Page Addresses</h3>
<ul>
<li>Logical address
<ul>
<li>High-order bits of address designate page number</li>
<li>Low-order bits of address designate offset within page</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/EuMGAwS.png" alt=""></p>
<ul>
<li>
<p>Address Format</p>
<table>
<thead>
<tr>
<th>Page Size</th>
<th>Low Bits</th>
<th>Virt Addr Bits</th>
<th>High Bits</th>
<th>Virt Pages</th>
</tr>
</thead>
<tbody>
<tr>
<td>16 bytes</td>
<td>log(16) = 4</td>
<td>10</td>
<td>10 - 4 = 6</td>
<td>2 ^ 6 = 64</td>
</tr>
<tr>
<td>1 KB</td>
<td>log(1K) = 10</td>
<td>20</td>
<td>20 - 10 = 10</td>
<td>2 ^ 10 = 1024</td>
</tr>
<tr>
<td>1 MB</td>
<td>log(1M) = 20</td>
<td>32</td>
<td>32 - 20 = 12</td>
<td>2 ^ 12 = 4K</td>
</tr>
<tr>
<td>512 bytes</td>
<td>log(512) = 9</td>
<td>16</td>
<td>16 - 9 = 7</td>
<td>2 ^ 7 = 128</td>
</tr>
<tr>
<td>4 KB</td>
<td>log(4K) = 12</td>
<td>32</td>
<td>32 -12 = 20</td>
<td>2 ^ 20 = 1M</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Address Translation</p>
<ul>
<li>Number of bits in virtual address <strong>need not equal</strong> number of bits in physical address</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/HZcAtTC.png" alt=""></p>
<h3 id="pagetables"><a class="markdownIt-Anchor" href="#pagetables"></a> Pagetables</h3>
<ul>
<li>
<p>How should OS translate VPN to PPN?</p>
<ul>
<li>Simple solution: Linear page table aka array</li>
</ul>
</li>
<li>
<p>Example<br>
<img src="https://i.imgur.com/uWlRJnw.png" alt=""></p>
<ul>
<li>Page table for P1: 3, 1, 7, 10</li>
<li>Page table for P2: 0, 4, 2, 6</li>
<li>Page table for P3: 8, 5, 9, 11</li>
</ul>
</li>
<li>
<p>How big is a pagetable</p>
<ul>
<li>Given 32-bit address space, 4KB pages, 4 byte entries</li>
<li>4KB pages =&gt; 12 bit for offset</li>
<li>32-bit address space =&gt; 20 bit for VPN =&gt; 2 ^ 20 = 1MB entries</li>
<li>1MB entries * 4 byte per entry = 4MB</li>
</ul>
</li>
<li>
<p>Where are pagetables stored</p>
<ul>
<li>Store each page table in memory</li>
<li>Hardware finds page table base with register (e.g., CR3 on x86)</li>
</ul>
</li>
<li>
<p>What happens on a context-switch?</p>
<ul>
<li>Change contents of page table base register to newly scheduled process</li>
<li>Save old page table base register in PCB of descheduled process</li>
</ul>
</li>
<li>
<p>What other info is in pagetable entries besides translation?</p>
<ul>
<li>valid bit</li>
<li>protection bits</li>
<li>present bit (needed later)</li>
<li>reference bit (needed later)</li>
<li>dirty bit (needed later)</li>
</ul>
</li>
</ul>
<h3 id="memory-access-with-paging"><a class="markdownIt-Anchor" href="#memory-access-with-paging"></a> Memory Access with Paging</h3>
<ul>
<li>
<p>Given</p>
<ul>
<li>Current instruction: <code>0x0010: movl 0x1100, %edi</code></li>
<li>Assume PT is at phys addr 0x5000</li>
<li>Assume PTE’s are 4 bytes</li>
<li>Assume 4KB pages =&gt; 12 bits for offset</li>
<li>Page table for current process: 2, 0, 80, 99</li>
</ul>
</li>
<li>
<p>Fetch instruction at logical addr 0x0010</p>
<ul>
<li>Access page table to get ppn for vpn 0</li>
<li>Mem ref 1: 0x5000</li>
<li>Learn vpn 0 is at ppn 2</li>
<li>Fetch instruction at 0x2010 (Mem ref 2)</li>
</ul>
</li>
<li>
<p>Exec, load from logical addr 0x1100</p>
<ul>
<li>Access page table to get ppn for vpn 1</li>
<li>Mem ref 3: 0x5000</li>
<li>Learn vpn 1 is at ppn 0</li>
<li>movl from 0x0100 into reg (Mem ref 4)</li>
</ul>
</li>
</ul>
<h3 id="advantages-of-paging"><a class="markdownIt-Anchor" href="#advantages-of-paging"></a> Advantages of Paging</h3>
<ul>
<li>
<p>No external fragmentation</p>
<ul>
<li>Any page can be placed in any frame in physical memory</li>
</ul>
</li>
<li>
<p>Fast to allocate and free</p>
<ul>
<li>Alloc: No searching for suitable free space</li>
<li>Free: Doesn’t have to coalesce with adjacent free space</li>
</ul>
</li>
<li>
<p>Simple to swap-out portions of memory to disk (later lecture)</p>
<ul>
<li>Page size matches disk block size</li>
<li>Can run process when some pages are on disk</li>
<li>Add “present” bit to PTE</li>
</ul>
</li>
</ul>
<h3 id="disadvantages-of-paging"><a class="markdownIt-Anchor" href="#disadvantages-of-paging"></a> Disadvantages of Paging</h3>
<ul>
<li>
<p>Internal fragmentation: Page size may not match size needed by process</p>
<ul>
<li>Wasted memory grows with larger pages</li>
<li>Tension?</li>
</ul>
</li>
<li>
<p>Additional memory reference to page table -&gt; Very inefficient</p>
<ul>
<li>Page table must be stored in memory</li>
<li>MMU stores only base address of page table</li>
</ul>
</li>
<li>
<p>Storage for page tables may be substantial</p>
<ul>
<li>Simple page table: Requires PTE for all pages in address space</li>
<li>Entry needed even if page not allocated?</li>
</ul>
</li>
</ul>
<h3 id="paging-translation-steps"><a class="markdownIt-Anchor" href="#paging-translation-steps"></a> Paging Translation Steps</h3>
<ol>
<li>extract VPN (virt page num) from VA (virt addr)</li>
<li>calculate addr of PTE (page table entry)</li>
<li>read PTE from memory</li>
<li>extract PFN (page frame num)</li>
<li>build PA (phys addr)</li>
<li>read contents of PA from memory into register</li>
</ol>
<h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2>
<h3 id="motivative-example-iterating-array"><a class="markdownIt-Anchor" href="#motivative-example-iterating-array"></a> Motivative Example: Iterating Array</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Memory Access</p>
<table>
<thead>
<tr>
<th>What virtual addresses?</th>
<th>What physical addresses?</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x3000</td>
<td>load 0x100C <br>load 0x7000</td>
</tr>
<tr>
<td>load 0x3004</td>
<td>load 0x100C <br>load 0x7004</td>
</tr>
<tr>
<td>load 0x3008</td>
<td>load 0x100C <br>load 0x7008</td>
</tr>
<tr>
<td>load 0x300C</td>
<td>load 0x100C <br>load 0x7008</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="introduction-2"><a class="markdownIt-Anchor" href="#introduction-2"></a> Introduction</h3>
<ul>
<li>Strategy: Cache Page Translations</li>
<li>TLB stands for Translation Lookaside Buffer<br>
<img src="https://i.imgur.com/mEwtslZ.png" alt=""></li>
</ul>
<h3 id="tlb-organization"><a class="markdownIt-Anchor" href="#tlb-organization"></a> TLB Organization</h3>
<ul>
<li>
<p>TLB Entry</p>
<table>
<thead>
<tr>
<th>Tag (virtual page number)</th>
<th>Physical page number (page table entry)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>Fully associative</p>
<ul>
<li>Any given translation can be anywhere in the TLB</li>
<li>Hardware will search the entire TLB in parallel</li>
</ul>
</li>
</ul>
<h3 id="example-iterating-array-with-tlb"><a class="markdownIt-Anchor" href="#example-iterating-array-with-tlb"></a> Example: Iterating Array with TLB</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Page table for current process (starting at 0x0000)</p>
  <table>
      <tbody>
          <tr>
              <td>PPN</td>
              <td>1</td>
              <td>5</td>
              <td>4</td>
              <td>…</td>
          </tr>
          <tr>
              <td>VPN</td>
              <td>0</td>
              <td>1</td>
              <td>2</td>
              <td>3</td>
          </tr>
      </tbody>
  </table>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>Valid</th>
<th>VPN</th>
<th>PPN</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Memory Access</p>
<table>
<thead>
<tr>
<th>What virtual addresses?</th>
<th>What physical addresses?</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x1000</td>
<td>load 0x0004 <br>load 0x5000</td>
</tr>
<tr>
<td>load 0x1004</td>
<td>(TLB hit) <br>load 0x5004</td>
</tr>
<tr>
<td>load 0x1008</td>
<td>(TLB hit) <br>load 0x5008</td>
</tr>
<tr>
<td>load 0x100C</td>
<td>(TLB hit) <br>load 0x500C</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>load 0x2000</td>
<td>load 0x0008 <br>load 0x4000</td>
</tr>
<tr>
<td>load 0x2004</td>
<td>(TLB hit) <br>load 0x4004</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Performance</p>
<ul>
<li># TLB lookups = number of accesses to a = 2048</li>
<li># TLB misses = 2</li>
<li>Miss rate = 2/2048 = 0.1%</li>
<li>Hit rate = 1 – miss rate = 99.9%</li>
</ul>
</li>
</ul>
<h3 id="tlb-replacement-policies"><a class="markdownIt-Anchor" href="#tlb-replacement-policies"></a> TLB Replacement Policies</h3>
<ul>
<li>
<p>Access Patterns</p>
<ul>
<li>Sequential array accesses almost always hit in TLB: Very fast!</li>
<li>Highly random, with no repeat accesses: Slow</li>
</ul>
</li>
<li>
<p>Code Example</p>
<table>
<thead>
<tr>
<th>Workload A</th>
<th>Workload B</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://i.imgur.com/fg4fYXO.png" alt=""></td>
<td><img src="https://i.imgur.com/b3eYUnz.png" alt=""></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/HWMGImG.png" alt=""></td>
<td><img src="https://i.imgur.com/iMYOS03.png" alt=""></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Workload Locality</p>
<ul>
<li>Spatial Locality: future access will be to nearby addresses</li>
<li>Temporal Locality: future access will be repeats to the same data</li>
</ul>
</li>
<li>
<p>What TLB characteristics are best for each type?</p>
<ul>
<li>
<p>Spatial:</p>
<ul>
<li>Access same page repeatedly; need same vpn à ppn translation</li>
<li>Same TLB entry re-used</li>
</ul>
</li>
<li>
<p>Temporal:</p>
<ul>
<li>Access same address near in future</li>
<li>Same TLB entry re-used in near future</li>
<li>How near in future? How many TLB entries are there?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Replacement policies</p>
<ul>
<li>LRU: evict Least-Recently Used TLB slot when needed</li>
<li>Random: Evict randomly choosen entry</li>
</ul>
</li>
</ul>
<h3 id="context-switches"><a class="markdownIt-Anchor" href="#context-switches"></a> Context Switches</h3>
<ul>
<li>
<p>What happens if a process uses cached TLB entries from another process?</p>
<ol>
<li>
<p>Flush TLB on each switch</p>
<ul>
<li>Costly</li>
<li>lose all recently cached translations</li>
</ul>
</li>
<li>
<p>Track which entries are for which process</p>
<ul>
<li>Address Space Identifier</li>
<li>Tag each TLB entry with an 8-bit ASID</li>
</ul>
</li>
</ol>
</li>
<li>
<p>TLB Example with ASID</p>
<ul>
<li>
<p>Pagetable</p>
<ul>
<li>P1 (ASID 11): 1, 5, 4, …</li>
<li>P2 (ASID 12): 6, 2, 3, …</li>
</ul>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>Valid</th>
<th>Virt</th>
<th>Phys</th>
<th>ASID</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>9</td>
<td>11</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>11</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>11</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Memory access</p>
<table>
<thead>
<tr>
<th>Virtual</th>
<th>Physical</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x1444 with ASID 12</td>
<td>0x2444</td>
</tr>
<tr>
<td>load 0x1444 with ASID 11</td>
<td>0x5444</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>TLB Performance</p>
<ul>
<li>
<p>Context switches are expensive</p>
</li>
<li>
<p>Even with ASID, other processes “pollute” TLB</p>
<ul>
<li>Discard process A’s TLB entries for process B’s entries</li>
</ul>
</li>
<li>
<p>Architectures can have multiple TLBs</p>
<ul>
<li>1 TLB for data, 1 TLB for instructions</li>
<li>1 TLB for regular pages, 1 TLB for “super pages”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tlb-misses"><a class="markdownIt-Anchor" href="#tlb-misses"></a> TLB Misses</h3>
<ul>
<li>
<p>Who Handles TLB MISS? Hardware or OS?</p>
</li>
<li>
<p>Hardware: CPU must know where pagetables are</p>
<ul>
<li>CR3 register on x86</li>
<li>Pagetable structure fixed and agreed upon between HW and OS</li>
<li>HW “walks” the pagetable and fills TLB</li>
</ul>
</li>
<li>
<p>OS: “Software-managed TLB”</p>
<ul>
<li>CPU traps into OS upon TLB miss</li>
<li>OS interprets pagetables as it chooses</li>
<li>Modifying TLB entries is privileged</li>
<li>Need same protection bits in TLB as pagetable - rwx</li>
</ul>
</li>
</ul>
<h3 id="summary-2"><a class="markdownIt-Anchor" href="#summary-2"></a> Summary</h3>
<ul>
<li>
<p>Pages are great, but accessing page tables for every memory access is slow</p>
</li>
<li>
<p>Cache recent page translations -&gt; TLB</p>
<ul>
<li>Hardware performs TLB lookup on every memory access</li>
</ul>
</li>
<li>
<p>TLB performance depends strongly on workload</p>
<ul>
<li>Sequential workloads perform well</li>
<li>Workloads with temporal locality can perform well</li>
</ul>
</li>
<li>
<p>In different systems, hardware or OS handles TLB misses</p>
</li>
<li>
<p>TLBs increase cost of context switches</p>
<ul>
<li>Flush TLB on every context switch</li>
<li>Add ASID to every TLB entry</li>
</ul>
</li>
</ul>
<h2 id="smaller-page-tables"><a class="markdownIt-Anchor" href="#smaller-page-tables"></a> Smaller Page Tables</h2>
<h3 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h3>
<ul>
<li>
<p>How big are page tables</p>
<ol>
<li>
<p>PTE’s are 2 bytes, and 32 possible virtual page numbers</p>
<ul>
<li>2 bytes * 32 = 64 bytes</li>
</ul>
</li>
<li>
<p>PTE’s are 2 bytes, virtual addrs are 24 bits, pages are 16 bytes</p>
<ul>
<li>16 bytes page =&gt; 4 bit offset =&gt; 20 bit VPN</li>
<li>=&gt; 2^20 Pages =&gt;  2^20 * 2 = 2MB for page tables</li>
</ul>
</li>
<li>
<p>PTE’s are 4 bytes, virtual addrs are 32 bits, and pages are 4 KB</p>
<ul>
<li>4KB page =&gt; 12 bit offset =&gt; 20 bit VPN</li>
<li>=&gt; 2^20 Pages =&gt;  2^20 * 4 = 4MB for page tables</li>
</ul>
</li>
<li>
<p>PTE’s are 4 bytes, virtual addrs are 64 bits, and pages are 4 KB</p>
<ul>
<li>4KB page =&gt; 12 bit offset =&gt; 52 bit VPN</li>
<li>=&gt; 2^52 Pages =&gt;  2^52 * 4 = 18.0143985 PB for page tables</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Why are Page Tables so Large?</p>
<ul>
<li>Many invalid PT entries</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/hw6UrkL.png" alt=""></p>
<ul>
<li>Summary
<ul>
<li>
<p>Storage for page tables may be substantial</p>
</li>
<li>
<p>Simple page table: Requires PTE for all pages in address space</p>
</li>
<li>
<p>Entry needed even if page not allocated.</p>
</li>
</ul>
</li>
</ul>
<h3 id="smaller-page-tables-2"><a class="markdownIt-Anchor" href="#smaller-page-tables-2"></a> Smaller Page Tables</h3>
<ul>
<li>
<p>Use more complex page tables, instead of just big array</p>
</li>
<li>
<p>Any data structure is possible with software-managed TLB</p>
<ul>
<li>
<p>Hardware looks for vpn in TLB on every memory access</p>
</li>
<li>
<p>If TLB does not contain vpn, TLB miss</p>
<ul>
<li>Trap into OS and let OS find vpn-&gt;ppn translation</li>
<li>OS notifies TLB of vpn-&gt;ppn for future accesses</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Other approaches</p>
<ol>
<li>
<p>Segmented Pagetables</p>
</li>
<li>
<p>Multi-level Pagetables</p>
<ul>
<li>Page the page tables</li>
<li>Page the pagetables of page tables…</li>
</ul>
</li>
<li>
<p>Inverted Pagetables</p>
</li>
</ol>
</li>
</ul>
<h3 id="paging-with-segmentation"><a class="markdownIt-Anchor" href="#paging-with-segmentation"></a> Paging with Segmentation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>
<p>Divide address space into segments (code, heap, stack)</p>
</li>
<li>
<p>Divide each segment into fixed-sized pages</p>
</li>
<li>
<p>Logical address divided into three portions</p>
<table>
<thead>
<tr>
<th>seg # (4 bits)</th>
<th>page number (8 bits)</th>
<th>page offset (12 bits)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li>Each segment has a page table</li>
<li>Each segment track base (physical address) and bounds of the page table</li>
</ul>
</li>
<li>
<p>Quiz</p>
<ul>
<li>
<p>Logical address layout</p>
<table>
<thead>
<tr>
<th>seg # (4 bits)</th>
<th>page number (8 bits)</th>
<th>page offset (12 bits)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>Segment Table</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>Bounds</th>
<th>R W</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x002000</td>
<td>0xff</td>
<td>1 0</td>
</tr>
<tr>
<td>1</td>
<td>0x000000</td>
<td>0x00</td>
<td>0 0</td>
</tr>
<tr>
<td>2</td>
<td>0x001000</td>
<td>0x0f</td>
<td>1 1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Translation</p>
<table>
<thead>
<tr>
<th>Virtual</th>
<th>Seg</th>
<th>Base</th>
<th>Offset</th>
<th>PPN</th>
<th>Physical</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x002070 R</td>
<td>0</td>
<td>0x002000</td>
<td>2</td>
<td>0x004</td>
<td>0x004070</td>
<td></td>
</tr>
<tr>
<td>0x202016 R</td>
<td>2</td>
<td>0x001000</td>
<td>2</td>
<td>0x003</td>
<td>0x003016</td>
<td></td>
</tr>
<tr>
<td>0x104c84 R</td>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>R = 0</td>
</tr>
<tr>
<td>0x010424 W</td>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>W = 0</td>
</tr>
<tr>
<td>0x210014 W</td>
<td>2</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>bounds</td>
</tr>
<tr>
<td>0x203568 W</td>
<td>2</td>
<td>0x001000</td>
<td>3</td>
<td>0x02a</td>
<td>0x02a568</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>
<p>Advantages of Segments</p>
<ul>
<li>Supports sparse address spaces.</li>
<li>Decreases size of page tables. If segment not used, not need for page table</li>
</ul>
</li>
<li>
<p>Advantages of Pages</p>
<ul>
<li>No external fragmentation</li>
<li>Segments can grow without any reshuffling</li>
<li>Can run process when some pages are swapped to disk (next lecture)</li>
</ul>
</li>
<li>
<p>Advantages of Both</p>
<ul>
<li>Increases flexibility of sharing: Share either single page or entire segment</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Potentially large page tables (for each segment)</li>
<li>Must allocate each page table contiguously</li>
<li>More problematic with more address bits</li>
</ul>
</li>
</ul>
<h3 id="multilevel-page-tables"><a class="markdownIt-Anchor" href="#multilevel-page-tables"></a> Multilevel Page Tables</h3>
<ul>
<li>
<p>Goal: Allow each page tables to be allocated non-contiguously</p>
</li>
<li>
<p>Idea: Page the page tables</p>
<ul>
<li>Creates multiple levels of page tables; outer level “page directory”</li>
<li>Only allocate page tables for pages in use</li>
<li>Used in x86 architectures (hardware can walk known structure)</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/9bSULQI.png" alt=""></p>
<ul>
<li>
<p>Multilevel Pagetable Translation</p>
<ul>
<li>
<p>Page directory and page tables</p>
<table>
<thead>
<tr>
<th></th>
<th>0x0</th>
<th>0x1</th>
<th>…</th>
<th>0xE</th>
<th>0xF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page directory</td>
<td>0x3</td>
<td>-</td>
<td>…</td>
<td>-</td>
<td>0x92</td>
</tr>
<tr>
<td>PT @PPN 0x3</td>
<td>0x10</td>
<td>0x23</td>
<td>…</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>PT @PPN 0x92</td>
<td>-</td>
<td>-</td>
<td>…</td>
<td>0x55</td>
<td>0x45</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Address layout</p>
<table>
<thead>
<tr>
<th>outer page (4)</th>
<th>inner page (4)</th>
<th>page offset (12)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
<ol>
<li>
<p>Translate 0x01ABC</p>
<ul>
<li>Outer page = 0x0 =&gt; Use page table at 0x3</li>
<li>Inner page = 0x1 =&gt; PPN = 0x23</li>
<li>Physical address = 0x23ABC</li>
</ul>
</li>
<li>
<p>Translate 0xFEED0</p>
<ul>
<li>Outer page = 0xF =&gt; Use page table at 0x92</li>
<li>Inner page = 0xE =&gt; PPN = 0x55</li>
<li>Physical address = 0x55ED0</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Address Format for Multilevel Paging</p>
<ul>
<li>Given 30-bit address with 4KB page size</li>
<li>#bits for page offset = log(4K) = 12</li>
<li>4 bytes per PTE =&gt; 1K entries per page =&gt; #bits for inner page = log(1K) = 10</li>
<li>#bits for outer page = 30 - 10 - 12 = 8</li>
</ul>
</li>
<li>
<p>Pagetable with 3 levels</p>
<ul>
<li>
<p>Problem</p>
<ul>
<li>Page directories (outer level) may not fit in a page</li>
</ul>
</li>
<li>
<p>Solution</p>
<ul>
<li>Split page directories into pieces</li>
<li>Use another page dir to refer to the page dir pieces.</li>
</ul>
</li>
<li>
<p>Memory Addressability Comparison</p>
<ul>
<li>1 level = 2<sup>10</sup> * 2<sup>12</sup> = 4MB</li>
<li>2 level = (2<sup>10</sup>)<sup>2</sup> * 2<sup>12</sup> = 4GB</li>
<li>3 level = (2<sup>10</sup>)<sup>3</sup> * 2<sup>12</sup> = 4TB</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Quiz: Count Memory Access</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>3-level page table</li>
<li>256-byte pages</li>
<li>16-bit addresses</li>
<li>ASIC of current process is 211</li>
</ul>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>ASID</th>
<th>VPN</th>
<th>PFN</th>
<th>Valid</th>
</tr>
</thead>
<tbody>
<tr>
<td>211</td>
<td>0xbb</td>
<td>0x91</td>
<td>1</td>
</tr>
<tr>
<td>211</td>
<td>0xff</td>
<td>0x23</td>
<td>1</td>
</tr>
<tr>
<td>122</td>
<td>0x05</td>
<td>0x91</td>
<td>1</td>
</tr>
<tr>
<td>211</td>
<td>0x05</td>
<td>0x12</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<ol>
<li>
<p>0xAA10: movl 0x1111, %edi</p>
<ul>
<li>
<p>TLB miss for 0xAA10 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p>
</li>
<li>
<p>TLB miss for 0x1111 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p>
</li>
<li>
<p>Total: 4 memory accesses</p>
</li>
</ul>
</li>
<li>
<p>0xBB13: addl $0x3, %edi</p>
<ul>
<li>TLB hit for 0xBB13 =&gt; 1 access more to get the instruction</li>
</ul>
</li>
<li>
<p>0x0519: movl %edi, 0xFF10</p>
<ul>
<li>
<p>TLB miss for 0x0519 =&gt; 3 memory access for page table + 1 more to get the instruction</p>
</li>
<li>
<p>TLB hit for 0xFF10 =&gt; 1 access more to get the instruction</p>
</li>
<li>
<p>Total: 5 memory accesses</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="inverted-page-table"><a class="markdownIt-Anchor" href="#inverted-page-table"></a> Inverted Page Table</h3>
<ul>
<li>
<p>Only need entries for virtual pages w/ valid physical mappings</p>
</li>
<li>
<p>Naïve approach:</p>
<ul>
<li>Search through data structure &lt;ppn, vpn+asid&gt; to find match</li>
<li>Too much time to search entire table</li>
</ul>
</li>
<li>
<p>Better:</p>
<ul>
<li>Find possible matches entries by hashing vpn+asid</li>
<li>Smaller number of entries to search for exact match</li>
</ul>
</li>
<li>
<p>Managing inverted page table requires software-controlled TLB</p>
</li>
</ul>
<h2 id="swapping"><a class="markdownIt-Anchor" href="#swapping"></a> Swapping</h2>
<h3 id="motivation-2"><a class="markdownIt-Anchor" href="#motivation-2"></a> Motivation</h3>
<ul>
<li>Support processes when not enough physical memory</li>
<li>Single process with very large address space</li>
<li>Multiple processes with combined address spaces</li>
</ul>
<h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3>
<ul>
<li>
<p>OS keeps unreferenced pages on disk</p>
<ul>
<li>Slower, cheaper backing store than memory</li>
</ul>
</li>
<li>
<p>Process can run when not all pages are loaded into main memory</p>
</li>
<li>
<p>OS and hardware cooperate to make large disk seem like memory</p>
<ul>
<li>Same behavior as if all of address space in main memory</li>
</ul>
</li>
</ul>
<h3 id="locality-of-reference"><a class="markdownIt-Anchor" href="#locality-of-reference"></a> Locality of Reference</h3>
<ul>
<li>
<p>Leverage locality of reference within processes</p>
<ul>
<li>Spatial: reference memory addresses near previously referenced addresses</li>
<li>Temporal: reference memory addresses that have referenced in the past</li>
<li>Processes spend majority of time in small portion of code</li>
</ul>
</li>
<li>
<p>Implication:</p>
<ul>
<li>Process only uses small amount of address space at any moment</li>
<li>Only small amount of address space must be resident in physical memory</li>
</ul>
</li>
<li>
<p>Memory Hierarchy</p>
<p><img src="https://i.imgur.com/pi58bfR.png" alt=""></p>
</li>
</ul>
<h3 id="mechanism-2"><a class="markdownIt-Anchor" href="#mechanism-2"></a> Mechanism</h3>
<ul>
<li>
<p>Each page in virtual address space maps to one of three locations:</p>
<ul>
<li>Physical main memory: Small, fast, expensive</li>
<li>Disk (backing store): Large, slow, cheap</li>
<li>Nothing (error): Free</li>
</ul>
</li>
<li>
<p>Extend page tables with an extra bit: present</p>
<ul>
<li>permissions (r/w), valid, present</li>
<li>Page in memory: present bit set in PTE</li>
<li>Page on disk: present bit cleared
<ul>
<li>PTE points to block on disk</li>
<li>Causes trap into OS when page is referenced</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Procedure</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hardware checks TLB</span><br><span class="line"><span class="keyword">if</span> TLB hit</span><br><span class="line">    address translation is done</span><br><span class="line">    page in physical memory</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB miss</span></span><br><span class="line">    Hardware <span class="keyword">or</span> OS walk page tables</span><br><span class="line">    <span class="keyword">if</span> PTE designates page is present</span><br><span class="line">        page in physical memory (i.e., present bit is cleared)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// page fault</span></span><br><span class="line">        Trap into OS (<span class="keyword">not</span> handled by hardware)</span><br><span class="line">        OS selects victim page in memory to replace</span><br><span class="line">        <span class="keyword">if</span> victim page is modified</span><br><span class="line">            write victim page out to disk</span><br><span class="line">        OS reads referenced page from disk into memory</span><br><span class="line">        Page table is updated, present bit is <span class="built_in">set</span></span><br><span class="line">        Process continues execution</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="policy-page-selection"><a class="markdownIt-Anchor" href="#policy-page-selection"></a> Policy: Page selection</h3>
<ul>
<li>
<p>When should a page on disk be brought into memory?</p>
</li>
<li>
<p>Demand paging: Load page only when page fault occurs</p>
<ul>
<li>Intuition: Wait until page must absolutely be in memory</li>
<li>When process starts: No pages are loaded in memory</li>
<li>Problems: Pay cost of page fault for every newly accessed page</li>
</ul>
</li>
<li>
<p>Prepaging (anticipatory, prefetching): Load page before referenced</p>
<ul>
<li>OS predicts future accesses (oracle) and brings pages into memory early</li>
<li>Works well for some access patterns (e.g., sequential)</li>
</ul>
</li>
<li>
<p>Hints: Combine above with user-supplied hints about page references</p>
<ul>
<li>User specifies: may need page in future, don’t need this page anymore, or sequential access pattern, …</li>
<li>Example: madvise() in Unix</li>
</ul>
</li>
</ul>
<h3 id="policy-page-replacement"><a class="markdownIt-Anchor" href="#policy-page-replacement"></a> Policy: Page replacement</h3>
<ul>
<li>
<p>Which resident page in memory should be thrown out to disk?</p>
</li>
<li>
<p>OPT: Replace page not used for longest time in future</p>
<ul>
<li>Advantages: Guaranteed to minimize number of page faults</li>
<li>Disadvantages: Requires that OS predict the future; Not practical, but good for comparison</li>
</ul>
</li>
<li>
<p>FIFO: Replace page that has been in memory the longest</p>
<ul>
<li>Intuition: First referenced long time ago, done with it now</li>
<li>Advantages: Fair: All pages receive equal residency; Easy to implement</li>
<li>Disadvantage: Some pages may always be needed</li>
</ul>
</li>
<li>
<p>LRU: Replace page not used for longest time in past</p>
<ul>
<li>Intuition: Use past to predict the future</li>
<li>Advantages: With locality, LRU approximates OPT</li>
<li>Disadvantages: Harder to implement and does not handle all workloads well</li>
</ul>
</li>
<li>
<p>Comparison</p>
<table>
<thead>
<tr>
<th>LRU, OPT</th>
<th>FIFO</th>
</tr>
</thead>
<tbody>
<tr>
<td>Guaranteed to  have fewer page faults<br>Smaller memory sizes ⊆ larger memory sizes<br>Smaller cache ⊆ bigger cache</td>
<td>Usually have fewer page faults <br>May actually have more page faults!</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="implementing-lru"><a class="markdownIt-Anchor" href="#implementing-lru"></a> Implementing LRU</h3>
<ul>
<li>
<p>Software Perfect LRU</p>
<ul>
<li>OS maintains ordered list of physical pages by reference time</li>
<li>When page is referenced: Move page to front of list</li>
<li>When need victim: Pick page at back of list</li>
<li>Trade-off: Slow on memory reference, fast on replacement</li>
</ul>
</li>
<li>
<p>Hardware Perfect LRU</p>
<ul>
<li>Associate timestamp register with each page</li>
<li>When page is referenced: Store system clock in register</li>
<li>When need victim: Scan through registers to find oldest clock</li>
<li>Trade-off: Fast on memory reference, slow on replacement (especially as size of memory grows)</li>
</ul>
</li>
<li>
<p>Approximating LRU: Clock Algorithm</p>
<ul>
<li>
<p>Hardware</p>
<ul>
<li>Keep use (or reference) bit for each page frame</li>
<li>When page is referenced: set use bit (page was used recently)</li>
</ul>
</li>
<li>
<p>Operating System</p>
<ul>
<li>Page replacement: Look for page with use bit cleared (has not been referenced for a while)</li>
</ul>
<ol>
<li>Keep pointer to last examined page frame</li>
<li>Traverse pages in circular buffer</li>
<li>Clear use bits as search</li>
<li>Stop when find page with already cleared use bit, replace this page</li>
</ol>
</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/WYNCIhZ.png" style="margin:auto; display: block;">
<h2 id="summary-3"><a class="markdownIt-Anchor" href="#summary-3"></a> Summary</h2>
<ul>
<li>
<p>Abstraction: Virtual address space with code, heap, stack</p>
</li>
<li>
<p>Address translation</p>
<ul>
<li>Contiguous memory: base, bounds, segmentation</li>
<li>Using fixed sizes pages with page tables</li>
</ul>
</li>
<li>
<p>Challenges with paging</p>
<ul>
<li>Extra memory references: avoid with TLB</li>
<li>Page table size: avoid with multi-level paging, inverted page tables etc.</li>
</ul>
</li>
<li>
<p>Larger address spaces: Swapping mechanisms, policies (LRU, Clock)</p>
</li>
</ul>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://th2zz.github.io/2019/03/16/Operating System - Virtualization/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/03/19/Database/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Database Management System - Relational Design Theory
          
        </div>
      </a>
    
    
      <a href="/2019/02/11/process control/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Process Control</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'mBc25X7r6Py8UqVWPpKhl5b9-gzGzoHsz',
        app_key: 'IsGMjzFd8QEgy8MACTl8eVu9',
        path: window.location.pathname,
        avatar: 'retro',
        placeholder: '说点什么吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2016-2020
        th2zz
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="th2zz"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['生きるとはつまり螺旋のことだったんだよ！','',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>