<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Computer Science," />










<meta name="description" content="CS537 - Operating System Summary  CPU Virtualization  Process  What is a process  A running program is a process Stream of executing instructions and their “context”   Thread  Can have multiple threa">
<meta name="keywords" content="Computer Science">
<meta property="og:type" content="article">
<meta property="og:title" content="Operating System">
<meta property="og:url" content="http://yoursite.com/2019/03/20/OS/index.html">
<meta property="og:site_name" content="th2zz">
<meta property="og:description" content="CS537 - Operating System Summary  CPU Virtualization  Process  What is a process  A running program is a process Stream of executing instructions and their “context”   Thread  Can have multiple threa">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://i.imgur.com/7hmjTrj.png">
<meta property="og:image" content="https://i.imgur.com/eE325zz.png">
<meta property="og:image" content="https://i.imgur.com/p6B5iuB.png">
<meta property="og:image" content="https://i.imgur.com/4L0JHF6.png">
<meta property="og:image" content="https://i.imgur.com/F97B6qw.png">
<meta property="og:image" content="https://i.imgur.com/aNCUwiF.png">
<meta property="og:image" content="https://i.imgur.com/S8TUga8.png">
<meta property="og:image" content="https://i.imgur.com/RL4PuJC.png">
<meta property="og:image" content="https://i.imgur.com/we79L5F.png">
<meta property="og:image" content="https://i.imgur.com/840IDak.png">
<meta property="og:image" content="https://i.imgur.com/1rZVwO8.png">
<meta property="og:image" content="https://i.imgur.com/Eika7Rs.png">
<meta property="og:image" content="https://i.imgur.com/Qoqdgtb.png">
<meta property="og:image" content="https://i.imgur.com/EuMGAwS.png">
<meta property="og:image" content="https://i.imgur.com/HZcAtTC.png">
<meta property="og:image" content="https://i.imgur.com/uWlRJnw.png">
<meta property="og:image" content="https://i.imgur.com/mEwtslZ.png">
<meta property="og:image" content="https://i.imgur.com/fg4fYXO.png">
<meta property="og:image" content="https://i.imgur.com/b3eYUnz.png">
<meta property="og:image" content="https://i.imgur.com/HWMGImG.png">
<meta property="og:image" content="https://i.imgur.com/iMYOS03.png">
<meta property="og:image" content="https://i.imgur.com/hw6UrkL.png">
<meta property="og:image" content="https://i.imgur.com/9bSULQI.png">
<meta property="og:image" content="https://i.imgur.com/pi58bfR.png">
<meta property="og:image" content="https://i.imgur.com/WYNCIhZ.png">
<meta property="og:image" content="https://i.imgur.com/3DmuMbX.png">
<meta property="og:image" content="https://i.imgur.com/usa8UOF.png">
<meta property="og:image" content="https://i.imgur.com/NVLmaXh.png">
<meta property="og:image" content="https://i.imgur.com/l2lu5Vn.png">
<meta property="og:image" content="https://i.imgur.com/Avi05dZ.png">
<meta property="og:image" content="https://i.imgur.com/cXfmvjp.png">
<meta property="og:image" content="https://i.imgur.com/77XWz8c.png">
<meta property="og:image" content="https://i.imgur.com/dG4Krbd.png">
<meta property="og:image" content="https://i.imgur.com/yJibQZG.png">
<meta property="og:updated_time" content="2019-03-20T19:28:46.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Operating System">
<meta name="twitter:description" content="CS537 - Operating System Summary  CPU Virtualization  Process  What is a process  A running program is a process Stream of executing instructions and their “context”   Thread  Can have multiple threa">
<meta name="twitter:image" content="https://i.imgur.com/7hmjTrj.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/20/OS/"/>





  <title>Operating System | th2zz</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">th2zz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">th2zz's notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tinghe Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="th2zz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Operating System</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T13:00:41-05:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="cs537-operating-system-summary"><a class="markdownIt-Anchor" href="#cs537-operating-system-summary"></a> <strong>CS537 - Operating System Summary</strong></h1>
<h1 id="cpu-virtualization"><a class="markdownIt-Anchor" href="#cpu-virtualization"></a> CPU Virtualization</h1>
<h2 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process</h2>
<h3 id="what-is-a-process"><a class="markdownIt-Anchor" href="#what-is-a-process"></a> What is a process</h3>
<ul>
<li>A running program is a process</li>
<li>Stream of executing instructions and their “context”</li>
</ul>
<h3 id="thread"><a class="markdownIt-Anchor" href="#thread"></a> Thread</h3>
<ul>
<li>Can have multiple threads within a single process</li>
<li>Lightweight process</li>
<li>Share an address space</li>
</ul>
<h3 id="why-do-we-need-processes"><a class="markdownIt-Anchor" href="#why-do-we-need-processes"></a> Why do we need processes?</h3>
<ul>
<li>Share CPU: Time sharing</li>
</ul>
<h3 id="os-scheduler"><a class="markdownIt-Anchor" href="#os-scheduler"></a> OS Scheduler</h3>
<ul>
<li>Scheduler save context when process is pause</li>
<li>Restore context on resumption</li>
</ul>
<h3 id="goals-for-cpu-virtualization"><a class="markdownIt-Anchor" href="#goals-for-cpu-virtualization"></a> Goals for CPU Virtualization</h3>
<ul>
<li>
<p>Policy goals</p>
<ul>
<li>Virtualize CPU resource using processes</li>
<li>Reschedule process for fairness? efficiency?</li>
</ul>
</li>
<li>
<p>Mechanism goals</p>
<ul>
<li>Efficiency: Time sharing should not add overhead</li>
<li>Control: OS should be able to intervene when required</li>
</ul>
</li>
</ul>
<h2 id="mechanism"><a class="markdownIt-Anchor" href="#mechanism"></a> Mechanism</h2>
<h3 id="system-call"><a class="markdownIt-Anchor" href="#system-call"></a> System call</h3>
<ul>
<li>
<p>User mode and kernel mode</p>
<ul>
<li>User processes run in user mode (restricted mode)</li>
<li>OS runs in kernel mode (not restricted)</li>
</ul>
</li>
<li>
<p>System call</p>
<ul>
<li>Separate user mode from kernel mode for security</li>
<li>Use system call to invoke kernel mode functions</li>
</ul>
</li>
<li>
<p>Procedure for calling read()</p>
<ol>
<li>Set system call table index to 6 <code>movl $6, %eax</code></li>
<li>Call trap with id 64 <code>int $64</code></li>
</ol>
</li>
</ul>
<p><img src="https://i.imgur.com/7hmjTrj.png" alt=""></p>
<h3 id="dispatch-mechanism"><a class="markdownIt-Anchor" href="#dispatch-mechanism"></a> Dispatch mechanism</h3>
<ul>
<li>
<p>Dispatch loop</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;	</span><br><span class="line">    run	process	A for some time-slice	</span><br><span class="line">    stop process A and save its context	</span><br><span class="line">    load context of another process B	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Cooperative Multi-tasking</p>
<ul>
<li>Trust process to relinquish CPU through traps</li>
<li>Provide special yield() system call</li>
<li>Processes can <strong>misbehave</strong></li>
</ul>
</li>
<li>
<p>Timer-based Multi-tasking</p>
<ul>
<li>Hardware generates timer interrupt (CPU or separate chip)</li>
<li>User must not be able to mask timer interrupt</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/eE325zz.png" alt=""></p>
<h2 id="policy"><a class="markdownIt-Anchor" href="#policy"></a> Policy</h2>
<h3 id="vocabulary"><a class="markdownIt-Anchor" href="#vocabulary"></a> Vocabulary</h3>
<ul>
<li>Workload: set of jobs (arrival time, run_time)</li>
<li>Job ~ Current execution of a process</li>
<li>Scheduler: Decides which ready job to run</li>
<li>Metric: measurement of scheduling quality</li>
<li>Turnaround time = completion time - arrival time</li>
<li>Response time = first run time - arrival time</li>
</ul>
<h3 id="fifo-first-in-first-out"><a class="markdownIt-Anchor" href="#fifo-first-in-first-out"></a> FIFO (First In, First Out)</h3>
<ul>
<li>Disadvantage: Turnaround time suffers when short jobs must wait for long jobs (Convoy Effect)</li>
</ul>
<img src="https://i.imgur.com/p6B5iuB.png" width="75%" style="margin:auto; display: block;">
<h3 id="sjf-shortest-job-first"><a class="markdownIt-Anchor" href="#sjf-shortest-job-first"></a> SJF (Shortest job first)</h3>
<ul>
<li>Disadvantage: Only schedule new job when previous job voluntarily relinquishes CPU</li>
</ul>
<img src="https://i.imgur.com/4L0JHF6.png" width="75%" style="margin:auto; display: block;">
<h3 id="stcf-shortest-time-to-completion-first"><a class="markdownIt-Anchor" href="#stcf-shortest-time-to-completion-first"></a> STCF (Shortest Time-to-Completion First)</h3>
<ul>
<li>Preemptive: Schedule different job by taking CPU away from running job</li>
<li>Always run job that will complete the quickest</li>
</ul>
<img src="https://i.imgur.com/F97B6qw.png" width="75%" style="margin:auto; display: block;">
<h3 id="round-robin"><a class="markdownIt-Anchor" href="#round-robin"></a> Round Robin</h3>
<ul>
<li>Goal: reduce response time</li>
<li>Trade-off: increase turnaround time</li>
</ul>
<img src="https://i.imgur.com/aNCUwiF.png" width="75%" style="margin:auto; display: block;">
<h3 id="io-aware-scheduling"><a class="markdownIt-Anchor" href="#io-aware-scheduling"></a> I/O Aware Scheduling</h3>
<ul>
<li>Goal: process won’t hold CPU when doing IO</li>
</ul>
<img src="https://i.imgur.com/S8TUga8.png" width="75%" style="margin:auto; display: block;">
<h3 id="multilevel-feedback-queue"><a class="markdownIt-Anchor" href="#multilevel-feedback-queue"></a> Multilevel Feedback Queue</h3>
<ul>
<li>
<p>Motivation: Run-time of each job is not known</p>
</li>
<li>
<p>Approach</p>
<ul>
<li>Multiple levels of round-robin</li>
<li>Each level has higher priority than lower level</li>
<li>Can preempt them</li>
</ul>
</li>
<li>
<p>Rules</p>
<ol>
<li>If priority(A) &gt; Priority(B), A runs</li>
<li>If priority(A) == Priority(B), A &amp; B run in RR</li>
<li>Processes start at top priority</li>
<li>If job uses whole slice, demote process (longer time slices at lower priorities)</li>
</ol>
</li>
<li>
<p>Avoid starvation</p>
<ul>
<li>Problem: Low priority job may never get scheduled</li>
<li>Solution: Periodically boost priority of all jobs (or all jobs thathaven’t been scheduled)</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/RL4PuJC.png" width="50%" style="margin:auto; display: block;">
<h1 id="memory-virtualization"><a class="markdownIt-Anchor" href="#memory-virtualization"></a> Memory Virtualization</h1>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<h3 id="goals"><a class="markdownIt-Anchor" href="#goals"></a> Goals</h3>
<ul>
<li><strong>Transparency</strong>: Process is unaware of sharing</li>
<li><strong>Protection</strong>: Cannot corrupt OS or other process memory</li>
<li><strong>Efficiency</strong>: Do not waste memory or slow down processes</li>
<li><strong>Sharing</strong>: Enable sharing between cooperating processes</li>
</ul>
<h3 id="address-space"><a class="markdownIt-Anchor" href="#address-space"></a> Address space</h3>
<ul>
<li>Stack: No fragmentation</li>
<li>Heap: Consists of allocated and free areas (holes)<br>
<img src="https://i.imgur.com/we79L5F.png" alt=""></li>
</ul>
<h3 id="memory-access-example"><a class="markdownIt-Anchor" href="#memory-access-example"></a> Memory Access Example</h3>
<table>
<thead>
<tr>
<th>Assembly</th>
<th>Access for Instruction</th>
<th>Access for Execution</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x10: movl 0x8(%rbp), %edi</code></td>
<td>Fetch instruction at 0x10</td>
<td>Load from 0x208</td>
</tr>
<tr>
<td><code>0x13: addl $0x3, %edi</code></td>
<td>Fetch instruction at 0x13</td>
<td>No memory access</td>
</tr>
<tr>
<td><code>0x19: movl %edi, 0x8(%rbp)</code></td>
<td>Fetch instruction at 0x19</td>
<td>Store to 0x208</td>
</tr>
</tbody>
</table>
<h2 id="basic-mechanisms"><a class="markdownIt-Anchor" href="#basic-mechanisms"></a> Basic Mechanisms</h2>
<h3 id="time-sharing"><a class="markdownIt-Anchor" href="#time-sharing"></a> Time Sharing</h3>
<ul>
<li>On process switch, save current process’s memory to disk and load another process’s memory from disk.</li>
<li>Ridiculously poor performance</li>
</ul>
<h3 id="static-relocation"><a class="markdownIt-Anchor" href="#static-relocation"></a> Static Relocation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>OS rewrites each program before loading it as a process in memory</li>
<li>Each rewrite for different process uses different addresses and pointers</li>
<li>Change jumps, loads of static data</li>
</ul>
</li>
<li>
<p>Disadvantage</p>
<ul>
<li>Process can destroy OS or other processes</li>
<li>No privacy</li>
<li>Cannot move address space after it has been placed</li>
<li>May not be able to allocate new process</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/840IDak.png" alt=""></p>
<h3 id="dynamic-relocation-introduction"><a class="markdownIt-Anchor" href="#dynamic-relocation-introduction"></a> Dynamic Relocation: Introduction</h3>
<ul>
<li>
<p>Goal: Protect processes from one another</p>
</li>
<li>
<p>Memory Management Unit (MMU)</p>
<ul>
<li>MMU dynamically changes process address at every memory reference</li>
<li>Process generates <strong>logical</strong> or <strong>virtual</strong> addresses (in their address space)</li>
<li>Memory hardware uses <strong>physical</strong> or <strong>real</strong> addresses</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/1rZVwO8.png" alt=""></p>
<ul>
<li>Two operating modes
<ul>
<li>
<p>Kernel mode</p>
<ul>
<li>Can manipulate contents of MMU</li>
<li>Allows OS to access all of physical memory</li>
</ul>
</li>
<li>
<p>User mode</p>
<ul>
<li>Perform translation of logical address to physical address</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="dynamic-relocation-base-register"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-register"></a> Dynamic Relocation: Base Register</h3>
<ul>
<li>Translation on every memory access of user process</li>
<li>MMU adds base register to logical address to form physical address</li>
<li>Store offset in base register</li>
<li>Each process has different value in base register</li>
<li>Dynamic relocation by changing value of base register.</li>
</ul>
<p><img src="https://i.imgur.com/Eika7Rs.png" alt=""></p>
<ul>
<li>
<p>Quiz</p>
<ul>
<li>What entity should do translation of addresses with base register? <strong>Hardware</strong></li>
<li>What entity should modify the base register? <strong>OS</strong></li>
</ul>
</li>
<li>
<p>Problem: No protection</p>
</li>
</ul>
<h3 id="dynamic-relocation-base-bounds"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-bounds"></a> Dynamic Relocation: Base + Bounds</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>limit the address space with a bounds register</li>
<li>Base register: smallest physical addr (or starting location)</li>
<li>Bounds register: size of this process’s virtual address space</li>
<li>OS kills process if process loads/stores beyond bounds</li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li>MMU compares logical address to bounds register</li>
<li>if logical address is greater, then generate error</li>
<li>MMU adds base register to logical address to form physical address</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/Qoqdgtb.png" alt=""></p>
<ul>
<li>
<p>Context switch</p>
<ol>
<li>Change to privileged mode</li>
<li>Save base and bounds registers of old process</li>
<li>Load base and bounds registers of new process</li>
<li>Change to user mode and jump to new process</li>
</ol>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Provides protection (both read and write) across address spaces</li>
<li>Supports dynamic relocation</li>
<li>Simple, inexpensive implementation: Few registers, little logic in MMU</li>
<li>Fast: Add and compare in parallel</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Each process must be allocated contiguously in physical memory</li>
<li>Must allocate memory that may not be used by process</li>
<li>No partial sharing: Cannot share limited parts of address space</li>
</ul>
</li>
</ul>
<h3 id="segmentation"><a class="markdownIt-Anchor" href="#segmentation"></a> Segmentation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>MMU contains Segment Table (per process)</li>
<li>Each segment has own base and bounds, protection bits</li>
<li>Example: 14 bit logical address, 4 segments;</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<p>Segment Table</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>Bounds</th>
<th>R W</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x2000</td>
<td>0x6ff</td>
<td>1 0</td>
</tr>
<tr>
<td>1</td>
<td>0x0000</td>
<td>0x4ff</td>
<td>1 1</td>
</tr>
<tr>
<td>2</td>
<td>0x3000</td>
<td>0xfff</td>
<td>1 1</td>
</tr>
<tr>
<td>3</td>
<td>0x0000</td>
<td>0x000</td>
<td>0 0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Translation</p>
<table>
<thead>
<tr>
<th>Logical address</th>
<th>Segment</th>
<th>Base</th>
<th>Physical address</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0240</td>
<td>0</td>
<td>0x2000</td>
<td>0x2240</td>
</tr>
<tr>
<td>0x1108</td>
<td>1</td>
<td>0x0000</td>
<td>0x1108</td>
</tr>
<tr>
<td>0x256c</td>
<td>2</td>
<td>0x3000</td>
<td>0x356c</td>
</tr>
<tr>
<td>0x3002</td>
<td>3</td>
<td>0x0000</td>
<td>Fail</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>No extra memory access</li>
<li>Enables sparse allocation of address space</li>
<li>Stack and heap can grow independently</li>
<li>Enables sharing of selected segments</li>
<li>Read-only status for code</li>
<li>Supports dynamic relocation of each segment</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Each segment must be allocated contiguously</li>
<li>May not have sufficient physical memory for large segments?</li>
<li>External Fragmentation</li>
</ul>
</li>
</ul>
<h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3>
<table>
<thead>
<tr>
<th>Description</th>
<th>Name of approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>One process uses RAM at a time</td>
<td>Time Sharing</td>
</tr>
<tr>
<td>Rewrite code and addresses before running</td>
<td>Static Relocation</td>
</tr>
<tr>
<td>Add per-process starting location to virt addr to obtain phys addr</td>
<td>Base</td>
</tr>
<tr>
<td>dynamic approach that verifies address is in valid range</td>
<td>Base + Bounds</td>
</tr>
<tr>
<td>Several base+bound pairs per process</td>
<td>Segmentation</td>
</tr>
</tbody>
</table>
<h2 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h2>
<h3 id="fragmentation"><a class="markdownIt-Anchor" href="#fragmentation"></a> Fragmentation</h3>
<ul>
<li>
<p>Definition</p>
<ul>
<li>Free memory that can’t be usefully allocated</li>
</ul>
</li>
<li>
<p>Types of fragmentation</p>
<ul>
<li>External: Visible to allocator (e.g., OS)</li>
<li>Internal: Visible to requester</li>
</ul>
</li>
</ul>
<h3 id="introduction-for-paging"><a class="markdownIt-Anchor" href="#introduction-for-paging"></a> Introduction for Paging</h3>
<ul>
<li>
<p>Goal</p>
<ul>
<li>Eliminate requirement that address space is contiguous</li>
<li>Eliminate external fragmentation</li>
<li>Grow segments as needed</li>
</ul>
</li>
<li>
<p>Idea</p>
<ul>
<li>Divide address spaces and physical memory into fixed-sized pages (usually 4KB)</li>
</ul>
</li>
</ul>
<h3 id="translation-of-page-addresses"><a class="markdownIt-Anchor" href="#translation-of-page-addresses"></a> Translation of Page Addresses</h3>
<ul>
<li>Logical address
<ul>
<li>High-order bits of address designate page number</li>
<li>Low-order bits of address designate offset within page</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/EuMGAwS.png" alt=""></p>
<ul>
<li>
<p>Address Format</p>
<table>
<thead>
<tr>
<th>Page Size</th>
<th>Low Bits</th>
<th>Virt Addr Bits</th>
<th>High Bits</th>
<th>Virt Pages</th>
</tr>
</thead>
<tbody>
<tr>
<td>16 bytes</td>
<td>log(16) = 4</td>
<td>10</td>
<td>10 - 4 = 6</td>
<td>2 ^ 6 = 64</td>
</tr>
<tr>
<td>1 KB</td>
<td>log(1K) = 10</td>
<td>20</td>
<td>20 - 10 = 10</td>
<td>2 ^ 10 = 1024</td>
</tr>
<tr>
<td>1 MB</td>
<td>log(1M) = 20</td>
<td>32</td>
<td>32 - 20 = 12</td>
<td>2 ^ 12 = 4K</td>
</tr>
<tr>
<td>512 bytes</td>
<td>log(512) = 9</td>
<td>16</td>
<td>16 - 9 = 7</td>
<td>2 ^ 7 = 128</td>
</tr>
<tr>
<td>4 KB</td>
<td>log(4K) = 12</td>
<td>32</td>
<td>32 -12 = 20</td>
<td>2 ^ 20 = 1M</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Address Translation</p>
<ul>
<li>Number of bits in virtual address <strong>need not equal</strong> number of bits in physical address</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/HZcAtTC.png" alt=""></p>
<h3 id="pagetables"><a class="markdownIt-Anchor" href="#pagetables"></a> Pagetables</h3>
<ul>
<li>
<p>How should OS translate VPN to PPN?</p>
<ul>
<li>Simple solution: Linear page table aka array</li>
</ul>
</li>
<li>
<p>Example<br>
<img src="https://i.imgur.com/uWlRJnw.png" alt=""></p>
<ul>
<li>Page table for P1: 3, 1, 7, 10</li>
<li>Page table for P2: 0, 4, 2, 6</li>
<li>Page table for P3: 8, 5, 9, 11</li>
</ul>
</li>
<li>
<p>How big is a pagetable</p>
<ul>
<li>Given 32-bit address space, 4KB pages, 4 byte entries</li>
<li>4KB pages =&gt; 12 bit for offset</li>
<li>32-bit address space =&gt; 20 bit for VPN =&gt; 2 ^ 20 = 1MB entries</li>
<li>1MB entries * 4 byte per entry = 4MB</li>
</ul>
</li>
<li>
<p>Where are pagetables stored</p>
<ul>
<li>Store each page table in memory</li>
<li>Hardware finds page table base with register (e.g., CR3 on x86)</li>
</ul>
</li>
<li>
<p>What happens on a context-switch?</p>
<ul>
<li>Change contents of page table base register to newly scheduled process</li>
<li>Save old page table base register in PCB of descheduled process</li>
</ul>
</li>
<li>
<p>What other info is in pagetable entries besides translation?</p>
<ul>
<li>valid bit</li>
<li>protection bits</li>
<li>present bit (needed later)</li>
<li>reference bit (needed later)</li>
<li>dirty bit (needed later)</li>
</ul>
</li>
</ul>
<h3 id="memory-access-with-paging"><a class="markdownIt-Anchor" href="#memory-access-with-paging"></a> Memory Access with Paging</h3>
<ul>
<li>
<p>Given</p>
<ul>
<li>Current instruction: <code>0x0010: movl 0x1100, %edi</code></li>
<li>Assume PT is at phys addr 0x5000</li>
<li>Assume PTE’s are 4 bytes</li>
<li>Assume 4KB pages =&gt; 12 bits for offset</li>
<li>Page table for current process: 2, 0, 80, 99</li>
</ul>
</li>
<li>
<p>Fetch instruction at logical addr 0x0010</p>
<ul>
<li>Access page table to get ppn for vpn 0</li>
<li>Mem ref 1: 0x5000</li>
<li>Learn vpn 0 is at ppn 2</li>
<li>Fetch instruction at 0x2010 (Mem ref 2)</li>
</ul>
</li>
<li>
<p>Exec, load from logical addr 0x1100</p>
<ul>
<li>Access page table to get ppn for vpn 1</li>
<li>Mem ref 3: 0x5000</li>
<li>Learn vpn 1 is at ppn 0</li>
<li>movl from 0x0100 into reg (Mem ref 4)</li>
</ul>
</li>
</ul>
<h3 id="advantages-of-paging"><a class="markdownIt-Anchor" href="#advantages-of-paging"></a> Advantages of Paging</h3>
<ul>
<li>
<p>No external fragmentation</p>
<ul>
<li>Any page can be placed in any frame in physical memory</li>
</ul>
</li>
<li>
<p>Fast to allocate and free</p>
<ul>
<li>Alloc: No searching for suitable free space</li>
<li>Free: Doesn’t have to coalesce with adjacent free space</li>
</ul>
</li>
<li>
<p>Simple to swap-out portions of memory to disk (later lecture)</p>
<ul>
<li>Page size matches disk block size</li>
<li>Can run process when some pages are on disk</li>
<li>Add “present” bit to PTE</li>
</ul>
</li>
</ul>
<h3 id="disadvantages-of-paging"><a class="markdownIt-Anchor" href="#disadvantages-of-paging"></a> Disadvantages of Paging</h3>
<ul>
<li>
<p>Internal fragmentation: Page size may not match size needed by process</p>
<ul>
<li>Wasted memory grows with larger pages</li>
<li>Tension?</li>
</ul>
</li>
<li>
<p>Additional memory reference to page table -&gt; Very inefficient</p>
<ul>
<li>Page table must be stored in memory</li>
<li>MMU stores only base address of page table</li>
</ul>
</li>
<li>
<p>Storage for page tables may be substantial</p>
<ul>
<li>Simple page table: Requires PTE for all pages in address space</li>
<li>Entry needed even if page not allocated?</li>
</ul>
</li>
</ul>
<h3 id="paging-translation-steps"><a class="markdownIt-Anchor" href="#paging-translation-steps"></a> Paging Translation Steps</h3>
<ol>
<li>extract VPN (virt page num) from VA (virt addr)</li>
<li>calculate addr of PTE (page table entry)</li>
<li>read PTE from memory</li>
<li>extract PFN (page frame num)</li>
<li>build PA (phys addr)</li>
<li>read contents of PA from memory into register</li>
</ol>
<h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2>
<h3 id="motivative-example-iterating-array"><a class="markdownIt-Anchor" href="#motivative-example-iterating-array"></a> Motivative Example: Iterating Array</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Memory Access</p>
<table>
<thead>
<tr>
<th>What virtual addresses?</th>
<th>What physical addresses?</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x3000</td>
<td>load 0x100C <br>load 0x7000</td>
</tr>
<tr>
<td>load 0x3004</td>
<td>load 0x100C <br>load 0x7004</td>
</tr>
<tr>
<td>load 0x3008</td>
<td>load 0x100C <br>load 0x7008</td>
</tr>
<tr>
<td>load 0x300C</td>
<td>load 0x100C <br>load 0x7008</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="introduction-2"><a class="markdownIt-Anchor" href="#introduction-2"></a> Introduction</h3>
<ul>
<li>Strategy: Cache Page Translations</li>
<li>TLB stands for Translation Lookaside Buffer<br>
<img src="https://i.imgur.com/mEwtslZ.png" alt=""></li>
</ul>
<h3 id="tlb-organization"><a class="markdownIt-Anchor" href="#tlb-organization"></a> TLB Organization</h3>
<ul>
<li>
<p>TLB Entry</p>
<table>
<thead>
<tr>
<th>Tag (virtual page number)</th>
<th>Physical page number (page table entry)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>Fully associative</p>
<ul>
<li>Any given translation can be anywhere in the TLB</li>
<li>Hardware will search the entire TLB in parallel</li>
</ul>
</li>
</ul>
<h3 id="example-iterating-array-with-tlb"><a class="markdownIt-Anchor" href="#example-iterating-array-with-tlb"></a> Example: Iterating Array with TLB</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Page table for current process (starting at 0x0000)</p>
  <table>
      <tbody>
          <tr>
              <td>PPN</td>
              <td>1</td>
              <td>5</td>
              <td>4</td>
              <td>…</td>
          </tr>
          <tr>
              <td>VPN</td>
              <td>0</td>
              <td>1</td>
              <td>2</td>
              <td>3</td>
          </tr>
      </tbody>
  </table>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>Valid</th>
<th>VPN</th>
<th>PPN</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Memory Access</p>
<table>
<thead>
<tr>
<th>What virtual addresses?</th>
<th>What physical addresses?</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x1000</td>
<td>load 0x0004 <br>load 0x5000</td>
</tr>
<tr>
<td>load 0x1004</td>
<td>(TLB hit) <br>load 0x5004</td>
</tr>
<tr>
<td>load 0x1008</td>
<td>(TLB hit) <br>load 0x5008</td>
</tr>
<tr>
<td>load 0x100C</td>
<td>(TLB hit) <br>load 0x500C</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>load 0x2000</td>
<td>load 0x0008 <br>load 0x4000</td>
</tr>
<tr>
<td>load 0x2004</td>
<td>(TLB hit) <br>load 0x4004</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Performance</p>
<ul>
<li># TLB lookups = number of accesses to a = 2048</li>
<li># TLB misses = 2</li>
<li>Miss rate = 2/2048 = 0.1%</li>
<li>Hit rate = 1 – miss rate = 99.9%</li>
</ul>
</li>
</ul>
<h3 id="tlb-replacement-policies"><a class="markdownIt-Anchor" href="#tlb-replacement-policies"></a> TLB Replacement Policies</h3>
<ul>
<li>
<p>Access Patterns</p>
<ul>
<li>Sequential array accesses almost always hit in TLB: Very fast!</li>
<li>Highly random, with no repeat accesses: Slow</li>
</ul>
</li>
<li>
<p>Code Example</p>
<table>
<thead>
<tr>
<th>Workload A</th>
<th>Workload B</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://i.imgur.com/fg4fYXO.png" alt=""></td>
<td><img src="https://i.imgur.com/b3eYUnz.png" alt=""></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/HWMGImG.png" alt=""></td>
<td><img src="https://i.imgur.com/iMYOS03.png" alt=""></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Workload Locality</p>
<ul>
<li>Spatial Locality: future access will be to nearby addresses</li>
<li>Temporal Locality: future access will be repeats to the same data</li>
</ul>
</li>
<li>
<p>What TLB characteristics are best for each type?</p>
<ul>
<li>
<p>Spatial:</p>
<ul>
<li>Access same page repeatedly; need same vpn à ppn translation</li>
<li>Same TLB entry re-used</li>
</ul>
</li>
<li>
<p>Temporal:</p>
<ul>
<li>Access same address near in future</li>
<li>Same TLB entry re-used in near future</li>
<li>How near in future? How many TLB entries are there?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Replacement policies</p>
<ul>
<li>LRU: evict Least-Recently Used TLB slot when needed</li>
<li>Random: Evict randomly choosen entry</li>
</ul>
</li>
</ul>
<h3 id="context-switches"><a class="markdownIt-Anchor" href="#context-switches"></a> Context Switches</h3>
<ul>
<li>
<p>What happens if a process uses cached TLB entries from another process?</p>
<ol>
<li>
<p>Flush TLB on each switch</p>
<ul>
<li>Costly</li>
<li>lose all recently cached translations</li>
</ul>
</li>
<li>
<p>Track which entries are for which process</p>
<ul>
<li>Address Space Identifier</li>
<li>Tag each TLB entry with an 8-bit ASID</li>
</ul>
</li>
</ol>
</li>
<li>
<p>TLB Example with ASID</p>
<ul>
<li>
<p>Pagetable</p>
<ul>
<li>P1 (ASID 11): 1, 5, 4, …</li>
<li>P2 (ASID 12): 6, 2, 3, …</li>
</ul>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>Valid</th>
<th>Virt</th>
<th>Phys</th>
<th>ASID</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>9</td>
<td>11</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>11</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>11</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Memory access</p>
<table>
<thead>
<tr>
<th>Virtual</th>
<th>Physical</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x1444 with ASID 12</td>
<td>0x2444</td>
</tr>
<tr>
<td>load 0x1444 with ASID 11</td>
<td>0x5444</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>TLB Performance</p>
<ul>
<li>
<p>Context switches are expensive</p>
</li>
<li>
<p>Even with ASID, other processes “pollute” TLB</p>
<ul>
<li>Discard process A’s TLB entries for process B’s entries</li>
</ul>
</li>
<li>
<p>Architectures can have multiple TLBs</p>
<ul>
<li>1 TLB for data, 1 TLB for instructions</li>
<li>1 TLB for regular pages, 1 TLB for “super pages”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tlb-misses"><a class="markdownIt-Anchor" href="#tlb-misses"></a> TLB Misses</h3>
<ul>
<li>
<p>Who Handles TLB MISS? Hardware or OS?</p>
</li>
<li>
<p>Hardware: CPU must know where pagetables are</p>
<ul>
<li>CR3 register on x86</li>
<li>Pagetable structure fixed and agreed upon between HW and OS</li>
<li>HW “walks” the pagetable and fills TLB</li>
</ul>
</li>
<li>
<p>OS: “Software-managed TLB”</p>
<ul>
<li>CPU traps into OS upon TLB miss</li>
<li>OS interprets pagetables as it chooses</li>
<li>Modifying TLB entries is privileged</li>
<li>Need same protection bits in TLB as pagetable - rwx</li>
</ul>
</li>
</ul>
<h3 id="summary-2"><a class="markdownIt-Anchor" href="#summary-2"></a> Summary</h3>
<ul>
<li>
<p>Pages are great, but accessing page tables for every memory access is slow</p>
</li>
<li>
<p>Cache recent page translations -&gt; TLB</p>
<ul>
<li>Hardware performs TLB lookup on every memory access</li>
</ul>
</li>
<li>
<p>TLB performance depends strongly on workload</p>
<ul>
<li>Sequential workloads perform well</li>
<li>Workloads with temporal locality can perform well</li>
</ul>
</li>
<li>
<p>In different systems, hardware or OS handles TLB misses</p>
</li>
<li>
<p>TLBs increase cost of context switches</p>
<ul>
<li>Flush TLB on every context switch</li>
<li>Add ASID to every TLB entry</li>
</ul>
</li>
</ul>
<h2 id="smaller-page-tables"><a class="markdownIt-Anchor" href="#smaller-page-tables"></a> Smaller Page Tables</h2>
<h3 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h3>
<ul>
<li>
<p>How big are page tables</p>
<ol>
<li>
<p>PTE’s are 2 bytes, and 32 possible virtual page numbers</p>
<ul>
<li>2 bytes * 32 = 64 bytes</li>
</ul>
</li>
<li>
<p>PTE’s are 2 bytes, virtual addrs are 24 bits, pages are 16 bytes</p>
<ul>
<li>16 bytes page =&gt; 4 bit offset =&gt; 20 bit VPN</li>
<li>=&gt; 2^20 Pages =&gt;  2^20 * 2 = 2MB for page tables</li>
</ul>
</li>
<li>
<p>PTE’s are 4 bytes, virtual addrs are 32 bits, and pages are 4 KB</p>
<ul>
<li>4KB page =&gt; 12 bit offset =&gt; 20 bit VPN</li>
<li>=&gt; 2^20 Pages =&gt;  2^20 * 4 = 4MB for page tables</li>
</ul>
</li>
<li>
<p>PTE’s are 4 bytes, virtual addrs are 64 bits, and pages are 4 KB</p>
<ul>
<li>4KB page =&gt; 12 bit offset =&gt; 52 bit VPN</li>
<li>=&gt; 2^52 Pages =&gt;  2^52 * 4 = 18.0143985 PB for page tables</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Why are Page Tables so Large?</p>
<ul>
<li>Many invalid PT entries</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/hw6UrkL.png" alt=""></p>
<ul>
<li>Summary
<ul>
<li>
<p>Storage for page tables may be substantial</p>
</li>
<li>
<p>Simple page table: Requires PTE for all pages in address space</p>
</li>
<li>
<p>Entry needed even if page not allocated.</p>
</li>
</ul>
</li>
</ul>
<h3 id="smaller-page-tables-2"><a class="markdownIt-Anchor" href="#smaller-page-tables-2"></a> Smaller Page Tables</h3>
<ul>
<li>
<p>Use more complex page tables, instead of just big array</p>
</li>
<li>
<p>Any data structure is possible with software-managed TLB</p>
<ul>
<li>
<p>Hardware looks for vpn in TLB on every memory access</p>
</li>
<li>
<p>If TLB does not contain vpn, TLB miss</p>
<ul>
<li>Trap into OS and let OS find vpn-&gt;ppn translation</li>
<li>OS notifies TLB of vpn-&gt;ppn for future accesses</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Other approaches</p>
<ol>
<li>
<p>Segmented Pagetables</p>
</li>
<li>
<p>Multi-level Pagetables</p>
<ul>
<li>Page the page tables</li>
<li>Page the pagetables of page tables…</li>
</ul>
</li>
<li>
<p>Inverted Pagetables</p>
</li>
</ol>
</li>
</ul>
<h3 id="paging-with-segmentation"><a class="markdownIt-Anchor" href="#paging-with-segmentation"></a> Paging with Segmentation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>
<p>Divide address space into segments (code, heap, stack)</p>
</li>
<li>
<p>Divide each segment into fixed-sized pages</p>
</li>
<li>
<p>Logical address divided into three portions</p>
<table>
<thead>
<tr>
<th>seg # (4 bits)</th>
<th>page number (8 bits)</th>
<th>page offset (12 bits)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li>Each segment has a page table</li>
<li>Each segment track base (physical address) and bounds of the page table</li>
</ul>
</li>
<li>
<p>Quiz</p>
<ul>
<li>
<p>Logical address layout</p>
<table>
<thead>
<tr>
<th>seg # (4 bits)</th>
<th>page number (8 bits)</th>
<th>page offset (12 bits)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>Segment Table</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>Bounds</th>
<th>R W</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x002000</td>
<td>0xff</td>
<td>1 0</td>
</tr>
<tr>
<td>1</td>
<td>0x000000</td>
<td>0x00</td>
<td>0 0</td>
</tr>
<tr>
<td>2</td>
<td>0x001000</td>
<td>0x0f</td>
<td>1 1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Translation</p>
<table>
<thead>
<tr>
<th>Virtual</th>
<th>Seg</th>
<th>Base</th>
<th>Offset</th>
<th>PPN</th>
<th>Physical</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x002070 R</td>
<td>0</td>
<td>0x002000</td>
<td>2</td>
<td>0x004</td>
<td>0x004070</td>
<td></td>
</tr>
<tr>
<td>0x202016 R</td>
<td>2</td>
<td>0x001000</td>
<td>2</td>
<td>0x003</td>
<td>0x003016</td>
<td></td>
</tr>
<tr>
<td>0x104c84 R</td>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>R = 0</td>
</tr>
<tr>
<td>0x010424 W</td>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>W = 0</td>
</tr>
<tr>
<td>0x210014 W</td>
<td>2</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>bounds</td>
</tr>
<tr>
<td>0x203568 W</td>
<td>2</td>
<td>0x001000</td>
<td>3</td>
<td>0x02a</td>
<td>0x02a568</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>
<p>Advantages of Segments</p>
<ul>
<li>Supports sparse address spaces.</li>
<li>Decreases size of page tables. If segment not used, not need for page table</li>
</ul>
</li>
<li>
<p>Advantages of Pages</p>
<ul>
<li>No external fragmentation</li>
<li>Segments can grow without any reshuffling</li>
<li>Can run process when some pages are swapped to disk (next lecture)</li>
</ul>
</li>
<li>
<p>Advantages of Both</p>
<ul>
<li>Increases flexibility of sharing: Share either single page or entire segment</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Potentially large page tables (for each segment)</li>
<li>Must allocate each page table contiguously</li>
<li>More problematic with more address bits</li>
</ul>
</li>
</ul>
<h3 id="multilevel-page-tables"><a class="markdownIt-Anchor" href="#multilevel-page-tables"></a> Multilevel Page Tables</h3>
<ul>
<li>
<p>Goal: Allow each page tables to be allocated non-contiguously</p>
</li>
<li>
<p>Idea: Page the page tables</p>
<ul>
<li>Creates multiple levels of page tables; outer level “page directory”</li>
<li>Only allocate page tables for pages in use</li>
<li>Used in x86 architectures (hardware can walk known structure)</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/9bSULQI.png" alt=""></p>
<ul>
<li>
<p>Multilevel Pagetable Translation</p>
<ul>
<li>
<p>Page directory and page tables</p>
<table>
<thead>
<tr>
<th></th>
<th>0x0</th>
<th>0x1</th>
<th>…</th>
<th>0xE</th>
<th>0xF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page directory</td>
<td>0x3</td>
<td>-</td>
<td>…</td>
<td>-</td>
<td>0x92</td>
</tr>
<tr>
<td>PT @PPN 0x3</td>
<td>0x10</td>
<td>0x23</td>
<td>…</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>PT @PPN 0x92</td>
<td>-</td>
<td>-</td>
<td>…</td>
<td>0x55</td>
<td>0x45</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Address layout</p>
<table>
<thead>
<tr>
<th>outer page (4)</th>
<th>inner page (4)</th>
<th>page offset (12)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
<ol>
<li>
<p>Translate 0x01ABC</p>
<ul>
<li>Outer page = 0x0 =&gt; Use page table at 0x3</li>
<li>Inner page = 0x1 =&gt; PPN = 0x23</li>
<li>Physical address = 0x23ABC</li>
</ul>
</li>
<li>
<p>Translate 0xFEED0</p>
<ul>
<li>Outer page = 0xF =&gt; Use page table at 0x92</li>
<li>Inner page = 0xE =&gt; PPN = 0x55</li>
<li>Physical address = 0x55ED0</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Address Format for Multilevel Paging</p>
<ul>
<li>Given 30-bit address with 4KB page size</li>
<li>#bits for page offset = log(4K) = 12</li>
<li>4 bytes per PTE =&gt; 1K entries per page =&gt; #bits for inner page = log(1K) = 10</li>
<li>#bits for outer page = 30 - 10 - 12 = 8</li>
</ul>
</li>
<li>
<p>Pagetable with 3 levels</p>
<ul>
<li>
<p>Problem</p>
<ul>
<li>Page directories (outer level) may not fit in a page</li>
</ul>
</li>
<li>
<p>Solution</p>
<ul>
<li>Split page directories into pieces</li>
<li>Use another page dir to refer to the page dir pieces.</li>
</ul>
</li>
<li>
<p>Memory Addressability Comparison</p>
<ul>
<li>1 level = 2<sup>10</sup> * 2<sup>12</sup> = 4MB</li>
<li>2 level = (2<sup>10</sup>)<sup>2</sup> * 2<sup>12</sup> = 4GB</li>
<li>3 level = (2<sup>10</sup>)<sup>3</sup> * 2<sup>12</sup> = 4TB</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Quiz: Count Memory Access</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>3-level page table</li>
<li>256-byte pages</li>
<li>16-bit addresses</li>
<li>ASIC of current process is 211</li>
</ul>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>ASID</th>
<th>VPN</th>
<th>PFN</th>
<th>Valid</th>
</tr>
</thead>
<tbody>
<tr>
<td>211</td>
<td>0xbb</td>
<td>0x91</td>
<td>1</td>
</tr>
<tr>
<td>211</td>
<td>0xff</td>
<td>0x23</td>
<td>1</td>
</tr>
<tr>
<td>122</td>
<td>0x05</td>
<td>0x91</td>
<td>1</td>
</tr>
<tr>
<td>211</td>
<td>0x05</td>
<td>0x12</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<ol>
<li>
<p>0xAA10: movl 0x1111, %edi</p>
<ul>
<li>
<p>TLB miss for 0xAA10 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p>
</li>
<li>
<p>TLB miss for 0x1111 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p>
</li>
<li>
<p>Total: 4 memory accesses</p>
</li>
</ul>
</li>
<li>
<p>0xBB13: addl $0x3, %edi</p>
<ul>
<li>TLB hit for 0xBB13 =&gt; 1 access more to get the instruction</li>
</ul>
</li>
<li>
<p>0x0519: movl %edi, 0xFF10</p>
<ul>
<li>
<p>TLB miss for 0x0519 =&gt; 3 memory access for page table + 1 more to get the instruction</p>
</li>
<li>
<p>TLB hit for 0xFF10 =&gt; 1 access more to get the instruction</p>
</li>
<li>
<p>Total: 5 memory accesses</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="inverted-page-table"><a class="markdownIt-Anchor" href="#inverted-page-table"></a> Inverted Page Table</h3>
<ul>
<li>
<p>Only need entries for virtual pages w/ valid physical mappings</p>
</li>
<li>
<p>Naïve approach:</p>
<ul>
<li>Search through data structure &lt;ppn, vpn+asid&gt; to find match</li>
<li>Too much time to search entire table</li>
</ul>
</li>
<li>
<p>Better:</p>
<ul>
<li>Find possible matches entries by hashing vpn+asid</li>
<li>Smaller number of entries to search for exact match</li>
</ul>
</li>
<li>
<p>Managing inverted page table requires software-controlled TLB</p>
</li>
</ul>
<h2 id="swapping"><a class="markdownIt-Anchor" href="#swapping"></a> Swapping</h2>
<h3 id="motivation-2"><a class="markdownIt-Anchor" href="#motivation-2"></a> Motivation</h3>
<ul>
<li>Support processes when not enough physical memory</li>
<li>Single process with very large address space</li>
<li>Multiple processes with combined address spaces</li>
</ul>
<h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3>
<ul>
<li>
<p>OS keeps unreferenced pages on disk</p>
<ul>
<li>Slower, cheaper backing store than memory</li>
</ul>
</li>
<li>
<p>Process can run when not all pages are loaded into main memory</p>
</li>
<li>
<p>OS and hardware cooperate to make large disk seem like memory</p>
<ul>
<li>Same behavior as if all of address space in main memory</li>
</ul>
</li>
</ul>
<h3 id="locality-of-reference"><a class="markdownIt-Anchor" href="#locality-of-reference"></a> Locality of Reference</h3>
<ul>
<li>
<p>Leverage locality of reference within processes</p>
<ul>
<li>Spatial: reference memory addresses near previously referenced addresses</li>
<li>Temporal: reference memory addresses that have referenced in the past</li>
<li>Processes spend majority of time in small portion of code</li>
</ul>
</li>
<li>
<p>Implication:</p>
<ul>
<li>Process only uses small amount of address space at any moment</li>
<li>Only small amount of address space must be resident in physical memory</li>
</ul>
</li>
<li>
<p>Memory Hierarchy</p>
<p><img src="https://i.imgur.com/pi58bfR.png" alt=""></p>
</li>
</ul>
<h3 id="mechanism-2"><a class="markdownIt-Anchor" href="#mechanism-2"></a> Mechanism</h3>
<ul>
<li>
<p>Each page in virtual address space maps to one of three locations:</p>
<ul>
<li>Physical main memory: Small, fast, expensive</li>
<li>Disk (backing store): Large, slow, cheap</li>
<li>Nothing (error): Free</li>
</ul>
</li>
<li>
<p>Extend page tables with an extra bit: present</p>
<ul>
<li>permissions (r/w), valid, present</li>
<li>Page in memory: present bit set in PTE</li>
<li>Page on disk: present bit cleared
<ul>
<li>PTE points to block on disk</li>
<li>Causes trap into OS when page is referenced</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Procedure</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hardware checks TLB</span><br><span class="line"><span class="keyword">if</span> TLB hit</span><br><span class="line">    address translation is done</span><br><span class="line">    page in physical memory</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB miss</span></span><br><span class="line">    Hardware <span class="keyword">or</span> OS walk page tables</span><br><span class="line">    <span class="keyword">if</span> PTE designates page is present</span><br><span class="line">        page in physical memory (i.e., present bit is cleared)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// page fault</span></span><br><span class="line">        Trap into OS (<span class="keyword">not</span> handled by hardware)</span><br><span class="line">        OS selects victim page in memory to replace</span><br><span class="line">        <span class="keyword">if</span> victim page is modified</span><br><span class="line">            write victim page out to disk</span><br><span class="line">        OS reads referenced page from disk into memory</span><br><span class="line">        Page table is updated, present bit is <span class="built_in">set</span></span><br><span class="line">        Process continues execution</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="policy-page-selection"><a class="markdownIt-Anchor" href="#policy-page-selection"></a> Policy: Page selection</h3>
<ul>
<li>
<p>When should a page on disk be brought into memory?</p>
</li>
<li>
<p>Demand paging: Load page only when page fault occurs</p>
<ul>
<li>Intuition: Wait until page must absolutely be in memory</li>
<li>When process starts: No pages are loaded in memory</li>
<li>Problems: Pay cost of page fault for every newly accessed page</li>
</ul>
</li>
<li>
<p>Prepaging (anticipatory, prefetching): Load page before referenced</p>
<ul>
<li>OS predicts future accesses (oracle) and brings pages into memory early</li>
<li>Works well for some access patterns (e.g., sequential)</li>
</ul>
</li>
<li>
<p>Hints: Combine above with user-supplied hints about page references</p>
<ul>
<li>User specifies: may need page in future, don’t need this page anymore, or sequential access pattern, …</li>
<li>Example: madvise() in Unix</li>
</ul>
</li>
</ul>
<h3 id="policy-page-replacement"><a class="markdownIt-Anchor" href="#policy-page-replacement"></a> Policy: Page replacement</h3>
<ul>
<li>
<p>Which resident page in memory should be thrown out to disk?</p>
</li>
<li>
<p>OPT: Replace page not used for longest time in future</p>
<ul>
<li>Advantages: Guaranteed to minimize number of page faults</li>
<li>Disadvantages: Requires that OS predict the future; Not practical, but good for comparison</li>
</ul>
</li>
<li>
<p>FIFO: Replace page that has been in memory the longest</p>
<ul>
<li>Intuition: First referenced long time ago, done with it now</li>
<li>Advantages: Fair: All pages receive equal residency; Easy to implement</li>
<li>Disadvantage: Some pages may always be needed</li>
</ul>
</li>
<li>
<p>LRU: Replace page not used for longest time in past</p>
<ul>
<li>Intuition: Use past to predict the future</li>
<li>Advantages: With locality, LRU approximates OPT</li>
<li>Disadvantages: Harder to implement and does not handle all workloads well</li>
</ul>
</li>
<li>
<p>Comparison</p>
<table>
<thead>
<tr>
<th>LRU, OPT</th>
<th>FIFO</th>
</tr>
</thead>
<tbody>
<tr>
<td>Guaranteed to  have fewer page faults<br>Smaller memory sizes ⊆ larger memory sizes<br>Smaller cache ⊆ bigger cache</td>
<td>Usually have fewer page faults <br>May actually have more page faults!</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="implementing-lru"><a class="markdownIt-Anchor" href="#implementing-lru"></a> Implementing LRU</h3>
<ul>
<li>
<p>Software Perfect LRU</p>
<ul>
<li>OS maintains ordered list of physical pages by reference time</li>
<li>When page is referenced: Move page to front of list</li>
<li>When need victim: Pick page at back of list</li>
<li>Trade-off: Slow on memory reference, fast on replacement</li>
</ul>
</li>
<li>
<p>Hardware Perfect LRU</p>
<ul>
<li>Associate timestamp register with each page</li>
<li>When page is referenced: Store system clock in register</li>
<li>When need victim: Scan through registers to find oldest clock</li>
<li>Trade-off: Fast on memory reference, slow on replacement (especially as size of memory grows)</li>
</ul>
</li>
<li>
<p>Approximating LRU: Clock Algorithm</p>
<ul>
<li>
<p>Hardware</p>
<ul>
<li>Keep use (or reference) bit for each page frame</li>
<li>When page is referenced: set use bit (page was used recently)</li>
</ul>
</li>
<li>
<p>Operating System</p>
<ul>
<li>Page replacement: Look for page with use bit cleared (has not been referenced for a while)</li>
</ul>
<ol>
<li>Keep pointer to last examined page frame</li>
<li>Traverse pages in circular buffer</li>
<li>Clear use bits as search</li>
<li>Stop when find page with already cleared use bit, replace this page</li>
</ol>
</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/WYNCIhZ.png" style="margin:auto; display: block;">
<h2 id="summary-3"><a class="markdownIt-Anchor" href="#summary-3"></a> Summary</h2>
<ul>
<li>
<p>Abstraction: Virtual address space with code, heap, stack</p>
</li>
<li>
<p>Address translation</p>
<ul>
<li>Contiguous memory: base, bounds, segmentation</li>
<li>Using fixed sizes pages with page tables</li>
</ul>
</li>
<li>
<p>Challenges with paging</p>
<ul>
<li>Extra memory references: avoid with TLB</li>
<li>Page table size: avoid with multi-level paging, inverted page tables etc.</li>
</ul>
</li>
<li>
<p>Larger address spaces: Swapping mechanisms, policies (LRU, Clock)</p>
</li>
</ul>
<h1 id="concurrency"><a class="markdownIt-Anchor" href="#concurrency"></a> Concurrency</h1>
<h2 id="thread-2"><a class="markdownIt-Anchor" href="#thread-2"></a> Thread</h2>
<h3 id="processes-vs-thread"><a class="markdownIt-Anchor" href="#processes-vs-thread"></a> Processes vs Thread</h3>
<ul>
<li>
<p>Process</p>
<ul>
<li>Example: Chrome (process per tab)</li>
<li>Communicate via pipe() or similar</li>
<li>Pros: Don’t need new abstractions; good for security</li>
<li>Cons:
<ul>
<li>Cumbersome programming</li>
<li>High communication overheads</li>
<li>Expensive context switching</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Thread</p>
<ul>
<li>Multiple threads of same process share an address space</li>
<li>Divide large task across several cooperative threads</li>
<li>Communicate through shared address space</li>
<li>Shared: page directories, page tables, code segment</li>
<li>Not Shared: instruction pointer, stack</li>
</ul>
</li>
<li>
<p>Multiple threads within a single process share:</p>
<ul>
<li>Process ID (PID)</li>
<li>Address space: Code (instructions), Most data (heap)</li>
<li>Open file descriptors</li>
<li>Current working directory</li>
<li>User and group id</li>
</ul>
</li>
<li>
<p>Each thread has its own</p>
<ul>
<li>Thread ID (TID)</li>
<li>Set of registers, including Program counter and Stack pointer</li>
<li>Stack for local variables and return addresses (in same address space)</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/3DmuMbX.png" alt=""></p>
<h3 id="common-programming-models"><a class="markdownIt-Anchor" href="#common-programming-models"></a> Common Programming Models</h3>
<ul>
<li>
<p>Producer/consumer</p>
<ul>
<li>Multiple producer threads create data (or work) that is handled by one of the multiple consumer threads</li>
</ul>
</li>
<li>
<p>Pipeline</p>
<ul>
<li>Task is divided into series of subtasks, each of which is handled in series by a different thread</li>
</ul>
</li>
<li>
<p>Defer work with background thread</p>
<ul>
<li>One thread performs non-critical work in the background (when CPU idle)</li>
</ul>
</li>
</ul>
<h3 id="user-level-threads-many-to-one"><a class="markdownIt-Anchor" href="#user-level-threads-many-to-one"></a> User-level threads: Many-to-one</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Implemented by user-level runtime libraries</li>
<li>Create, schedule, synchronize threads at user-level</li>
<li>OS is not aware of user-level threads</li>
<li>OS thinks each process contains only a single thread of control</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Does not require OS support; Portable</li>
<li>Can tune scheduling policy to meet application demands</li>
<li>Lower overhead thread operations since no system call</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Cannot leverage multiprocessors</li>
<li>Entire process blocks when one thread blocks</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/usa8UOF.png" width="50%" style="margin:auto; display: block;">
<h3 id="kernel-level-threads-one-to-one"><a class="markdownIt-Anchor" href="#kernel-level-threads-one-to-one"></a> Kernel-level threads: One-to-one</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>OS provides each user-level thread with a kernel thread</li>
<li>Each kernel thread scheduled independently</li>
<li>Thread operations (creation, scheduling, synchronization) performed by OS</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Each kernel-level thread can run in parallel on a multiprocessor</li>
<li>When one thread blocks, other threads from process can be scheduled</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Higher overhead for thread operations</li>
<li>OS must scale well with increasing number of threads</li>
</ul>
</li>
</ul>
 <img src="https://i.imgur.com/NVLmaXh.png" width="50%" style="margin:auto; display: block;">
<h3 id="thread-schedule-examples"><a class="markdownIt-Anchor" href="#thread-schedule-examples"></a> Thread Schedule Examples</h3>
<ul>
<li>
<p>Assume <code>M[0x123]</code> = 100 initially, and we want to increment it by 1 twice</p>
</li>
<li>
<p>Example 1</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br><br><br><br></td>
<td><br><br><br><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 102<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 102</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Example 2</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br><br><br><br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br></td>
<td><br><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br><br><br></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="non-determinism"><a class="markdownIt-Anchor" href="#non-determinism"></a> Non-Determinism</h3>
<ul>
<li>
<p>Concurrency leads to non-deterministic results</p>
<ul>
<li>Different results even with same inputs</li>
<li>race conditions</li>
</ul>
</li>
<li>
<p>Whether bug manifests depends on CPU schedule!</p>
</li>
<li>
<p>How to program: imagine scheduler is malicious?!</p>
</li>
</ul>
<h3 id="what-do-we-want"><a class="markdownIt-Anchor" href="#what-do-we-want"></a> What do we want?</h3>
<ul>
<li>
<p>Want 3 instructions to execute as an uninterruptable group</p>
</li>
<li>
<p>That is, we want them to be atomic</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x123, %eax </span><br><span class="line">add $0x1, %eax  </span><br><span class="line">mov %eax, 0x123</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>More general: Need mutual exclusion for critical sections</p>
<ul>
<li>if thread A is in critical section C, thread B isn’t</li>
<li>(okay if other threads do unrelated work)</li>
</ul>
</li>
</ul>
<h3 id="synchronization"><a class="markdownIt-Anchor" href="#synchronization"></a> Synchronization</h3>
<ul>
<li>Build higher-level synchronization primitives in OS</li>
<li>Operations that ensure correct ordering of instructions across threads</li>
<li>Use help from hardware</li>
</ul>
<h3 id="concurrency-objective"><a class="markdownIt-Anchor" href="#concurrency-objective"></a> Concurrency Objective</h3>
<ul>
<li>
<p>Mutual exclusion (e.g., A and B don’t run at same time)</p>
<ul>
<li>solved with locks</li>
</ul>
</li>
<li>
<p>Ordering (e.g., B runs after A does something)</p>
<ul>
<li>solved with condition variables and semaphores</li>
</ul>
</li>
</ul>
<h3 id="summary-4"><a class="markdownIt-Anchor" href="#summary-4"></a> Summary</h3>
<ul>
<li>Concurrency is needed for high performance when using multiple cores</li>
<li>Threads are multiple execution streams within a single process or address space (share PID and address space, own registers and stack)</li>
<li>Context switches within a critical section can lead to non-deterministic bugs</li>
</ul>
<h2 id="locks"><a class="markdownIt-Anchor" href="#locks"></a> Locks</h2>
<h3 id="introduction-3"><a class="markdownIt-Anchor" href="#introduction-3"></a> Introduction</h3>
<ul>
<li>
<p>Goal: Provide mutual exclusion (mutex)</p>
</li>
<li>
<p>Atomic operation: No other instructions can be interleaved</p>
</li>
</ul>
<ol>
<li>Allocate and Initialize
<ul>
<li>
<figure class="highlight plain"><figcaption><span>mylock </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2. Acquire</span><br><span class="line">    - Acquire exclusion access to lock;</span><br><span class="line">    - Wait if lock is not available (some other process in critical section)</span><br><span class="line">    - Spin or block (relinquish CPU) while waiting</span><br><span class="line">    - `Pthread_mutex_lock(&amp;mylock);`</span><br><span class="line"></span><br><span class="line">3. Release</span><br><span class="line">    - Release exclusive access to lock; let another process enter critical section</span><br><span class="line">    - `Pthread_mutex_unlock(&amp;mylock);`</span><br><span class="line"></span><br><span class="line">### Implementation Goals</span><br><span class="line">- Correctness</span><br><span class="line">    - Mutual exclusion</span><br><span class="line">        - Only one thread in critical section at a time</span><br><span class="line">    - Progress (deadlock-free) </span><br><span class="line">        - If several simultaneous requests, must allow one to proceed</span><br><span class="line">        - Deadlock happens when all threads are waiting for lock</span><br><span class="line"></span><br><span class="line">    - Bounded (starvation-free)</span><br><span class="line">        - Must eventually allow each waiting thread to enter</span><br><span class="line">        - The waiting time for lock is bounded</span><br><span class="line"></span><br><span class="line">- Fairness: Each thread waits for same amount of time</span><br><span class="line">- Performance: CPU is not used unnecessarily</span><br><span class="line"></span><br><span class="line">### Spin Lock with Interrupts</span><br><span class="line">- Idea</span><br><span class="line">    - Turn off interrupts for critical sections</span><br><span class="line">    - Prevent dispatcher from running another thread</span><br><span class="line">    - Code between interrupts executes atomically</span><br><span class="line"></span><br><span class="line">- Implementation code</span><br><span class="line">    ```c=</span><br><span class="line">    void acquire(lockT *l) &#123;</span><br><span class="line">        disableInterrupts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void release(lockT *l)  &#123; </span><br><span class="line">        enableInterrupts(); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>Disadvantages
<ul>
<li>Only works on uniprocessors</li>
<li>Process can keep control of CPU for arbitrary length</li>
<li>Cannot perform other necessary work</li>
</ul>
</li>
</ul>
<h3 id="spin-lock-with-load-store"><a class="markdownIt-Anchor" href="#spin-lock-with-load-store"></a> Spin Lock with Load + Store</h3>
<ul>
<li>
<p>Idea: uses a single <strong>shared</strong> lock variable</p>
</li>
<li>
<p>Implementation code</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared variable </span></span><br><span class="line">boolean lock = <span class="literal">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(Boolean *lock)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (*lock) <span class="comment">/* wait */</span> ; </span><br><span class="line">    *lock = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Boolean *lock)</span> </span>&#123; </span><br><span class="line">    *lock = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Race condition</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>while (*lock)</code><br><br><br> <code>lock = true;</code></td>
<td><br><code>while (*lock)</code> <br> <code>*lock = true;</code><br><br></td>
</tr>
</tbody>
</table>
<ul>
<li>Both threads grab lock!</li>
<li>Problem: Testing lock and setting lock are not atomic</li>
</ul>
</li>
</ul>
<h3 id="spin-lock-with-xchg"><a class="markdownIt-Anchor" href="#spin-lock-with-xchg"></a> Spin Lock with xchg</h3>
<ul>
<li>
<p>xchg: Atomic exchange or test-and-set</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return what was pointed to by addr</span></span><br><span class="line"><span class="comment">// at the same time, store newval into addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *addr;</span><br><span class="line">    *addr = newval;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implementation code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; <span class="comment">// 0 =&gt; unlocked; 1 =&gt; locked</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit loop when flag changed from 0 (unlocked) to 1 (locked)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; <span class="comment">// set the flag to 0 (unlocked)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="spin-lock-with-cas"><a class="markdownIt-Anchor" href="#spin-lock-with-cas"></a> Spin Lock with CAS</h3>
<ul>
<li>
<p>CAS: Compare and Swap</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomic instruction</span></span><br><span class="line"><span class="comment">// set newval to *addr when *addr == expected</span></span><br><span class="line"><span class="comment">// return what was pointed to by addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> expected, <span class="keyword">int</span> newval)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> actual = *addr; </span><br><span class="line">    <span class="keyword">if</span> (actual == expected)  </span><br><span class="line">        *addr = newval; </span><br><span class="line">    <span class="keyword">return</span> actual; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implementation code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin-wait (do nothing)  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Exercise with xchg and CAS</p>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = xchg(&amp;a, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> c = CompareAndSwap(&amp;b, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> d = CompareAndSwap(&amp;b, <span class="number">1</span>, <span class="number">3</span>) ;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Result:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h3 id="ticket-locks"><a class="markdownIt-Anchor" href="#ticket-locks"></a> Ticket Locks</h3>
<ul>
<li>
<p>Basic spinlocks are unfair</p>
<p><img src="https://i.imgur.com/l2lu5Vn.png" alt=""></p>
<ul>
<li>Scheduler is unaware of locks/unlocks!</li>
</ul>
</li>
<li>
<p>Introduction to Ticket Locks</p>
<ul>
<li>
<p>Idea: reserve each thread’s turn to use a lock.</p>
</li>
<li>
<p>Each thread spins until their turn.</p>
</li>
<li>
<p>Use new atomic primitive, fetch-and-add</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> old = *ptr; </span><br><span class="line">    *ptr = old + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> old; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Acquire: Grab ticket; Spin while not thread’s ticket != turn</p>
</li>
<li>
<p>Release: Advance to next turn</p>
</li>
</ul>
</li>
<li>
<p>Example</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Event</th>
<th>ticket</th>
<th>Turn</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A <code>lock()</code></td>
<td>0</td>
<td>0</td>
<td>A runs</td>
</tr>
<tr>
<td>2</td>
<td>B <code>lock()</code></td>
<td>1</td>
<td></td>
<td>B spins until turn = 1</td>
</tr>
<tr>
<td>3</td>
<td>C <code>lock()</code></td>
<td>2</td>
<td></td>
<td>C spins until turn = 2</td>
</tr>
<tr>
<td>4</td>
<td>A <code>unlock()</code></td>
<td></td>
<td>1</td>
<td>B runs</td>
</tr>
<tr>
<td>5</td>
<td>A <code>lock()</code></td>
<td>3</td>
<td></td>
<td>A spins until turn = 3</td>
</tr>
<tr>
<td>6</td>
<td>B <code>unlock()</code></td>
<td></td>
<td>2</td>
<td>C runs</td>
</tr>
<tr>
<td>7</td>
<td>C <code>unlock()</code></td>
<td></td>
<td>3</td>
<td>A runs</td>
</tr>
<tr>
<td>8</td>
<td>A <code>unlock()</code></td>
<td></td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Ticket Lock Implementation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> ticket; </span><br><span class="line">    <span class="keyword">int</span> turn; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn); <span class="comment">// spin</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ticket-lock-with-yield"><a class="markdownIt-Anchor" href="#ticket-lock-with-yield"></a> Ticket Lock with Yield</h3>
<ul>
<li>
<p>Spinlock Performance</p>
<ul>
<li>
<p>Fast when…</p>
<ul>
<li>many CPUs</li>
<li>locks held a short time</li>
<li>advantage: avoid context switch</li>
</ul>
</li>
<li>
<p>Slow when…</p>
<ul>
<li>one CPU</li>
<li>locks held a long time</li>
<li>disadvantage: spinning is wasteful</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CPU Scheduler is Ignorant</p>
<ul>
<li>CPU scheduler may run B, C, D instead of A even though B, C, D are waiting for A</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/Avi05dZ.png" alt=""></p>
<ul>
<li>
<p>Ticket Locks with Yield</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> ticket; </span><br><span class="line">    <span class="keyword">int</span> turn; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn) &#123;</span><br><span class="line">        yield(); <span class="comment">// yield instead of spin</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Yield instead of Spin</p>
</li>
</ul>
<p><img src="https://i.imgur.com/cXfmvjp.png" alt=""></p>
<ul>
<li>Time Comparison: Yield vs Spin
<ul>
<li>
<p>Assumption</p>
<ul>
<li>Round robin scheduling, 10ms time slice</li>
<li>Process A, B, C, D, E, F, G, H, I, J in the system</li>
</ul>
</li>
<li>
<p>Timeline</p>
<ul>
<li>A: lock() … compute … unlock()</li>
<li>B: lock() … compute … unlock()</li>
<li>…</li>
<li>J: lock() … compute … unlock()</li>
<li>A: lock() … compute … unlock()</li>
<li>…</li>
</ul>
</li>
<li>
<p>If A’s compute is 20ms long, starting at t = 0, when does B get lock with spin ?</p>
<ul>
<li>
<p>110 ms</p>
<table>
<thead>
<tr>
<th>A…J</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>If B’s compute is 30ms long, when does C get lock with spin ?</p>
<ul>
<li>
<p>320 ms</p>
<table>
<thead>
<tr>
<th>A…J</th>
<th>A…J</th>
<th>A…J</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>If context switch time = 1ms, when does B get lock with yield ?</p>
<ul>
<li>29 ms</li>
<li>
<table>
<thead>
<tr>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>9</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="queue-lock"><a class="markdownIt-Anchor" href="#queue-lock"></a> Queue Lock</h3>
<ul>
<li>
<p>Motivation</p>
<ul>
<li>
<p>Time complexity of spinlock</p>
<ul>
<li>Without yield: O(threads * time_slice)</li>
<li>With yield: O(threads * context_switch)</li>
</ul>
</li>
<li>
<p>Even with yield, spinning is slow with high thread contention</p>
</li>
</ul>
</li>
<li>
<p>Idea</p>
<ul>
<li>Block and put thread on waiting queue instead of spinning</li>
<li>Remove waiting threads from scheduler ready queue</li>
<li>(e.g., <code>park()</code> and <code>unpark(threadID)</code>)</li>
<li>Scheduler runs any thread that is ready</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>A &amp; C has 60ms of work</li>
<li>A, B, D contend for lock</li>
<li>C not contending</li>
<li>Context switch + yield takes 5ms</li>
</ul>
</li>
<li>
<p>Timeline</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Event</th>
<th>Running</th>
<th>Runnable</th>
<th>Waiting</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td></td>
<td>A, B, C, D</td>
<td></td>
</tr>
<tr>
<td>0-20</td>
<td>A scheduled</td>
<td>A</td>
<td>B, C, D</td>
<td></td>
</tr>
<tr>
<td>20-25</td>
<td>B scheduled &amp; blocked</td>
<td></td>
<td>C, D, A</td>
<td>B</td>
</tr>
<tr>
<td>25-45</td>
<td>C scheduled</td>
<td>C</td>
<td>D, A</td>
<td>B</td>
</tr>
<tr>
<td>45-50</td>
<td>D scheduled &amp; blocked</td>
<td></td>
<td>A, C</td>
<td>B, D</td>
</tr>
<tr>
<td>50-70</td>
<td>A scheduled</td>
<td>A</td>
<td>C</td>
<td>B, D</td>
</tr>
<tr>
<td>70-90</td>
<td>C scheduled</td>
<td>C</td>
<td>A</td>
<td>B, D</td>
</tr>
<tr>
<td>90-110</td>
<td>A scheduled &amp; finished</td>
<td>A</td>
<td>C</td>
<td>B, D</td>
</tr>
<tr>
<td>110-130</td>
<td>C scheduled &amp; finished</td>
<td>C</td>
<td>B</td>
<td>D</td>
</tr>
<tr>
<td>130-150</td>
<td>B scheduled &amp; finished</td>
<td>B</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>150-170</td>
<td>D scheduled &amp; finished</td>
<td>D</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Incorrect Implementation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> guard = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">queue_t</span> q;</span><br><span class="line">&#125; LockT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Grab guard</span></span><br><span class="line"><span class="comment">// 2. If lock is held, add to queue and park</span></span><br><span class="line"><span class="comment">// 3. If lock is not held, grab the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;lock) &#123; </span><br><span class="line">        qadd(l-&gt;q, tid); </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">        park();     <span class="comment">// blocked  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        l-&gt;lock = <span class="literal">true</span>; </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Grab guard</span></span><br><span class="line"><span class="comment">// 2. If queue is empty, release hte lock</span></span><br><span class="line"><span class="comment">// 3. If the queue is not empty, unpark head of queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (qempty(l-&gt;q))</span><br><span class="line">        l-&gt;lock=<span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(qremove(l-&gt;q));  </span><br><span class="line">    l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Questions and Answers</p>
<ul>
<li>
<p>Why is guard used?<br>
To ensure queue operations is thread safe</p>
</li>
<li>
<p>Why OK to spin on guard?<br>
Very shhort critical section</p>
</li>
<li>
<p>In release(), why not set <code>lock = false</code> when unpark?<br>
<code>lock == true</code> is passed from one thread to the next</p>
</li>
</ul>
</li>
<li>
<p>Race Condition for Previous Implementation</p>
<table>
<thead>
<tr>
<th>Thread 1 (in lock)</th>
<th>Thread 2 (in unlock)</th>
</tr>
</thead>
<tbody>
<tr>
<td>if (l-&gt;lock) {<br> qadd(l-&gt;q, tid); <br> l-&gt;guard = false; <br> <br> <br> <br><br>  park()</td>
<td><br> <br> <br> while (TAS(&amp;l-&gt;guard, true)); <br> if (qempty(l-&gt;q)) // false!!  <br> else unpark(qremove(l-&gt;q)); <br> l-&gt;guard = false;   <br> <br></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Correct Implementation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> guard = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">queue_t</span> q;</span><br><span class="line">&#125; LockT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;lock) &#123; </span><br><span class="line">        qadd(l-&gt;q, tid); </span><br><span class="line">        setpark(pid); <span class="comment">// notify of plan</span></span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">        park();     <span class="comment">// blocked  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        l-&gt;lock = <span class="literal">true</span>; </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (qempty(l-&gt;q))</span><br><span class="line">        l-&gt;lock=<span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(qremove(l-&gt;q));  </span><br><span class="line">    l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Time Comparison: Yield vs Blocking</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>Round robin scheduling, 10ms time slice</li>
<li>Process A, B, C, D, E, F, G, H, I, J in the system</li>
<li>Context switch takes 1ms</li>
</ul>
</li>
<li>
<p>Timeline</p>
<ul>
<li>A: lock() … compute … unlock()</li>
<li>B: lock() … compute … unlock()</li>
<li>…</li>
<li>J: lock() … compute … unlock()</li>
<li>A: lock() … compute … unlock()</li>
<li>…</li>
</ul>
</li>
<li>
<p>If A’s compute is 30ms long, starting at t = 0, when does B get lock with yield?</p>
<ul>
<li>
<p>48 ms</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>9</td>
<td>10</td>
<td>9</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>If A’s compute is 30ms long, starting at t = 0, when does B get lock with blocking?</p>
<ul>
<li>
<p>39 ms</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>9</td>
<td>10</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="queue-lock-vs-spin-lock"><a class="markdownIt-Anchor" href="#queue-lock-vs-spin-lock"></a> Queue Lock vs Spin Lock</h3>
<ul>
<li>
<p>Each approach is better under different circumstances</p>
</li>
<li>
<p>Uniprocessor</p>
<ul>
<li>Waiting process is scheduled à Process holding lock isn’t</li>
<li>Waiting process should always relinquish processor</li>
<li>Associate queue of waiters with each lock (as in previous implementation)</li>
</ul>
</li>
<li>
<p>Multiprocessor</p>
<ul>
<li>Waiting process is scheduled -&gt; Process holding lock might be</li>
<li>Spin or block depends on how long, t, before lock is released
<ul>
<li>Lock released quickly -&gt; Spin-wait</li>
<li>Lock released slowly -&gt; Block</li>
<li>Quick and slow are relative to context-switch cost, C</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="condition-variables"><a class="markdownIt-Anchor" href="#condition-variables"></a> Condition Variables</h2>
<h3 id="ordering"><a class="markdownIt-Anchor" href="#ordering"></a> Ordering</h3>
<ul>
<li>
<p>Idea: Thread A runs after Thread B does something</p>
</li>
<li>
<p>Example: Join</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> p1, p2; </span><br><span class="line">Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>); </span><br><span class="line">Pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>); </span><br><span class="line"><span class="comment">// join waits for the threads to finish </span></span><br><span class="line">Pthread_join(p1, <span class="literal">NULL</span>); </span><br><span class="line">Pthread_join(p2, <span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="condition-variables-2"><a class="markdownIt-Anchor" href="#condition-variables-2"></a> Condition Variables</h3>
<ul>
<li>
<p>Condition Variable: queue of waiting threads</p>
</li>
<li>
<p>B waits for a signal on CV before running: <code>wait(CV, …)</code></p>
</li>
<li>
<p>A sends signal to CV when time for B to run: <code>signal(CV, …)</code></p>
</li>
<li>
<p><code>wait(cond_t *cv, mutex_t *lock)</code></p>
<ul>
<li>assumes the lock is held when wait() is called</li>
<li>puts caller to sleep + releases the lock (atomically)</li>
<li>when awoken, reacquires lock before returning</li>
</ul>
</li>
<li>
<p><code>signal(cond_t *cv)</code></p>
<ul>
<li>wake a single waiting thread (if &gt;= 1 thread is waiting)</li>
<li>if there is no waiting thread, just return, doing nothing</li>
</ul>
</li>
</ul>
<h3 id="join-attempt-1-no-state"><a class="markdownIt-Anchor" href="#join-attempt-1-no-state"></a> Join Attempt 1: No State</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);     <span class="comment">// x </span></span><br><span class="line">   Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);   <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a </span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// b </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// c </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Intended schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td>x</td>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td>z</td>
</tr>
<tr>
<td>Child</td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>y</td>
</tr>
<tr>
<td>Child</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>Parent is stuck because nobody will call signal</li>
</ul>
</li>
<li>
<p>Rule of Thumb 1</p>
<ul>
<li>Keep state in addition to CV’s</li>
<li>CV’s are used to signal threads when state changes</li>
<li>If state is already as needed, thread doesn’t wait for a signal!</li>
</ul>
</li>
</ul>
<h3 id="join-attempt-2-no-mutex-lock"><a class="markdownIt-Anchor" href="#join-attempt-2-no-mutex-lock"></a> Join Attempt 2: No Mutex Lock</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="comment">// If the child process already finished executing</span></span><br><span class="line">   <span class="comment">// the parent process doesn't need to wait</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// a</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// b </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Intended schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td></td>
<td></td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
</tr>
<tr>
<td>Child</td>
<td>a</td>
<td>b</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td>w</td>
<td>x</td>
<td></td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>Child</td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>Parent is stuck again</li>
</ul>
</li>
</ul>
<h3 id="join-attempt-3-state-mutex-lock"><a class="markdownIt-Anchor" href="#join-attempt-3-state-mutex-lock"></a> Join Attempt 3: State + Mutex Lock</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a</span></span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// b</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// c </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td>z</td>
</tr>
<tr>
<td>Child</td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Rule of Thumb 2</p>
<ul>
<li>Hold mutex lock while calling wait/signal</li>
<li>Ensures no race between interacting with state and wait/signal</li>
</ul>
</li>
</ul>
<h3 id="producerconsumer-problem"><a class="markdownIt-Anchor" href="#producerconsumer-problem"></a> Producer/Consumer Problem</h3>
<ul>
<li>Example: UNIX pipes
<ul>
<li>
<p>A pipe may have many writers and readers</p>
</li>
<li>
<p>Internally, there is a finite-sized buffer</p>
</li>
<li>
<p>Writers add data to the buffer</p>
<ul>
<li>Writers have to wait if buffer is full</li>
</ul>
</li>
<li>
<p>Readers remove data from the buffer</p>
<ul>
<li>Readers have to wait if buffer is empty</li>
</ul>
</li>
<li>
<p>Implementation:</p>
<ul>
<li>reads/writes to buffer require locking</li>
<li>when buffers are full, writers must wait</li>
<li>when buffers are empty, readers must wait</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre>
               Start (consumer)
               |
     +---------v---------------------------+------+
Buf: |         |          data             |      |
     +---------+---------------------------^------+
                                           |
                                           End (producer)
</pre>
<ul>
<li>Producer/Consumer Problem
<ul>
<li>
<p>Producers generate data (like pipe writers)</p>
</li>
<li>
<p>Consumers grab data and process it (like pipe readers)</p>
</li>
<li>
<p>Producer/consumer problems are frequent in systems (e.g. web servers)</p>
</li>
<li>
<p>General strategy use condition variables to:</p>
<ul>
<li>make producers wait when buffers are full</li>
<li>make consumers wait when there is nothing to consume</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pc-attempt-1-one-cv"><a class="markdownIt-Anchor" href="#pc-attempt-1-one-cv"></a> P/C Attempt 1: One CV</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Producer grabs the lock</span></span><br><span class="line"><span class="comment">// 2. Check whether the buffer is full. If so, wait.</span></span><br><span class="line"><span class="comment">// 3. Put something to the buffer</span></span><br><span class="line"><span class="comment">// 4. Signal consumers to read</span></span><br><span class="line"><span class="comment">// 5. Release the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == max)      <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;cond, &amp;m);  <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;cond);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Consumer grabs the lock</span></span><br><span class="line"><span class="comment">// 2. Check whether the buffer is empty. If so, wait.</span></span><br><span class="line"><span class="comment">// 3. Get the content from buffer and remove it.</span></span><br><span class="line"><span class="comment">// 4. Signal consumers to write</span></span><br><span class="line"><span class="comment">// 5. Release the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == <span class="number">0</span>)       <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;cond, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;cond);     <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>p1</td>
<td>p2</td>
<td>p4</td>
<td>p5</td>
<td>p6</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C1</td>
<td>c1</td>
<td>c2</td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C2</td>
<td></td>
<td></td>
<td></td>
<td>c1</td>
<td>c2</td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>c5</td>
</tr>
</tbody>
</table>
<ul>
<li>At time 16, Consumer 1 could signal Consumer 2 to wake up</li>
</ul>
</li>
</ul>
<h3 id="pc-attempt-2-two-cvs"><a class="markdownIt-Anchor" href="#pc-attempt-2-two-cvs"></a> P/C Attempt 2: Two CVs</h3>
<ul>
<li>
<p>How to wake the right thread? Use two condition variables</p>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == max)      <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;empty, &amp;m); <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;fill);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == <span class="number">0</span>)       <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;fill, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;empty);    <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td></td>
<td></td>
<td></td>
<td>p1</td>
<td>p4</td>
<td>p5</td>
<td>p6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C1</td>
<td>c1</td>
<td>c2</td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c4</td>
</tr>
<tr>
<td>C2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c1</td>
<td>c4</td>
<td>c5</td>
<td>c6</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>At time 12, Consumer 1 wakes up but has nothing to read</li>
<li>Note: When <code>signal()</code> is called, the thread may not resume immediately</li>
</ul>
</li>
</ul>
<h3 id="pc-attempt-3-two-cvs-with-while"><a class="markdownIt-Anchor" href="#pc-attempt-3-two-cvs-with-while"></a> P/C Attempt 3: Two CVs with While</h3>
<ul>
<li>
<p>Idea: Recheck the shared variable is still in the state you want after waking up</p>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">while</span> (numfull == max)   <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;empty, &amp;m); <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;fill);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">while</span> (numfull == <span class="number">0</span>)    <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;fill, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;empty);    <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Rule of Thumb 3</p>
<ul>
<li>Whenever a lock is acquired, recheck assumptions about state!</li>
<li>Another thread could grab lock in between signal and wakeup from wait</li>
<li>Note that some libraries also have “spurious wakeups”</li>
<li>(may wake multiple waiting threads at signal or at any time)</li>
</ul>
</li>
</ul>
<h3 id="summary-5"><a class="markdownIt-Anchor" href="#summary-5"></a> Summary</h3>
<ul>
<li>
<p>Rules of Thumb for CVs</p>
<ol>
<li>Keep state in addition to CV’s</li>
<li>Always do wait/signal with lock held</li>
<li>Whenever thread wakes from waiting, recheck state</li>
</ol>
</li>
<li>
<p><code>wait(cond_t *cv, mutex_t *lock)</code></p>
<ul>
<li>assumes the lock is held when wait() is called</li>
<li>puts caller to sleep + releases the lock (atomically)</li>
<li>when awoken, reacquires lock before returning</li>
</ul>
</li>
<li>
<p><code>signal(cond_t *cv)</code></p>
<ul>
<li>wake a single waiting thread (if &gt;= 1 thread is waiting)</li>
<li>if there is no waiting thread, just return, doing nothing</li>
</ul>
</li>
</ul>
<h2 id="semaphores"><a class="markdownIt-Anchor" href="#semaphores"></a> Semaphores</h2>
<h3 id="introduction-4"><a class="markdownIt-Anchor" href="#introduction-4"></a> Introduction</h3>
<ul>
<li>
<p>Condition variables have no state (other than waiting queue)</p>
<ul>
<li>Programmer must track additional state</li>
</ul>
</li>
<li>
<p>Semaphores have state: track integer value</p>
<ul>
<li>State cannot be directly accessed by user program</li>
<li>But state determines behavior of semaphore operations</li>
</ul>
</li>
</ul>
<h3 id="semaphore-operations"><a class="markdownIt-Anchor" href="#semaphore-operations"></a> Semaphore Operations</h3>
<ul>
<li>
<p>Allocate and Initialize</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_init(<span class="keyword">sem_t</span> *s, <span class="keyword">int</span> initval) &#123;</span><br><span class="line">    s-&gt;value = initval; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>User cannot read or write value directly after initialization</li>
</ul>
</li>
<li>
<p>Wait or Test (sometime P() for Dutch) <code>sem_wait(sem_t*)</code></p>
<ul>
<li>Decrements sem value, Waits until value of sem is &gt;= 0</li>
</ul>
</li>
<li>
<p>Signal or Post (sometime V() for Dutch) <code>sem_post(sem_t*)</code></p>
<ul>
<li>Increment sem value, then wake a single waiter</li>
</ul>
</li>
</ul>
<h3 id="build-lock-from-semaphore"><a class="markdownIt-Anchor" href="#build-lock-from-semaphore"></a> Build Lock from Semaphore</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">sem_t</span> sem; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    sem_init(&amp;lock-&gt;sem, <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;lock-&gt;sem);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    sem_post(&amp;lock-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="join-with-cv-vs-semaphores"><a class="markdownIt-Anchor" href="#join-with-cv-vs-semaphores"></a> Join with CV vs Semaphores</h3>
<ul>
<li>
<p>Join with Condition Variable</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a</span></span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// b</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// c </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Join with Semaphores</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Join with Semaphores Example 1</p>
  <pre>
    s                       s                      s
  +---+   parent wait()   +---+   child post()   +---+
  | 0 |+----------------->| -1|+---------------->| 0 |
  +---+                   +---+                  +---+
                            ^                      ^
                            |                      |
                            Parent blocked         Parent resumes
  </pre>
</li>
<li>
<p>Join with Semaphores Example 2</p>
  <pre>
    s                       s                      s
  +---+   child post()    +---+  parent wait()   +---+
  | 0 |+----------------->| 1 |+---------------->| 0 |
  +---+                   +---+                  +---+
  </pre>
</li>
</ul>
<h3 id="pc-1-producer-1-consumer-with-buffer-of-size-1"><a class="markdownIt-Anchor" href="#pc-1-producer-1-consumer-with-buffer-of-size-1"></a> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size 1</h3>
<ul>
<li>
<p>Use 2 semaphores</p>
<ul>
<li>emptyBuffer: Initialize to 1</li>
<li>fullBuffer: Initialize to 0</li>
</ul>
</li>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer);</span><br><span class="line">    Fill(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer);</span><br><span class="line">    Use(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example 1: Producer comes first</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Current Thread</th>
<th>emptyBuffer</th>
<th>fullBuffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>Producer</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Consumer</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>Producer</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Example 2: Consumer comes first</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Current Thread</th>
<th>emptyBuffer</th>
<th>fullBuffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>Consumer</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>2</td>
<td>Producer</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>Consumer</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="pc-1-producer-1-consumer-with-buffer-of-size-n"><a class="markdownIt-Anchor" href="#pc-1-producer-1-consumer-with-buffer-of-size-n"></a> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size N</h3>
<ul>
<li>
<p>Use 2 semaphores</p>
<ul>
<li>emptyBuffer: Initialize to N</li>
<li>fullBuffer: Initialize to 0</li>
</ul>
</li>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer);</span><br><span class="line">    Fill(&amp;buffer[i]); </span><br><span class="line">    i = (i + <span class="number">1</span>) % N;</span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer);</span><br><span class="line">    Use(&amp;buffer[j]);</span><br><span class="line">    j = (j + <span class="number">1</span>) % N;</span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example 1: Producer comes first (N = 3)</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Curr</th>
<th>empty<br>Buffer</th>
<th>full<br>Buffer</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>3</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>P1</td>
<td>2</td>
<td>1</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>2</td>
<td>P2</td>
<td>1</td>
<td>2</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>3</td>
<td>P3</td>
<td>0</td>
<td>3</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>4</td>
<td>P4</td>
<td>-1</td>
<td>3</td>
<td>wait(emptyBuffer)</td>
</tr>
<tr>
<td>5</td>
<td>C1</td>
<td>0</td>
<td>2</td>
<td>wait(fullBuffer) + use + signal(emptyBuffer)</td>
</tr>
<tr>
<td>6</td>
<td>C2</td>
<td>1</td>
<td>1</td>
<td>wait(fullBuffer) + use + signal(emptyBuffer)</td>
</tr>
<tr>
<td>7</td>
<td>P4</td>
<td>0</td>
<td>2</td>
<td>fill + signal(fullBuffer)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Example 2: Two consumers come first (N = 3)</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Curr</th>
<th>empty<br>Buffer</th>
<th>full<br>Buffer</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>3</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>C1</td>
<td>3</td>
<td>-1</td>
<td>wait(fullBuffer)</td>
</tr>
<tr>
<td>2</td>
<td>C2</td>
<td>3</td>
<td>-2</td>
<td>wait(fullBuffe)</td>
</tr>
<tr>
<td>3</td>
<td>P</td>
<td>2</td>
<td>-1</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>4</td>
<td>C1</td>
<td>3</td>
<td>-1</td>
<td>use + signal(emptyBuffer)</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="pc-multiple-producers-consumers"><a class="markdownIt-Anchor" href="#pc-multiple-producers-consumers"></a> P/C: Multiple Producers &amp; Consumers</h3>
<ul>
<li>
<p>Requirements</p>
<ul>
<li>Each consumer must grab unique filled element</li>
<li>Each producer must grab unique empty element</li>
</ul>
</li>
<li>
<p>Attempt 1</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Problem: <code>findfull</code> and <code>findempty</code> are not thread-safe</p>
</li>
</ul>
</li>
<li>
<p>Attempt 2</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Problem</p>
<ul>
<li>Deadlock: Consumer grabs <code>mutex</code> and wait for <code>fullBuffer</code> for ever</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Attempt 3</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Problem</p>
<ul>
<li>Cannot operate on multiple buffer locations at the same time</li>
<li>Only 1 thread at at time can be using of filling different buffers</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Attempt 4</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Advantage</p>
<ul>
<li>Works and increases concurrency; only finding a buffer is protected by mutex;</li>
<li>Filling or Using different buffers can proceed concurrently</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="readerwriter-locks"><a class="markdownIt-Anchor" href="#readerwriter-locks"></a> Reader/Writer Locks</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Let multiple reader threads grab lock (shared)</li>
<li>Only one writer thread can grab lock (exclusive)
<ul>
<li>No reader threads</li>
<li>No other writer threads</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct_rwlock_t</span> &#123;</span><br><span class="line">    <span class="keyword">sem_t</span> lock; <span class="comment">// reader lock</span></span><br><span class="line">    <span class="keyword">sem_t</span> writelock;</span><br><span class="line">    <span class="keyword">int</span> readers; <span class="comment">// number of readers</span></span><br><span class="line">&#125; <span class="keyword">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_init</span><span class="params">(<span class="keyword">rwlock_t</span>*rw)</span> </span>&#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// initialize locks to 1, similar to mutex initialization</span></span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">1</span>);  </span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123; </span><br><span class="line">    sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">    rw-&gt;readers++; </span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>) </span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">    sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123; </span><br><span class="line">    sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">    rw-&gt;readers--; </span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>) </span><br><span class="line">        sem_post(&amp;rw-&gt;writelock); <span class="comment">// let other writes</span></span><br><span class="line">    sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Current Action</th>
<th>lock</th>
<th>writelock</th>
<th>readers</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>T1 <code>acquire_readlock</code></td>
<td><del>0</del> 1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>T2 <code>acquire_readlock</code></td>
<td><del>0</del> 1</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>T3 <code>acquire_writelock</code></td>
<td>1</td>
<td>-1</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>T1 <code>release_readlock</code></td>
<td><del>0</del> 1</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>T2 <code>release_readlock</code></td>
<td><del>0</del> 1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Quiz 1</p>
<ul>
<li>T1: <code>acquire_readlock()</code> =&gt; T1 running</li>
<li>T2: <code>acquire_readlock()</code> =&gt; T2 running</li>
<li>T3: <code>acquire_writelock()</code> =&gt; T3 blocked, waiting for write lock</li>
</ul>
</li>
<li>
<p>Quiz 2</p>
<ul>
<li>T6: <code>acquire_writelock()</code> =&gt; T6 running</li>
<li>T4: <code>acquire_readlock()</code> =&gt; T4 blocked, waiting for read lock</li>
<li>T5: <code>acquire_readlock()</code> =&gt; T5 blocked, waiting for read lock</li>
</ul>
</li>
</ul>
<h3 id="build-zemaphore-from-lock-and-cv"><a class="markdownIt-Anchor" href="#build-zemaphore-from-lock-and-cv"></a> Build Zemaphore from Lock and CV</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">cond_t</span> cond; </span><br><span class="line">    <span class="keyword">lock_t</span> lock; </span><br><span class="line">&#125; <span class="keyword">zem_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_init</span><span class="params">(<span class="keyword">zem_t</span> *z, <span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">    z-&gt;value = value; </span><br><span class="line">    cond_init(&amp;z-&gt;cond); </span><br><span class="line">    lock_init(&amp;z-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// waits until value &gt; 0. and decrement</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_wait</span><span class="params">(<span class="keyword">zem_t</span> *z)</span> </span>&#123; </span><br><span class="line">    lock_acquire(&amp;z-&gt;lock); </span><br><span class="line">    z-&gt;value--; </span><br><span class="line">    <span class="keyword">while</span> (z-&gt;value &lt; <span class="number">0</span>) </span><br><span class="line">       cond_wait(&amp;z-&gt;cond); </span><br><span class="line">    lock_release(&amp;z-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// increment value, then wake a single waiter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_post</span><span class="params">(<span class="keyword">zem_t</span> *z)</span> </span>&#123; </span><br><span class="line">    lock_acquire(&amp;z-&gt;lock); </span><br><span class="line">    z-&gt;value++; </span><br><span class="line">    cond_signal(&amp;z-&gt;cond); </span><br><span class="line">    lock_release(&amp;z-&gt;lock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="summary-6"><a class="markdownIt-Anchor" href="#summary-6"></a> Summary</h3>
<ul>
<li>
<p>Semaphores are equivalent to locks + condition variables</p>
<ul>
<li>Can be used for both mutual exclusion and ordering</li>
</ul>
</li>
<li>
<p>Semaphores contain state</p>
<ul>
<li>How they are initialized depends on how they will be used</li>
<li>Init to 0: Join (1 thread must arrive first, then other)</li>
<li>Init to N: Number of available resources</li>
</ul>
</li>
<li>
<p>sem_wait(): Decrement and waits until value &gt;= 0</p>
</li>
<li>
<p>sem_post(): Increment value, then wake a single waiter (atomic)</p>
</li>
<li>
<p>Can use semaphores in producer/consumer and for reader/writer locks</p>
</li>
</ul>
<h2 id="concurrency-bugs"><a class="markdownIt-Anchor" href="#concurrency-bugs"></a> Concurrency Bugs</h2>
<h3 id="concurrency-in-medicine-therac-25-1980s"><a class="markdownIt-Anchor" href="#concurrency-in-medicine-therac-25-1980s"></a> Concurrency in Medicine: Therac-25 (1980’s)</h3>
<blockquote>
<p>“The accidents occurred when the high-power electron beam was activated<br>
instead of the intended low power beam, and without the beam spreader plate<br>
rotated into place. Previous models had hardware interlocks in place to prevent<br>
this, but Therac-25 had removed them, depending instead on software interlocks<br>
for safety. The software interlock could fail due to a race condition.”</p>
</blockquote>
<blockquote>
<p>“…in three cases, the injured patients later died.”</p>
</blockquote>
<ul>
<li>Source: <a href="http://en.wikipedia.org/wiki/Therac-25" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Therac-25</a></li>
</ul>
<h3 id="concurrency-study"><a class="markdownIt-Anchor" href="#concurrency-study"></a> Concurrency Study</h3>
<p><img src="https://i.imgur.com/77XWz8c.png" alt=""></p>
<h3 id="atomicity-mysql"><a class="markdownIt-Anchor" href="#atomicity-mysql"></a> Atomicity: MySQL</h3>
<ul>
<li>
<p>Bug</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="built_in">fputs</span>(thd-&gt;proc_info, <span class="comment">/*...*/</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Fix</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="built_in">fputs</span>(thd-&gt;proc_info, <span class="comment">/*...*/</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ordering-mozilla"><a class="markdownIt-Anchor" href="#ordering-mozilla"></a> Ordering: Mozilla</h3>
<ul>
<li>
<p>Bug</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, <span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">(<span class="comment">/*...*/</span>)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Fix</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, <span class="comment">/*...*/</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    mtInit = <span class="number">1</span>; </span><br><span class="line">    pthread_cond_signal(&amp;mtCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">(<span class="comment">/*...*/</span>)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    <span class="keyword">while</span> (mtInit == <span class="number">0</span>) </span><br><span class="line">        pthread_cond_wait(&amp;mtCond, &amp;mtLock);  </span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);  </span><br><span class="line">    </span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="deadlock"><a class="markdownIt-Anchor" href="#deadlock"></a> Deadlock</h2>
<h3 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h3>
<ul>
<li>No progress can be made because two or more threads are waiting for the other to take some action and thus neither ever does</li>
</ul>
<h3 id="example-1-circular-dependency"><a class="markdownIt-Anchor" href="#example-1-circular-dependency"></a> Example 1: Circular Dependency</h3>
<ul>
<li>
<p>Code</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lock(&amp;A);</code> <br><br><br> <code>lock(&amp;B);</code>(blocked)</td>
<td><br><code>lock(&amp;B);</code>  <br> <code>lock(&amp;A);</code>(blocked)<br><br></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Circular Dependency<br>
<img src="https://i.imgur.com/dG4Krbd.png" alt=""></p>
<ul>
<li>Cycle in dependency graph -&gt; possible to have deadlock</li>
</ul>
</li>
<li>
<p>Fix Deadlock Code</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lock(&amp;A);</code> <br><code>lock(&amp;B);</code></td>
<td><code>lock(&amp;A);</code>  <br> <code>lock(&amp;A);</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Non-Circular Dependency<br>
<img src="https://i.imgur.com/yJibQZG.png" alt=""></p>
</li>
</ul>
<h3 id="example-2-encapsulation"><a class="markdownIt-Anchor" href="#example-2-encapsulation"></a> Example 2: Encapsulation</h3>
<ul>
<li>Code</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_t</span> *set_intersection(<span class="keyword">set_t</span> *s1, <span class="keyword">set_t</span> *s2) &#123;</span><br><span class="line">   <span class="keyword">set_t</span> *rv = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*rv));</span><br><span class="line">   mutex_lock(&amp;s1-&gt;lock);</span><br><span class="line">   mutex_lock(&amp;s2-&gt;lock);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1-&gt;len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set_contains(s2, s1-&gt;items[i])) &#123;</span><br><span class="line">         set_add(rv, s1-&gt;items[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   mutex_unlock(&amp;s2-&gt;lock);</span><br><span class="line">   mutex_unlock(&amp;s1-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Deadlock scenario</p>
<ul>
<li>Thread 1: <code>rv = set_intersection(setA, setB);</code></li>
<li>Thread 2: <code>rv = set_intersection(setB, setA);</code></li>
</ul>
</li>
<li>
<p>Encapsulation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m1 &gt; m2) &#123;</span><br><span class="line">  <span class="comment">// grab locks in high-to-low address order</span></span><br><span class="line">  pthread_mutex_lock(m1);</span><br><span class="line">  pthread_mutex_lock(m2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pthread_mutex_lock(m2);</span><br><span class="line">  pthread_mutex_lock(m1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Problem: Deadlock happens when <code>m1 == m2</code></li>
</ul>
</li>
</ul>
<h3 id="deadlock-theory"><a class="markdownIt-Anchor" href="#deadlock-theory"></a> Deadlock Theory</h3>
<ul>
<li>
<p>Deadlocks can only happen with these four conditions:</p>
<ol>
<li>mutual exclusion</li>
<li>hold-and-wait</li>
<li>no preemption</li>
<li>circular wait</li>
</ol>
</li>
<li>
<p>Can eliminate deadlock by eliminating any one condition</p>
</li>
</ul>
<h3 id="1-mutual-exclusion"><a class="markdownIt-Anchor" href="#1-mutual-exclusion"></a> 1. Mutual Exclusion</h3>
<ul>
<li>
<p>Problem: Threads claim exclusive control of resources that they require</p>
</li>
<li>
<p>Strategy: Eliminate locks! Replace locks with atomic primitive</p>
</li>
<li>
<p>Lock-free <code>add</code></p>
<ul>
<li>
<p>Implement <code>add</code> using lock</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *val, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  Mutex_lock(&amp;m);</span><br><span class="line">  *val += amt;</span><br><span class="line">  Mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Atomic primitive <code>CompareAndSwap</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *address, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*address == expected) &#123;</span><br><span class="line">    *address = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// success</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implement <code>add</code> without lock</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *val, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> old = *value;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!CompareAndSwap(val, old, old + amt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Wait-free Linked List Insert</p>
<ul>
<li>
<p>Implement <code>insert</code> using lock</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*n));</span><br><span class="line">  n-&gt;val = val;</span><br><span class="line">  lock(&amp;m);</span><br><span class="line">  n-&gt;next = head;</span><br><span class="line">  head = n;</span><br><span class="line">  unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implement <code>insert</code> using while loop</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *n = Malloc(<span class="keyword">sizeof</span>(*n));</span><br><span class="line">  n-&gt;val = val;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!CompareAndSwap(&amp;head, n-&gt;next, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-hold-and-wait"><a class="markdownIt-Anchor" href="#2-hold-and-wait"></a> 2. Hold and Wait</h3>
<ul>
<li>
<p>Problem: Threads hold resources allocated to them while waiting for additional resources</p>
</li>
<li>
<p>Strategy: Acquire all locks atomically once. Can release locks over time, but cannot acquire again until all have been released</p>
</li>
<li>
<p>How to do this? Use a meta lock:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock(&amp;meta);</span><br><span class="line">lock(&amp;L1); <span class="comment">/*...*/</span> lock(&amp;L10);</span><br><span class="line">unlock(&amp;L10); <span class="comment">/*...*/</span> unlock(&amp;L1);</span><br><span class="line">unlock(&amp;meta);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Locks are not fine-grained</li>
</ul>
</li>
</ul>
<h3 id="3-no-preemption"><a class="markdownIt-Anchor" href="#3-no-preemption"></a> 3. No Preemption</h3>
<ul>
<li>
<p>Problem: Resources (e.g., locks) cannot be forcibly removed from threads that are</p>
</li>
<li>
<p>Strategy: if thread can’t get what it wants, release what it holds</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top: </span><br><span class="line">lock(A);</span><br><span class="line"><span class="keyword">if</span> (trylock(B) == <span class="number">-1</span>) &#123; <span class="comment">// try to lock B</span></span><br><span class="line">  unlock(A); <span class="comment">// if failed, also unlock A</span></span><br><span class="line">  <span class="keyword">goto</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Live lock: A situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work</li>
</ul>
</li>
</ul>
<h3 id="circular-wait"><a class="markdownIt-Anchor" href="#circular-wait"></a> Circular Wait</h3>
<ul>
<li>
<p>Circular chain of threads such that each thread holds a resource (e.g., lock)<br>
being requested by next thread in the chain.</p>
</li>
<li>
<p>Strategy:</p>
<ul>
<li>decide which locks should be acquired before others</li>
<li>if A before B, never acquire A if B is already held!</li>
<li>document this, and write code accordingly</li>
</ul>
</li>
<li>
<p>Works well if system has distinct layers</p>
</li>
</ul>
<h2 id="concurrent-data-structures"><a class="markdownIt-Anchor" href="#concurrent-data-structures"></a> Concurrent Data Structures</h2>
<h3 id="scalability"><a class="markdownIt-Anchor" href="#scalability"></a> Scalability</h3>
<ul>
<li>
<p>N times as much work on N cores as done on 1 core.</p>
</li>
<li>
<p>Strong scaling</p>
<ul>
<li>
<p>Fix input size, increase number of cores</p>
</li>
<li>
<p>e.g. Matrix multiplication: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>B</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{m\times n}\times B_{n\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mbin mtight">×</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">×</span><span class="mord mathit mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span></span></span></span> requires <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mnd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mclose">)</span></span></span></span> FLOPS (floating point operations per second)</p>
</li>
</ul>
  <pre>
 Time 
   ^
   |
   |     **
   |     **
   |     **
   |     **
   |     **     **
   |     **     **
   |     **     **     **
   |     **     **     **     **
   +-----++-----++-----++-----++----> Number of Cores
   0     1      2      3      4
</pre></li>
</ul>

<ul>
<li>
<p>Weak scaling</p>
<ul>
<li>
<p>Increase input size with number of cores</p>
</li>
<li>
<p>e.g. Matrix multiplication</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>FLOPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 core</td>
<td>100 × 100</td>
<td>100 × 100</td>
<td>10<sup>6</sup></td>
</tr>
<tr>
<td>2 core</td>
<td>100 × 200</td>
<td>200 × 100</td>
<td>2×10<sup>6</sup></td>
</tr>
<tr>
<td>3 core</td>
<td>100 × 300</td>
<td>300 × 100</td>
<td>2×10<sup>6</sup></td>
</tr>
<tr>
<td>4 core</td>
<td>100 × 400</td>
<td>400 × 100</td>
<td>4×10<sup>6</sup></td>
</tr>
</tbody>
</table>
  <pre>
 Time 
   ^
   |
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   +-----++-----++-----++-----++----> Number of Cores
   0     1      2      3      4
  </pre>
</li>
</ul>
<h3 id="counter"><a class="markdownIt-Anchor" href="#counter"></a> Counter</h3>
<ul>
<li>
<p>Non-thread-safe Counter</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Problem: Two threads calls <code>increment</code> at the same time</li>
</ul>
</li>
<li>
<p>Thread-safe counter</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Linearizability</p>
<ul>
<li>
<p>Even if two threads execute in parallel on multiple cores, the effect that you see should be as if all of them are executed in some linear order.</p>
</li>
<li>
<p>Example: T1 and T2 call <code>increment</code> first, then T3 calls <code>get</code>.</p>
</li>
<li>
<p>Since T3 arrived after T1 and T2, we would want T3 to see the values after T1 and T2 have finished executing as if these were three instructions executed by a single processor</p>
</li>
</ul>
</li>
<li>
<p>The Underlying Problem</p>
<ul>
<li>Ticket lock</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> current_ticket; <span class="comment">// turn</span></span><br><span class="line">    <span class="keyword">int</span> next_ticket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    t = atomic_inc(lock-&gt;next_ticket)</span><br><span class="line">    <span class="keyword">while</span> (t != lock-&gt;current_ticket); <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;current_ticket++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>If one of the thread holds the lock,  all of the other threads need to check the lock</li>
<li>So each lock acquisition becomes more and more expensive as you go from like two to four to eight…</li>
</ul>
</li>
</ul>
<h3 id="approximate-counter-sloppy-counter"><a class="markdownIt-Anchor" href="#approximate-counter-sloppy-counter"></a> Approximate Counter (Sloppy Counter)</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Maintain a counter per-core and a global counter</li>
<li>Global counter lock</li>
<li>Per-core locks if more than 1 thread per-core</li>
</ul>
</li>
<li>
<p>Increment:</p>
<ul>
<li>update local counters at threshold update global</li>
</ul>
</li>
<li>
<p>Read:</p>
<ul>
<li>global counter (maybe inaccurate?)</li>
</ul>
</li>
<li>
<p>Code</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> global;                      <span class="comment">// global count</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> glock;           <span class="comment">// global lock</span></span><br><span class="line">  <span class="keyword">int</span> local[NUMCPUS];              <span class="comment">// local count (per cpu)</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> llock[NUMCPUS];  <span class="comment">// ... and locks</span></span><br><span class="line">  <span class="keyword">int</span> threshold;                   <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init: record threshold, init locks, init values of all local counts and</span></span><br><span class="line"><span class="comment">// global count</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span>* c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">  c-&gt;threshold = threshold;</span><br><span class="line">  c-&gt;global = <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">    c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usually, just grab local lock and update local amount once local</span></span><br><span class="line"><span class="comment">// count has risen by ’threshold’, grab global lock and transfer local values to it</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span>* c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">  c-&gt;local[threadID] += amt;                 <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123;  <span class="comment">// transfer to global</span></span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get: just return global amount (which may not be perfect)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span>* c)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">  <span class="keyword">int</span> val = c-&gt;global;</span><br><span class="line">  pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">  <span class="keyword">return</span> val;  <span class="comment">// only approximate!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="concurrent-linked-list"><a class="markdownIt-Anchor" href="#concurrent-linked-list"></a> Concurrent Linked List</h3>
<ul>
<li>
<p>First Attempt</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//  fail</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">  <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">  L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">//  success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Better Implementation (Shorter Critical Section)</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//  fail</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">  <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">  L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">//  success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="hash-table-from-list"><a class="markdownIt-Anchor" href="#hash-table-from-list"></a> Hash Table from List</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Avoid contention by using different locks</li>
</ul>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">  <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="concurrent-queue"><a class="markdownIt-Anchor" href="#concurrent-queue"></a> Concurrent Queue</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Enqueue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">  tmp-&gt;value = value;</span><br><span class="line">  tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;q-&gt;tailLock);</span><br><span class="line">  q-&gt;tail-&gt;next = tmp;</span><br><span class="line">  q-&gt;tail = tmp;</span><br><span class="line">  pthread_mutex_unlock(&amp;q-&gt;tailLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Dequeue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;q-&gt;headLock);</span><br><span class="line">  <span class="keyword">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">  <span class="keyword">node_t</span> *newHead = tmp-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// queue was empty</span></span><br><span class="line">  &#125;</span><br><span class="line">  *value = newHead-&gt;value;</span><br><span class="line">  q-&gt;head = newHead;</span><br><span class="line">  pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="summary-7"><a class="markdownIt-Anchor" href="#summary-7"></a> Summary</h3>
<ul>
<li>
<p>Simple approach: Add a lock to each method?!</p>
</li>
<li>
<p>Check for scalability – weak scaling, strong scaling</p>
</li>
<li>
<p>Avoid cross-thread, cross-core traffic</p>
<ul>
<li>Per-core counter</li>
<li>Buckets in hashtable</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Computer-Science/" rel="tag"># Computer Science</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/18/Database/" rel="next" title="Database Management System">
                <i class="fa fa-chevron-left"></i> Database Management System
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Tinghe Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#cs537-operating-system-summary"><span class="nav-number">1.</span> <span class="nav-text"> CS537 - Operating System Summary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cpu-virtualization"><span class="nav-number">2.</span> <span class="nav-text"> CPU Virtualization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#process"><span class="nav-number">2.1.</span> <span class="nav-text"> Process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#what-is-a-process"><span class="nav-number">2.1.1.</span> <span class="nav-text"> What is a process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread"><span class="nav-number">2.1.2.</span> <span class="nav-text"> Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#why-do-we-need-processes"><span class="nav-number">2.1.3.</span> <span class="nav-text"> Why do we need processes?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#os-scheduler"><span class="nav-number">2.1.4.</span> <span class="nav-text"> OS Scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goals-for-cpu-virtualization"><span class="nav-number">2.1.5.</span> <span class="nav-text"> Goals for CPU Virtualization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mechanism"><span class="nav-number">2.2.</span> <span class="nav-text"> Mechanism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system-call"><span class="nav-number">2.2.1.</span> <span class="nav-text"> System call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-mechanism"><span class="nav-number">2.2.2.</span> <span class="nav-text"> Dispatch mechanism</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#policy"><span class="nav-number">2.3.</span> <span class="nav-text"> Policy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vocabulary"><span class="nav-number">2.3.1.</span> <span class="nav-text"> Vocabulary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fifo-first-in-first-out"><span class="nav-number">2.3.2.</span> <span class="nav-text"> FIFO (First In, First Out)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sjf-shortest-job-first"><span class="nav-number">2.3.3.</span> <span class="nav-text"> SJF (Shortest job first)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stcf-shortest-time-to-completion-first"><span class="nav-number">2.3.4.</span> <span class="nav-text"> STCF (Shortest Time-to-Completion First)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#round-robin"><span class="nav-number">2.3.5.</span> <span class="nav-text"> Round Robin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-aware-scheduling"><span class="nav-number">2.3.6.</span> <span class="nav-text"> I/O Aware Scheduling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multilevel-feedback-queue"><span class="nav-number">2.3.7.</span> <span class="nav-text"> Multilevel Feedback Queue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#memory-virtualization"><span class="nav-number">3.</span> <span class="nav-text"> Memory Virtualization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">3.1.</span> <span class="nav-text"> Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#goals"><span class="nav-number">3.1.1.</span> <span class="nav-text"> Goals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#address-space"><span class="nav-number">3.1.2.</span> <span class="nav-text"> Address space</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-access-example"><span class="nav-number">3.1.3.</span> <span class="nav-text"> Memory Access Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#basic-mechanisms"><span class="nav-number">3.2.</span> <span class="nav-text"> Basic Mechanisms</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-sharing"><span class="nav-number">3.2.1.</span> <span class="nav-text"> Time Sharing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-relocation"><span class="nav-number">3.2.2.</span> <span class="nav-text"> Static Relocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-relocation-introduction"><span class="nav-number">3.2.3.</span> <span class="nav-text"> Dynamic Relocation: Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-relocation-base-register"><span class="nav-number">3.2.4.</span> <span class="nav-text"> Dynamic Relocation: Base Register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-relocation-base-bounds"><span class="nav-number">3.2.5.</span> <span class="nav-text"> Dynamic Relocation: Base + Bounds</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#segmentation"><span class="nav-number">3.2.6.</span> <span class="nav-text"> Segmentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary"><span class="nav-number">3.2.7.</span> <span class="nav-text"> Summary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#paging"><span class="nav-number">3.3.</span> <span class="nav-text"> Paging</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fragmentation"><span class="nav-number">3.3.1.</span> <span class="nav-text"> Fragmentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction-for-paging"><span class="nav-number">3.3.2.</span> <span class="nav-text"> Introduction for Paging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#translation-of-page-addresses"><span class="nav-number">3.3.3.</span> <span class="nav-text"> Translation of Page Addresses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pagetables"><span class="nav-number">3.3.4.</span> <span class="nav-text"> Pagetables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-access-with-paging"><span class="nav-number">3.3.5.</span> <span class="nav-text"> Memory Access with Paging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#advantages-of-paging"><span class="nav-number">3.3.6.</span> <span class="nav-text"> Advantages of Paging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#disadvantages-of-paging"><span class="nav-number">3.3.7.</span> <span class="nav-text"> Disadvantages of Paging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#paging-translation-steps"><span class="nav-number">3.3.8.</span> <span class="nav-text"> Paging Translation Steps</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tlb"><span class="nav-number">3.4.</span> <span class="nav-text"> TLB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#motivative-example-iterating-array"><span class="nav-number">3.4.1.</span> <span class="nav-text"> Motivative Example: Iterating Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction-2"><span class="nav-number">3.4.2.</span> <span class="nav-text"> Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tlb-organization"><span class="nav-number">3.4.3.</span> <span class="nav-text"> TLB Organization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-iterating-array-with-tlb"><span class="nav-number">3.4.4.</span> <span class="nav-text"> Example: Iterating Array with TLB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tlb-replacement-policies"><span class="nav-number">3.4.5.</span> <span class="nav-text"> TLB Replacement Policies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#context-switches"><span class="nav-number">3.4.6.</span> <span class="nav-text"> Context Switches</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tlb-misses"><span class="nav-number">3.4.7.</span> <span class="nav-text"> TLB Misses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary-2"><span class="nav-number">3.4.8.</span> <span class="nav-text"> Summary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#smaller-page-tables"><span class="nav-number">3.5.</span> <span class="nav-text"> Smaller Page Tables</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#motivation"><span class="nav-number">3.5.1.</span> <span class="nav-text"> Motivation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#smaller-page-tables-2"><span class="nav-number">3.5.2.</span> <span class="nav-text"> Smaller Page Tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#paging-with-segmentation"><span class="nav-number">3.5.3.</span> <span class="nav-text"> Paging with Segmentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multilevel-page-tables"><span class="nav-number">3.5.4.</span> <span class="nav-text"> Multilevel Page Tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inverted-page-table"><span class="nav-number">3.5.5.</span> <span class="nav-text"> Inverted Page Table</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swapping"><span class="nav-number">3.6.</span> <span class="nav-text"> Swapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#motivation-2"><span class="nav-number">3.6.1.</span> <span class="nav-text"> Motivation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#idea"><span class="nav-number">3.6.2.</span> <span class="nav-text"> Idea</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#locality-of-reference"><span class="nav-number">3.6.3.</span> <span class="nav-text"> Locality of Reference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mechanism-2"><span class="nav-number">3.6.4.</span> <span class="nav-text"> Mechanism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#policy-page-selection"><span class="nav-number">3.6.5.</span> <span class="nav-text"> Policy: Page selection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#policy-page-replacement"><span class="nav-number">3.6.6.</span> <span class="nav-text"> Policy: Page replacement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementing-lru"><span class="nav-number">3.6.7.</span> <span class="nav-text"> Implementing LRU</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary-3"><span class="nav-number">3.7.</span> <span class="nav-text"> Summary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#concurrency"><span class="nav-number">4.</span> <span class="nav-text"> Concurrency</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-2"><span class="nav-number">4.1.</span> <span class="nav-text"> Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#processes-vs-thread"><span class="nav-number">4.1.1.</span> <span class="nav-text"> Processes vs Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#common-programming-models"><span class="nav-number">4.1.2.</span> <span class="nav-text"> Common Programming Models</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-level-threads-many-to-one"><span class="nav-number">4.1.3.</span> <span class="nav-text"> User-level threads: Many-to-one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel-level-threads-one-to-one"><span class="nav-number">4.1.4.</span> <span class="nav-text"> Kernel-level threads: One-to-one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-schedule-examples"><span class="nav-number">4.1.5.</span> <span class="nav-text"> Thread Schedule Examples</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#non-determinism"><span class="nav-number">4.1.6.</span> <span class="nav-text"> Non-Determinism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#what-do-we-want"><span class="nav-number">4.1.7.</span> <span class="nav-text"> What do we want?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronization"><span class="nav-number">4.1.8.</span> <span class="nav-text"> Synchronization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrency-objective"><span class="nav-number">4.1.9.</span> <span class="nav-text"> Concurrency Objective</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary-4"><span class="nav-number">4.1.10.</span> <span class="nav-text"> Summary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#locks"><span class="nav-number">4.2.</span> <span class="nav-text"> Locks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction-3"><span class="nav-number">4.2.1.</span> <span class="nav-text"> Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spin-lock-with-load-store"><span class="nav-number">4.2.2.</span> <span class="nav-text"> Spin Lock with Load + Store</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spin-lock-with-xchg"><span class="nav-number">4.2.3.</span> <span class="nav-text"> Spin Lock with xchg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spin-lock-with-cas"><span class="nav-number">4.2.4.</span> <span class="nav-text"> Spin Lock with CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ticket-locks"><span class="nav-number">4.2.5.</span> <span class="nav-text"> Ticket Locks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ticket-lock-with-yield"><span class="nav-number">4.2.6.</span> <span class="nav-text"> Ticket Lock with Yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue-lock"><span class="nav-number">4.2.7.</span> <span class="nav-text"> Queue Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue-lock-vs-spin-lock"><span class="nav-number">4.2.8.</span> <span class="nav-text"> Queue Lock vs Spin Lock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#condition-variables"><span class="nav-number">4.3.</span> <span class="nav-text"> Condition Variables</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ordering"><span class="nav-number">4.3.1.</span> <span class="nav-text"> Ordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition-variables-2"><span class="nav-number">4.3.2.</span> <span class="nav-text"> Condition Variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-attempt-1-no-state"><span class="nav-number">4.3.3.</span> <span class="nav-text"> Join Attempt 1: No State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-attempt-2-no-mutex-lock"><span class="nav-number">4.3.4.</span> <span class="nav-text"> Join Attempt 2: No Mutex Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-attempt-3-state-mutex-lock"><span class="nav-number">4.3.5.</span> <span class="nav-text"> Join Attempt 3: State + Mutex Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#producerconsumer-problem"><span class="nav-number">4.3.6.</span> <span class="nav-text"> Producer/Consumer Problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-attempt-1-one-cv"><span class="nav-number">4.3.7.</span> <span class="nav-text"> P/C Attempt 1: One CV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-attempt-2-two-cvs"><span class="nav-number">4.3.8.</span> <span class="nav-text"> P/C Attempt 2: Two CVs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-attempt-3-two-cvs-with-while"><span class="nav-number">4.3.9.</span> <span class="nav-text"> P/C Attempt 3: Two CVs with While</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary-5"><span class="nav-number">4.3.10.</span> <span class="nav-text"> Summary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#semaphores"><span class="nav-number">4.4.</span> <span class="nav-text"> Semaphores</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction-4"><span class="nav-number">4.4.1.</span> <span class="nav-text"> Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semaphore-operations"><span class="nav-number">4.4.2.</span> <span class="nav-text"> Semaphore Operations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#build-lock-from-semaphore"><span class="nav-number">4.4.3.</span> <span class="nav-text"> Build Lock from Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-with-cv-vs-semaphores"><span class="nav-number">4.4.4.</span> <span class="nav-text"> Join with CV vs Semaphores</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-1-producer-1-consumer-with-buffer-of-size-1"><span class="nav-number">4.4.5.</span> <span class="nav-text"> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-1-producer-1-consumer-with-buffer-of-size-n"><span class="nav-number">4.4.6.</span> <span class="nav-text"> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size N</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-multiple-producers-consumers"><span class="nav-number">4.4.7.</span> <span class="nav-text"> P/C: Multiple Producers &amp; Consumers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readerwriter-locks"><span class="nav-number">4.4.8.</span> <span class="nav-text"> Reader/Writer Locks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#build-zemaphore-from-lock-and-cv"><span class="nav-number">4.4.9.</span> <span class="nav-text"> Build Zemaphore from Lock and CV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary-6"><span class="nav-number">4.4.10.</span> <span class="nav-text"> Summary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrency-bugs"><span class="nav-number">4.5.</span> <span class="nav-text"> Concurrency Bugs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrency-in-medicine-therac-25-1980s"><span class="nav-number">4.5.1.</span> <span class="nav-text"> Concurrency in Medicine: Therac-25 (1980’s)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrency-study"><span class="nav-number">4.5.2.</span> <span class="nav-text"> Concurrency Study</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#atomicity-mysql"><span class="nav-number">4.5.3.</span> <span class="nav-text"> Atomicity: MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ordering-mozilla"><span class="nav-number">4.5.4.</span> <span class="nav-text"> Ordering: Mozilla</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deadlock"><span class="nav-number">4.6.</span> <span class="nav-text"> Deadlock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#definition"><span class="nav-number">4.6.1.</span> <span class="nav-text"> Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-1-circular-dependency"><span class="nav-number">4.6.2.</span> <span class="nav-text"> Example 1: Circular Dependency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-2-encapsulation"><span class="nav-number">4.6.3.</span> <span class="nav-text"> Example 2: Encapsulation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deadlock-theory"><span class="nav-number">4.6.4.</span> <span class="nav-text"> Deadlock Theory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-mutual-exclusion"><span class="nav-number">4.6.5.</span> <span class="nav-text"> 1. Mutual Exclusion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-hold-and-wait"><span class="nav-number">4.6.6.</span> <span class="nav-text"> 2. Hold and Wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-no-preemption"><span class="nav-number">4.6.7.</span> <span class="nav-text"> 3. No Preemption</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#circular-wait"><span class="nav-number">4.6.8.</span> <span class="nav-text"> Circular Wait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrent-data-structures"><span class="nav-number">4.7.</span> <span class="nav-text"> Concurrent Data Structures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scalability"><span class="nav-number">4.7.1.</span> <span class="nav-text"> Scalability</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#counter"><span class="nav-number">4.7.2.</span> <span class="nav-text"> Counter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#approximate-counter-sloppy-counter"><span class="nav-number">4.7.3.</span> <span class="nav-text"> Approximate Counter (Sloppy Counter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrent-linked-list"><span class="nav-number">4.7.4.</span> <span class="nav-text"> Concurrent Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-table-from-list"><span class="nav-number">4.7.5.</span> <span class="nav-text"> Hash Table from List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrent-queue"><span class="nav-number">4.7.6.</span> <span class="nav-text"> Concurrent Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary-7"><span class="nav-number">4.7.7.</span> <span class="nav-text"> Summary</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tinghe Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
