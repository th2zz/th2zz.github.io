<!DOCTYPE html>
<html lang="en">

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Database Management System - Relational Design Theory |  th2zz
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/assets/torr3.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

</head>

</html>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-Database" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Database Management System - Relational Design Theory
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/03/19/Database/" class="article-date">
  <time datetime="2019-03-18T18:00:41.000Z" itemprop="datePublished">2019-03-18</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.9k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">28分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="cs564-dbms-relational-design-theory"><a class="markdownIt-Anchor" href="#cs564-dbms-relational-design-theory"></a> <strong>CS564 - DBMS - Relational Design Theory</strong></h1>
<h2 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h2>
<h3 id="relational-algebra-and-calculus"><a class="markdownIt-Anchor" href="#relational-algebra-and-calculus"></a> Relational algebra and Calculus</h3>
<p><img src="https://i.imgur.com/kksvzjk.png" alt=""></p>
<h3 id="keys"><a class="markdownIt-Anchor" href="#keys"></a> Keys</h3>
<ul>
<li>A<strong>superkey</strong> is a set of one or more attributes that, taken collectively, allow us to identify uniquely a tuple in the relation</li>
<li>Such minimal superkeys are called <strong>candidate keys</strong>.</li>
<li>We shall use the term <strong>primary key</strong> to denote a candidate key that is chosen by the database designer as the principal means of identifying tuples within a relation.</li>
<li><strong>Foreign Key</strong> is a set of attributes in a referencing relation, such that for each tuple in the referencing relation, the values of the foreign key attributes are guaranteed to occur as the primary key value of a tuple in the referenced relation.</li>
</ul>
<h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> Join</h3>
<ul>
<li>natural join combines two tables based on identical columns</li>
<li>Cartesian product operation combines tuples from two relations, but unlike the join operation, its result contains all pairs of tuples from the two relations</li>
</ul>
<h3 id="sql-language"><a class="markdownIt-Anchor" href="#sql-language"></a> SQL Language</h3>
<ul>
<li>SQL allows us to use the keyword all to specify explicitly that duplicates are not removed</li>
<li><strong>varchar(n)</strong>: A variable-length character string with user-specified maximum length n. The full form, character varying, is equivalent.</li>
<li><strong>numeric(p, d)</strong>:Afixed-point numberwith user-specified precision. The number consists of p digits (plus a sign), and d of the p digits are to the right of the decimal point.</li>
<li><strong>Percent (%)</strong>: The % character matches any substring.</li>
<li><strong>Underscore (_)</strong>: The character _ matches any character.</li>
<li>The set operation automatically eliminates duplicates</li>
</ul>
<p><img src="https://i.imgur.com/G2hgY3K.png" alt=""></p>
<h2 id="database-design-er-model"><a class="markdownIt-Anchor" href="#database-design-er-model"></a> Database Design (ER Model)</h2>
<h3 id="terms"><a class="markdownIt-Anchor" href="#terms"></a> Terms</h3>
<ul>
<li>Entity</li>
<li>Attribute
<ul>
<li>Domain</li>
<li>Key</li>
<li>Primary Key can not be null</li>
</ul>
</li>
<li>Relationship
<ul>
<li>Descriptive attribute, the attribute of the entity in between two entities</li>
<li>A relationship should be uniquely identified</li>
<li>Instance of relationship set is a set of relationships</li>
<li>Sometimes a relationship can involve two identities in the same enetity set</li>
</ul>
</li>
<li>Constraints
<ul>
<li>Participation constraint, total, partial</li>
<li>weak enetity set</li>
<li>ISA inheritance relationship set
<ul>
<li>specialzation, generalization</li>
<li>overlap, covering constraint</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="the-relational-model"><a class="markdownIt-Anchor" href="#the-relational-model"></a> The Relational Model</h3>
<ul>
<li>Integrity Constriant
<ul>
<li>Foreign key constraint</li>
</ul>
</li>
</ul>
<h2 id="relational-design-theory"><a class="markdownIt-Anchor" href="#relational-design-theory"></a> Relational Design Theory</h2>
<h3 id="函数依赖-functional-dependency"><a class="markdownIt-Anchor" href="#函数依赖-functional-dependency"></a> 函数依赖 Functional Dependency</h3>
<ul>
<li>
<p>考虑如下的university database schema<br>
<img src="https://i.imgur.com/rjGtPin.png" width="500" height="200"><br>
将表instructor和department替换为其自然连接的结果不是一个好的选择<br>
<img src="https://i.imgur.com/JltoS4y.png" width="400"><br>
因为对于每个instructor都有部门budget信息大量重复 我们需要保证任何更新操作都要同步budget。 另一个缺点是natural inner join会去除左右两边为null的情况，所以没有instructor的部门就无法在表中被表示。<br>
<strong>但如果我们先有inst_dept表，我们该如何知道这个设计不好并且应该被分解成instructor和department呢？</strong><br>
我们需要发现每个department必须只有1个building,每个department必须只有一个budget。<br>
Not every ER design can be precise enough to avoid such problems，so we need to allow designers to specify rules such as “<strong>each specific value of dept_name corresponds to at most one budget</strong>” even in cases where dept_name is not the primary key for the schema.<br>
In this case, we need to write a rule “<strong>if there were a schema(dept_name,budget),then dept_name is able to serve as the primary key</strong>.” This rule is specified as a functional dependency:<br>
<img src="https://i.imgur.com/aaCGsjY.png" width="250"><br>
This gives sufficient information to recognize the problem of inst_dept schema. Therefore functional dependency says what relational instances are allowed under certain constraints.<br>
Functional depedency generalizes notions of key in a relation. It depicts relationship between attributes.</p>
</li>
<li>
<p><strong>Definition</strong>: A relational instance satisfies functional dependency from attribute A-&gt;B if (any) two tuples having same value of attribute A also have same value of attribute B. i.e. A uniquely determines B</p>
</li>
<li>
<p><strong>A trivial functional dependency</strong> is the one which will always hold in a relation. <strong>A-&gt;B and B is a subset of A.</strong></p>
</li>
<li>
<p><strong>Non-Trivial functional dependency</strong> may or may not hold in a relation. <strong>A-&gt;B and B is NOT a subset of A.</strong></p>
</li>
<li>
<p><strong>Properties of functional dependency</strong><br>
“Armstrong’s Axioms”<br>
<img src="https://i.imgur.com/zkhjneI.png" alt=""><br>
Other<br>
<img src="https://i.imgur.com/nNsRewf.png" alt=""><br>
<img src="https://i.imgur.com/D9pWMoO.png" alt=""></p>
</li>
<li>
<p><strong>&quot;A set of functional dependencies&quot; F</strong> is a set of FD constraints on legal relational instances in a relation.</p>
</li>
<li>
<p><strong>&quot;The closure of FDs set F&quot; F+</strong> is a set of all FDs that can be inferred from given the set F (<strong>Note that this includes all FDs in F itself</strong>).</p>
</li>
<li>
<p><strong>Attribute Closure</strong>: Attribute closure of an attribute set A is a set of all attributes that can be functionally determined from elements of set A (<strong>Note that this includes attributes in A itself</strong>).<br>
Examples:<br>
<img src="https://i.imgur.com/hf0hLCc.png" alt=""></p>
</li>
<li>
<p><strong>Determining equivalence of functional dependencies</strong><br>
Check whether 2 FD sets are subset of each other’s closure.</p>
</li>
<li>
<p><strong>Computing minimal cover</strong><br>
A minimal cover of a FD set A is the smallest set of FDs that covers A.<br>
<img src="https://i.imgur.com/ItMURpT.png" alt=""><br>
<img src="https://i.imgur.com/HOT0QpT.png" alt=""></p>
</li>
<li>
<p><strong>Other notes</strong><br>
所有非主属性都完全函数依赖于每个候选键<br>
所有主属性都完全函数依赖于每个不包含它的候选键<br>
没有任何属性完全函数依赖于非候选键的任何一组属性</p>
</li>
</ul>
<h3 id="数据异常-data-anomalies"><a class="markdownIt-Anchor" href="#数据异常-data-anomalies"></a> 数据异常 Data Anomalies</h3>
<p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h3 id="范式-normal-form"><a class="markdownIt-Anchor" href="#范式-normal-form"></a> 范式 Normal Form</h3>
<p>范式理论是为了解决以上提到四种异常。<br>
高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。<br>
<img src="https://i.imgur.com/v1zy4Cw.png" width="250" height="200"></p>
<h4 id="分解"><a class="markdownIt-Anchor" href="#分解"></a> 分解</h4>
<p><strong>Universal Relation:</strong> A relation that captures all the information in schema and is decomposable into smaller relations.</p>
<ul>
<li>
<p>Decomposition of a relation is done when a relation in relational model is not in appropriate normal form. A good/detailed ER model should end up directly as a 3NF or BCNF. The functional dependencies guide us to determine entities and their relationships</p>
</li>
<li>
<p>Ideal decomposition should be <strong>lossless</strong> and <strong>dependency preserving</strong>.<br>
For relation R decomposed into R1 and R2:<br>
<img src="https://i.imgur.com/LIH6YcZ.png" width="300"></p>
</li>
<li>
<p>Example:<br>
<img src="https://i.imgur.com/HRk77Rk.png" width="300"><br>
<img src="https://i.imgur.com/BKpXIIy.png" width="300"><br>
employee表被分解为employee1表和employee2表：因为employee可以重名，所以我们将分解结果natural join会无法还原employee表。</p>
</li>
<li>
<p><strong>Lossless decomposition(lossless join decomposition) Requirements</strong><br>
<img src="https://i.imgur.com/7it87CU.png" alt=""></p>
</li>
<li>
<p><strong>Dependency preserving decomposition</strong><br>
If we decompose a relation R into relations R1 and R2, All dependencies of R either must be a part of R1 or R2 or must be derivable from combination of FD’s of R1 and R2.</p>
<ul>
<li>Example:</li>
</ul>
<ol>
<li>R (A, B, C, D) with FD set{A-&gt;BC} is decomposed into R1(ABC) and R2(AD) which is dependency preserving because FD A-&gt;BC is a part of R1(ABC).</li>
<li>R(A,B,C,D) and functional dependencies A-&gt;B and C-&gt;D. Then the decomposition of R into R1(AB) and R2(CD) is dependency preserving but not lossless join because it violates the second condition of lossless join and A-&gt;B can be ensured in R1(AB) and C-&gt;D can be ensured in R2(CD). Hence it is dependency preserving decomposition.</li>
</ol>
</li>
</ul>
<h4 id="1-第一范式-1nf-atomicity原子性"><a class="markdownIt-Anchor" href="#1-第一范式-1nf-atomicity原子性"></a> 1. 第一范式 (1NF) Atomicity(原子性)</h4>
<p>表的属性不可分（表的属性不可为复合属性）。然而注意复合属性有时也是有用的并被大量实际使用于面向对象数据库。</p>
<h4 id="2-boycecodd-normal-formbcnf-每个表中只有一个候选键"><a class="markdownIt-Anchor" href="#2-boycecodd-normal-formbcnf-每个表中只有一个候选键"></a> 2. Boyce–Codd normal form(BCNF) 每个表中只有一个候选键</h4>
<p>BCNF is a slightly stronger version of 3NF.<br>
Every BCNF satisfies 3NF. It eliminates all redundancy that can be discovered based on functional dependencies.<br>
<strong>A database design is in BCNF</strong> if each member of the set of relation schemas that constitutes the design is in BCNF.</p>
<p><strong>Definition：</strong><br>
A relational schema R is in BCNF with respect to a set of functional dependencies F if for all functional dependencies in F+ of form A-&gt;B where A,B are subsets of R, at least one of the following holds:</p>
<ul>
<li>A-&gt;B is a trivial functional dependency (B is a subset of A)</li>
<li>A is a super key of schema R</li>
</ul>
<p><strong>Another equivalent definition (important):</strong><br>
For all nontrivial FD A-&gt;B, A must be a super key of schema R.<br>
<strong>The negated definition</strong><br>
A relational schema R is not in BCNF w.r.t FDs set F if there exists a FD in F+ of form A-&gt;B where A,B are subsets of R s.t.<br>
A-&gt;B is a nontrivial FD (B is not a subset of A) <strong>AND</strong> A is not a super key of schema R.<br>
<strong>Example</strong>:<br>
inst_dept (ID, name, salary, dept_name, building, budget) is not in BCNF because dept_name-&gt;budget is a nontrivial FD and dept_name is not a super key of inst_dept.<br>
The schema instructor and department are not in BCNF because for all nontrivial FDs, either left side is not super key, or is super key. (in that case: ID, dept_name can be super key for each schema).<br>
<strong>Decomposing relational schema to BCNF</strong><br>
For a relational schema R not in BCNF, we must have at least 1 nontrivial FD A-&gt;B s.t. A is not a super key for R.<br>
We decompose R into 2 schemas:<br>
<img src="https://i.imgur.com/NbVERSD.png" width="180"><br>
For inst_dept, A=dept_name, B={building,budget}, it can be decomposed to (dept_name, building, budget) AND (ID,name,salary,dept_name)<br>
<strong>Problem of BCNF:</strong></p>
<ul>
<li>BCNF is not dependency preserving.</li>
</ul>
<h4 id="3-第三范式-3nf-2nf消除传递函数依赖"><a class="markdownIt-Anchor" href="#3-第三范式-3nf-2nf消除传递函数依赖"></a> 3. 第三范式 (3NF) 2NF&amp;消除传递函数依赖</h4>
<p>BCNF requires A to be a superkey for nontrival FD A-&gt;B. 3NF relaxes the constraints by allowing A to not be a super key.<br>
<strong>Definition：</strong><br>
A relational schema R is in 3NF with respect to a set of functional dependencies F if for all functional dependencies in F+ of form A-&gt;B where A,B are subsets of R, at least one of the following holds:</p>
<ul>
<li>A-&gt;B is a trivial functional dependency (B is a subset of A)</li>
<li>A is a super key of schema R</li>
<li>Each attribute X in B-A is contained in a candidate key in R</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>存在以下transitive functional dependency：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p><img src="https://i.imgur.com/iLeQOu8.png" alt=""></p>
<h3 id="multi-dimensional-database"><a class="markdownIt-Anchor" href="#multi-dimensional-database"></a> Multi-dimensional database</h3>
<p><img src="https://i.imgur.com/1RU9DJz.jpg" alt=""></p>
<p>Think spreadsheets and reporting but generalized.</p>
<ul>
<li>A star schema is the simplest form of a dimensional model, in which data is organized into facts and dimensions.  A fact is an event that is counted or measured, such as a sale or login.  A dimension contains reference information about the fact, such as date, product, or customer. A star schema is diagramed by surrounding each fact with its associated dimensions. The resulting diagram resembles a star.<br>
<img src="https://i.imgur.com/7xGywCG.png" alt=""></li>
<li>Example:<br>
<img src="https://i.imgur.com/n4OrKwb.jpg" alt=""></li>
</ul>
<h3 id="levels-of-abstraction-in-dbms"><a class="markdownIt-Anchor" href="#levels-of-abstraction-in-dbms"></a> Levels of abstraction in DBMS</h3>
<ul>
<li>Physical Schema is the way the relations are actually stored in SSD/HDD. It also defines indexes, statistics etc. defined on the table. (Indexes are defined using DDL.)</li>
<li>Logical (Conceptual) Schema is the DDL for creating the table. (It can sometimes specify the physical schema.)</li>
<li>External Schema is the DDL that define’s the external user’s view of the database. Though some “base” tables are directly visible, most of it is protected through views.</li>
</ul>
<h2 id="storage-and-file-structure"><a class="markdownIt-Anchor" href="#storage-and-file-structure"></a> Storage and File Structure</h2>
<h3 id="storage-overview"><a class="markdownIt-Anchor" href="#storage-overview"></a> Storage Overview</h3>
<ul>
<li>Persistent storage nonvolatile memory
<ul>
<li>Data in a DBMS has to be persistent</li>
<li>SSD: flash memory based, faster and more expensive</li>
<li>HDD: magnetic storage, slower and cheaper</li>
<li>Tapes: disks are the new tapes, still great for archiving</li>
<li>Cloud server</li>
</ul>
</li>
<li>Volatile storage
<ul>
<li>DRAM</li>
</ul>
</li>
</ul>
<h3 id="memory-hierarchy"><a class="markdownIt-Anchor" href="#memory-hierarchy"></a> Memory hierarchy</h3>
<p><img src="https://i.imgur.com/1EP43L3.jpg" alt=""></p>
<h3 id="disk"><a class="markdownIt-Anchor" href="#disk"></a> Disk</h3>
<p><img src="https://i.imgur.com/RJ2GrlY.png" alt=""></p>
<ul>
<li>
<p>The disk surface is logically divided into tracks, which are subdivided into sectors.</p>
<ul>
<li>A <strong>sector</strong> is the smallest unit of information that can be read from or written to the disk.</li>
<li>The <strong>read–write head</strong> stores information on a sector magnetically as reversals of the direction of magnetization of the magnetic material.</li>
<li>The <strong>platters</strong> that are <strong>fixed on a spindle rod</strong> spin, say 90 rps</li>
<li>Arm assembly moves in or out to position a head on desired track.</li>
<li>The tracks make an imaginary 空心<strong>cylinder</strong>: tracks with the same radius on all surfaces of disks platters     <strong>#cylinder = #tracks/surface</strong></li>
<li>#surface = #tracks/#cylinder = 2#platters</li>
<li>Only one head used at a time</li>
<li><strong>Block size</strong> is a multiple of sector size (fixed, usually 512 bytes)</li>
<li><strong>capacity</strong> = heads(#surfaces) x cylinder x sectors x 512 (typical size of one sector in bytes) =  #surfaces * #tracks * #sectors per track * bytes per sector</li>
</ul>
</li>
<li>
<p>Seek time: the time for repositioning the arm to change track.</p>
</li>
<li>
<p>Rotational delay: the time for getting to the right sector = 0.5(60s/磁盘转速rpm)   0.5为average</p>
</li>
<li>
<p>transfer time: actual overhead for transfering data = moving head across block</p>
</li>
</ul>
<p>Seek time + rotational delay is the major contributor to delay.<br>
<strong>Formatting</strong>: defining polar coordinate system on disk surface.<br>
<strong>wear leveling</strong>: storing hot data on less weared sectors and storing cold data on more weared sector to extend service time of the disk.</p>
<ul>
<li>
<p>RAID 0 Data stripping<br>
RAID 0 consists of striping, but no mirroring or parity. Compared to a spanned volume, the capacity of a RAID 0 volume is the same; it is the sum of the capacities of the disks in the set. But because striping distributes the contents of each file among all disks in the set, the failure of any disk causes all files, the entire RAID 0 volume, to be lost. A broken spanned volume at least preserves the files on the unfailing disks. The benefit of RAID 0 is that the throughput of read and write operations to any file is multiplied by the number of disks because, unlike spanned volumes, reads and writes are done concurrently,[11] and the cost is complete vulnerability to drive failures.</p>
</li>
<li>
<p>RAID 1 Mirroring<br>
RAID 1 consists of data mirroring, without parity or striping. Data is written identically to two drives, thereby producing a “mirrored set” of drives. Thus, any read request can be serviced by any drive in the set. If a request is broadcast to every drive in the set, it can be serviced by the drive that accesses the data first (depending on its seek time and rotational latency), improving performance. Sustained read throughput, if the controller or software is optimized for it, approaches the sum of throughputs of every drive in the set, just as for RAID 0. Actual read throughput of most RAID 1 implementations is slower than the fastest drive. Write throughput is always slower because every drive must be updated, and the slowest drive limits the write performance. The array continues to operate as long as at least one drive is functioning.</p>
</li>
<li>
<p>RAID 5 Stripping with Distributed Parity<br>
Upon failure of a single drive, subsequent reads can be calculated from the distributed parity such that no data is lost. RAID 5 requires at least three disks.</p>
</li>
<li>
<p>RAID 6 two parity disks<br>
RAID 6 consists of block-level striping with double distributed parity. Double parity provides fault tolerance up to two failed drives. This makes larger RAID groups more practical, especially for high-availability systems, as large-capacity drives take longer to restore. RAID 6 requires a minimum of four disks. As with RAID 5, a single drive failure results in reduced performance of the entire array until the failed drive has been replaced.[11] With a RAID 6 array, using drives from multiple sources and manufacturers, it is possible to mitigate most of the problems associated with RAID 5. The larger the drive capacities and the larger the array size, the more important it becomes to choose RAID 6 instead of RAID 5.</p>
</li>
</ul>
<h3 id="database-buffer"><a class="markdownIt-Anchor" href="#database-buffer"></a> Database Buffer</h3>
<ul>
<li>A major goal of the database system is to minimize the number of block transfers between the disk and memory.</li>
<li>The subsystem responsible for the allocation of buffer space is called the buffer manager.</li>
</ul>
<h3 id="file-organization"><a class="markdownIt-Anchor" href="#file-organization"></a> File Organization</h3>
<p><img src="https://i.imgur.com/V8RvRQk.jpg" alt=""></p>
<p><strong>A fixed length record</strong> is one where the length of the fields in each record has been set to be a certain maximum number of characters long. Suppose a field that was going to contain a name was set to be 25 characters long. This means that the field could only ever contain up to 25 characters. If all the fields in the record have a fixed length like this then the record is said to be a fixed length record. The problem with fixed length records is that each field very rarely contains the maximum number of characters allowed. This means that a lot of space is needlessly set aside and wasted. Also, values sometimes cannot be entered because they are too large to fit inside the allowed space in a field. The advantage of fixed length records is that they make file processing much easier because the start and end of each record is always a fixed number of characters apart. This makes it much easier to locate both indicidual records and fields.<br>
<img src="https://i.imgur.com/FdzIIl7.png" alt=""></p>
<p><img src="https://i.imgur.com/O6PKrwj.jpg" alt=""><br>
A <strong>variable length record</strong> is one where the length of a field can change to allow data of any size to fit. The advantage of variable length records is that space is not wasted, only the space needed is ever used. The main problem with variable length records is that it is much more difficult to locate the start and end of individual records and fields. This is because they are not separated by a fixed amount of characters. To separate variable length recordseach field has a special character to mark where it ends- called an end- of- field marker. When records need to be located the computer must count through the end- of- field markers to locate individual records and fields.</p>
<p><img src="https://i.imgur.com/VBlJR9B.png" alt=""></p>
<p><img src="https://i.imgur.com/6NoscfG.png" alt=""><br>
<img src="https://i.imgur.com/TXo6UxW.png" alt=""><br>
<img src="https://i.imgur.com/t6f8Eqi.png" alt=""><br>
<img src="https://i.imgur.com/cdRtHS5.png" alt=""></p>
<ul>
<li>Columnar storage<br>
A column-oriented DBMS (or columnar database management system) is a database management system (DBMS) that stores data tables by column rather than by row. Practical use of a column store versus a row store differs little in the relational DBMS world. Both columnar and row databases can use traditional database query languages like SQL to load data and perform queries. Both row and columnar databases can become the backbone in a system to serve data for common extract, transform, load (ETL) and data visualization tools. However, by storing data in columns rather than rows, the database can more precisely access the data it needs to answer a query rather than scanning and discarding unwanted data in rows. Query performance is increased for certain workloads.</li>
</ul>
<h3 id="storage-summary"><a class="markdownIt-Anchor" href="#storage-summary"></a> Storage summary</h3>
<ul>
<li>Databases must have persistent storage: SSD, HDD Their performance characteristics affect database design</li>
<li>Buffer manager tries to keep the optimal set of data blocks (pages) in memory to minimize I/O</li>
<li>must be able to “lock” (pin) a page in memory</li>
<li>must be able to write / flush page to disk on demand</li>
<li>Rows comprise both fixed and variable length fields</li>
<li>Slotted page format is flexible to keep records organized and accessible on a page</li>
<li>Single column values could be stored in fixed length records, but are usually compressed via encodings</li>
<li>Compression is used at both column and block level Heap files are ok but most databases use B+ trees</li>
<li>Columnar storage is another tool in the database tool-kit, soon all DBMS vendors will have it</li>
</ul>
<h2 id="indexing-and-hashing"><a class="markdownIt-Anchor" href="#indexing-and-hashing"></a> Indexing and Hashing</h2>
<h3 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> B+ tree</h3>
<ul>
<li><strong>Properties</strong>
<ul>
<li>
<p>It can be shown that the number of I/O operations needed in the worst case for an insertion is proportional to logn/2(N), where n is the maximum number of pointers in a node, and N is the number of records in the file being indexed.</p>
</li>
<li>
<p>It contains up to n − 1 search-key values K1 , K2 , . . . , Kn − 1 , and n pointers  P1 , P2 , . . . , Pn . The search-key values within a node are kept in sorted order; thus, if i &lt; j, then Ki &lt; Kj<br>
<img src="https://i.imgur.com/ApVXPRo.png" alt=""></p>
</li>
<li>
<p>Each <strong>non-leaf</strong> node in the tree has between n/2 and n children, where n is fixed for a particular tree.</p>
</li>
<li>
<p>A <strong>non-leaf</strong> node may hold up to n pointers, and must hold at least n/2 pointers. The number of pointers in a node is called the fanout of the node.</p>
</li>
<li>
<p>Each <strong>leaf</strong> can hold up to n − 1 values. We allow leaf nodes to contain as few as (n − 1)/2 values. With n = 4 in our example B±tree, each leaf must contain at least 2 values, and at most 3 values.</p>
</li>
<li>
<p>Since, n = 4 and 1 &lt; (n − 1)/2, we must either merge the node with a sibling node, or redistribute the entries between the nodes, to ensure that each node is at least half-full.</p>
</li>
</ul>
</li>
<li>Insertion
<ul>
<li>Split</li>
<li>Coalesce</li>
</ul>
</li>
<li>Deletion
<ul>
<li>if the occupancy of a node falls below 2n/3, the system attempts to borrow an entry from one of the sibling nodes</li>
<li>Borrow left, pick max one</li>
<li>Borrow right, pick min one</li>
<li>Merge left, shift left, change parent</li>
<li>Merge right, shift right, change parent</li>
</ul>
</li>
<li><strong>Non-unique search key</strong>: If a relation can have more than one record containing the same search key value (that is, two or more records can have the same values for the indexed attributes), the search key is said to be a non-unique search key.</li>
<li><strong>Bulk-loading in B+ tree</strong>
<ul>
<li>Insertion of a large number of entries at a time into an index is referred to as bulk loading of the index.</li>
<li>sort the file on the search key of the index being constructed</li>
<li>There is a significant benefit to sorting the entries before inserting them into the B+tree.</li>
<li>nodes will never have to be read from disk during bulk load, if the B+ tree was empty to start with. Each leaf node will thus incur only one I/O operation even though many entries may be inserted into the node.</li>
</ul>
</li>
<li><strong>bottom-up B+ tree construction</strong>
<ul>
<li>it can be constructed faster by building it bottom-up, from the leaf level, instead of using the usual insert procedure.</li>
<li>we break up the sorted entries into blocks, keeping as many entries in a block as can fit in the block; the resulting blocks form the leaf level of the B±tree. The minimum value in each block, alongwith the pointer to the block, is used to create entries in the next level of the B±tree, pointing to the leaf blocks</li>
</ul>
</li>
</ul>
<h3 id="hashing"><a class="markdownIt-Anchor" href="#hashing"></a> HASHING</h3>
<h4 id="static-hashing"><a class="markdownIt-Anchor" href="#static-hashing"></a> Static Hashing</h4>
<ul>
<li>We use the term <strong>bucket</strong> to denote a unit of storage that can store one or more records.</li>
<li>let <strong>K</strong> denote the set of all search-key values, and let <strong>B</strong> denote the set of all bucket addresses. A <strong>hash function h</strong> is a function from K to B. Let h denote a hash function.</li>
<li>Hash function should be random and uniform</li>
<li>Algorithm is similiar to Data Structure Hash Table</li>
</ul>
<h4 id="dynamic-hashing"><a class="markdownIt-Anchor" href="#dynamic-hashing"></a> Dynamic Hashing</h4>
<p><img src="https://i.imgur.com/jAg67QV.png" alt=""></p>
<h3 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> BITMAP</h3>
<ul>
<li>A <strong>bitmap</strong> is simply an array of bits. In its simplest form, a bitmap index on the attribute A of relation r consists of one bitmap for each value that A can take. Each bitmap has as many bits as the number of records in the relation. The ith bit of the bitmap for value vj is set to 1 if the record numbered i has the value vj for attribute A. All other bits of the bitmap are set to 0.</li>
</ul>
<p><img src="https://i.imgur.com/bjJkZQR.png" alt=""></p>
<ul>
<li>To recognize deleted records,we can store an <strong>existence bitmap</strong>, in which bit i is 0 if record i does not exist and 1 otherwise.
<ul>
<li>If some records have been deleted, however, just computing the complement of a bitmap is not sufficient. Bits corresponding to such records would be 0 in the original bitmap, but would become 1 in the complement, although the records don’t exist.</li>
</ul>
</li>
<li><strong>Limitation</strong>
<ul>
<li>If there are further conditions, the fraction of records satisfying all the conditions is likely to be quite small.</li>
<li>If the fraction is large, scanning the entire relation would remain the cheaper alternative.</li>
</ul>
</li>
<li><strong>Counting the number of bits that are 1 in a bitmap</strong> can be done quickly by a clever technique. We can maintain an array with 256 entries, where the ith entry stores the number of bits that are 1 in the binary representation of i.</li>
</ul>
<h3 id="储存与索引总结"><a class="markdownIt-Anchor" href="#储存与索引总结"></a> 储存与索引总结</h3>
<p>atomicity problem:  transaction is executed totally or not at all<br>
integrated storage structure: index file 和record file一起<br>
seperate file: 相反</p>
<p>clustered index 与原数据同顺序<br>
clustered indexes do not guarantee sequential storage on the disk. Managing exactly where data is placed on the disk is the job of the OS, not the DBMS. But it suggests that items are ordered generally according to the clustering key.</p>
<p>With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indexes, although each new index will increase the time it takes to write new records.</p>
<p>It is generally faster to read from a clustered index if you want to get back all the columns. You do not have to go first to the index and then to the table.</p>
<p>Writing to a table with a clustered index can be slower, if there is a need to rearrange the data</p>
<p>primary index: using primary key for indexing</p>
<p>secondary index: otherwise</p>
<p>index以block为单位进行index  within block用offset</p>
<p>hash index  通过哈希函数生成hash address to a bucket with possible overflow chain for managing collision<br>
cheaper than B+tree if no overflow occurs Access: O(1+#overflow buckets)<br>
所以hash索引的最大的特点就是等值查询快，不能进行范围索引。<br>
位图索引适合静态low-cardinality重复数据<br>
b树索引同时支持范围及等值查询</p>
<p>b tree m-way(order m, m fanout, m-1info fields) search tree with additional constraints:  叶子层高度相同 root 2 key  其他节点至少半满ceiling(order/2)来尽量减少高度    若想要插入的位置已满  recursively按中序遍历顺序将中点上移 同时将前驱后继节点分开 始终保持节点半满的要求<br>
b+ tree 更贴近多级索引，是在b树基础上, nonleaf node sparse index 减少disk page access  支持equality search 在叶子层将nonleaf节点key按中序遍历顺序拷贝下来 叶子层包含record ptrs 保持中序遍历顺序建立链表 形成dense &amp; clustered index 从而支持range search<br>
删除： 左合并 右合并 来满足半满的限制  split if necessary can propagate to root.<br>
order=#ptr fields = p    /node<br>
#k,v fields = p-1          /node</p>
<p>(p-1)(key_ptr_size + record_ptr_size) + p(block_ptr_size) &lt;= blocksize=512</p>
<p>static hashing: linear congruential hash function with fixed #hash buckets  use overflow chain to manage contention</p>
<p>extendible hashing: nonlinear hashing congruential function such as h_k(v)=h(v) mod 2^k  use directory of size 2^k to store ptrs to hash buckets<br>
when collisions happen increment k value and maps it elsewhere</p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://th2zz.github.io/2019/03/19/Database/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/03/23/Threaded Binary Tree and Morris Traversal/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Threaded Binary Tree and Morris Traversal
          
        </div>
      </a>
    
    
      <a href="/2019/03/16/Operating System - Virtualization/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Operating System - Virtualization</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
<div class="gitalk" id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '24a8a906a3b6e08b0b7a',
    clientSecret: 'a8443a2a0006c8e48692bb49c1ac84a9e51b0426',
    repo: 'gitalk-comment',
    owner: 'th2zz',
    admin: ['th2zz'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2016-2020
        th2zz
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="th2zz"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Suche">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['生きるとはつまり螺旋のことだったんだよ！','',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>