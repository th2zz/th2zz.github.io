<!DOCTYPE html>
<html lang="en">

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Operating System - Persistence |  th2zz
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/assets/torr3.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

</head>

</html>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-Operating System - Persistence" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Operating System - Persistence
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/04/11/Operating System - Persistence/" class="article-date">
  <time datetime="2019-04-11T01:51:23.000Z" itemprop="datePublished">2019-04-10</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">2.6k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">15分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="cs537-operating-system-summary-part-2-persistence"><a class="markdownIt-Anchor" href="#cs537-operating-system-summary-part-2-persistence"></a> <strong>CS537 - Operating System Summary Part 2 Persistence</strong></h1>
<h1 id="persistence"><a class="markdownIt-Anchor" href="#persistence"></a> Persistence</h1>
<h2 id="io-device-and-communication-protocol"><a class="markdownIt-Anchor" href="#io-device-and-communication-protocol"></a> IO Device and Communication Protocol</h2>
<h3 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h3>
<ul>
<li>we want <strong>hardware</strong> that will let us plug in different devices</li>
<li>we want <strong>OS</strong> that can interact with different combinations of HW</li>
</ul>
<h3 id="hardware-support-for-io-device-in-system-architecture"><a class="markdownIt-Anchor" href="#hardware-support-for-io-device-in-system-architecture"></a> Hardware support for IO device in system architecture</h3>
<ul>
<li>different buses have different speed, costs, size/volume of devices that need to be connected with</li>
<li>high speed buses are very expensive to manufacture</li>
<li>Hierarchical buses are a good solution<br>
<img src="https://i.imgur.com/8mMkV75.png" alt=""></li>
<li>proprietary bus: <strong>60GB/s</strong> on a 4-core system</li>
<li>General I/O bus: PCI…etc. <strong>1-4GB/s</strong></li>
<li>Peripheral I/O bus: disk devices, SCSI, SATA, USB, <strong>100MB/s</strong></li>
<li>Modern system hierarcical uses more specialized chipset and p2p interconnects for better performance. Example Z270 Chipset:<br>
<img src="https://i.imgur.com/eXgCTWC.png" alt=""></li>
<li>Dedicated Graphics bus: facilitate graphics intensive applications such as gaming, interactive web browser, and photo manipulations.</li>
<li>Higher performance devices connected via PCIe, NVMe persistent storage.</li>
<li>lower performance devices connected via USB, eSATA: modern sata standard, SSD: higher speed storage</li>
</ul>
<h3 id="oss-view-to-device-a-canonical-device"><a class="markdownIt-Anchor" href="#oss-view-to-device-a-canonical-device"></a> OS’s view to Device &amp; a canonical device</h3>
<p><img src="https://i.imgur.com/DtbaXIO.png" alt=""></p>
<ul>
<li>Interface: where OS reads/writes to, allow system to control its operations</li>
<li>Internal Structure (Varies depends on different devices &amp; manufacture): microcontroller, extra memory, special-purpose chips…connection to cache/disk drives, graphics cards…</li>
</ul>
<h3 id="a-canonical-protocol-os-writing-to-device"><a class="markdownIt-Anchor" href="#a-canonical-protocol-os-writing-to-device"></a> A canonical protocol OS writing to device</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (STATUS == BUSY)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">Write data to DATA <span class="keyword">register</span></span><br><span class="line">Write command to COMMAND <span class="keyword">register</span></span><br><span class="line"><span class="keyword">while</span> (STATUS == BUSY)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Simple polling protocol works but is inefficient sometimes:</li>
</ul>
<table>
<thead>
<tr>
<th>CPU</th>
<th>sys_write A</th>
<th>waits</th>
<th>copy Data &amp; Command to A</th>
<th>wait(for command to be executed)</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISK</td>
<td>busy</td>
<td>busy</td>
<td></td>
<td>busy</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>The policy of polling itself reduces CPU utilization when job processing time can be long</li>
<li>Using interrupt instead<br>
<img src="https://i.imgur.com/lgYgLBu.png" alt=""></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (STATUS == BUSY) <span class="comment">// 1</span></span><br><span class="line">    wait <span class="keyword">for</span> interrupt;</span><br><span class="line">Write data to DATA <span class="keyword">register</span> <span class="comment">// 2</span></span><br><span class="line">Write command to COMMAND <span class="keyword">register</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">while</span> (STATUS == BUSY) <span class="comment">// 4</span></span><br><span class="line">    wait <span class="keyword">for</span> interrupt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Interrupt improves CPU utilization in this case.</li>
<li>Summary: Polling/Interrupt is a tradeoff.
<ul>
<li>Faster devices:
<ul>
<li>better to spin(poll) and keep waiting than taking interrupt overhead</li>
</ul>
</li>
<li>Unknown device speed:
<ul>
<li>Hybrid approach (spin then use interrupts)</li>
</ul>
</li>
<li>Better not to use interrupts when Floods of interrupts arrive:
<ul>
<li>Example: floods of requests to the NIC device of a webserver</li>
<li>can lead to livelock (always handling interrupts rather than doing actual works - user level processes to service some requests)</li>
<li>Better to ignore interrupts and use some polling to make some progress handling them and control what is happening in the system</li>
</ul>
</li>
<li>Other improvement
<ul>
<li>Interrupt coalescing (batch together several interrupts into a single one): This reduces overhead of interrupts processing</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="data-transfer-costs-more-efficient-data-movement-with-dma"><a class="markdownIt-Anchor" href="#data-transfer-costs-more-efficient-data-movement-with-dma"></a> Data Transfer Costs &amp; More efficient data movement with DMA</h3>
<ul>
<li>Programmed I/O:
<ul>
<li>Programmed IO(PIO) is a method of transferring data between the CPU and a peripheral, such as a network adapter or an ATA storage device. Each data item transfer is initiated by an instruction in the program, involving the CPU for every transaction.</li>
<li>when using PIO to transfer a large chunk of data to a device. CPU is overburdened with trivial tasks of copying data from memory to device explicitly one word at a time. Poor CPU utilization!<br>
<img src="https://i.imgur.com/NxnvlJU.png" alt=""></li>
<li><strong>Solution</strong>: Direct Memory Access (DMA)
<ul>
<li>CPU let a <strong>special purpose device “DMA engine”</strong> to copy data on behalf of it.</li>
<li>OS would program the DMA engine by telling it where the data lives inmemory, how much data to copy, and which device to send it to</li>
<li>CPU is thus free and OS can do something else: this improves both CPU and disk utilization, and improves the time of copying data into the <strong>data register</strong> in a device. (not command register because commands are usually very small in size).<br>
<img src="https://i.imgur.com/by6oZkv.png" alt=""><br>
<img src="https://i.imgur.com/XuKa5ys.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (STATUS == BUSY) <span class="comment">// 1</span></span><br><span class="line">    ;</span><br><span class="line">Write command to COMMAND <span class="keyword">register</span> <span class="comment">// no step 2 anymore, 3</span></span><br><span class="line"><span class="keyword">while</span> (STATUS == BUSY) <span class="comment">// 4</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<h3 id="methods-of-device-interactions"><a class="markdownIt-Anchor" href="#methods-of-device-interactions"></a> Methods of Device interactions</h3>
<ul>
<li>How OS communicates with Device? (Doesn’t matter much, both are used)
<ul>
<li>Special instructions
<ul>
<li>each device has a port</li>
<li>in/out instructions (x86) communicate with device</li>
</ul>
</li>
<li>Memory-Mapped I/O
<ul>
<li>H/W maps registers into address space
<ul>
<li>example: eax ebx cpu register</li>
</ul>
</li>
<li>loads/stores of mapped register sent to device
<ul>
<li>load/store eax/ebx</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="device-drivers"><a class="markdownIt-Anchor" href="#device-drivers"></a> Device Drivers</h3>
<p><img src="https://i.imgur.com/tYLHgXh.png" alt=""></p>
<ul>
<li>Motivation: we want to keep device general and neutral as much as possible and hide the details of device interactions with OS subsystems.</li>
<li>Device driver: At the lowest level, a piece of software in the OS must know in detail how a device works. Any specifics of device interaction are encapsulated within.</li>
<li>Significance: Writing device driver for each device helps us abstract hardware and avoid writing different OS for different H/W combinations.</li>
<li>Example: we want a file system that works with SSD, USB, SATA</li>
<li>Problem: Many devices in a system! Each has its own protocol!
<ul>
<li>Drivers are 70% of Linux Source code and major causes of OS crashes.</li>
</ul>
</li>
</ul>
<h2 id="hard-disks"><a class="markdownIt-Anchor" href="#hard-disks"></a> Hard Disks</h2>
<h3 id="hard-disk-interface-and-its-view-to-osuser"><a class="markdownIt-Anchor" href="#hard-disk-interface-and-its-view-to-osuser"></a> Hard Disk Interface and its view to OS/User</h3>
<ul>
<li>The abstraction to OS/User</li>
</ul>
<table>
<thead>
<tr>
<th>sector 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>sector 1</td>
</tr>
<tr>
<td>sector 2</td>
</tr>
<tr>
<td>…</td>
</tr>
</tbody>
</table>
<ul>
<li>Disk has a sector-addressable address space</li>
<li>Appears as an array of sectors</li>
<li>Similar to Paging, sectors are typically 512 bytes/sector</li>
<li>Main operations: <strong>atomic</strong> read/write to a particular sector. When power failure, can have guranntee that r/w to a sector is done or not.</li>
<li>Mechanical and slow</li>
</ul>
<h3 id="internals-performance-measure"><a class="markdownIt-Anchor" href="#internals-performance-measure"></a> Internals &amp; Performance Measure</h3>
<img src="https://i.imgur.com/eMcYqyA.png" width="250">
<img src="https://i.imgur.com/zwN9ySC.png" width="250">
<ul>
<li>Platter: a circular/disk shape entity with magnetic foam on both sides</li>
<li>Spindle: connected with motor to make platter spin.</li>
<li>RPM(Rotations Per Minutes): tells the rate of platter spinning. 10000RMP = 1 rotation/6ms<br>
<img src="https://i.imgur.com/b8jsBT7.png" alt=""></li>
<li>Surface: one side of a platter. <strong>Both sides</strong> can be written/read.</li>
<li>tracks: a ring of certain inner &amp; outer radius, surface is divided into different tracks. Tracks are divided into numbered sectors. Each track in above graph has 8 sectors.</li>
<li>cylinder: stack of tracks across platters. This idea is useful when we want to do uniform operations on the same track of each surfaces.</li>
<li>Arm seeks over desired tracks, platter rotates! <strong>A head per surface for R/W!</strong></li>
<li>Reading/Writing data from disks<br>
<img src="https://i.imgur.com/gP9kn0E.png" width="250">
<ul>
<li>Rotation Delay: the waiting time for the platter to rotate till the head is positioned at right sector on the single track. On average R/2.<br>
<img src="https://i.imgur.com/uYVVvU7.png" width="250"></li>
<li>Seek Time: the waiting time for disk arm to be positioned on the right track.</li>
<li>Transfer Time: actual time data is either read from or written to the surface.</li>
<li>Overall Time to Read/write
<ul>
<li><strong>Time_IO = seek + rotation + transfer</strong></li>
<li>IO rate (mainly used for comparing drives performance):
<ul>
<li><strong>IO_rate = size to transfer / Time_IO</strong></li>
</ul>
</li>
</ul>
</li>
<li>Summary
<ul>
<li>Seek cost (major): Function of cylinder distance. Not purely linear cost. Must accelerate, coast, decelerate, settle. Settling alone can take 0.5 - 2 ms. Entire seeks often takes 4 - 10 ms. <strong>Average seek = 1/3 of max seek</strong>.</li>
<li>Rotate cost (major): Depends on rotations per minute (RPM). 7200 RPM is common, 15000 RPM is high end. <strong>Average rotation = 1/2 of rotation delay</strong></li>
<li>Transfer time: pretty fast. depends on RPM and sector density. 100+ MB/s is typical for maximum transfer rate.</li>
</ul>
</li>
</ul>
</li>
<li>IO time calculation Example
<ul>
<li><img src="https://i.imgur.com/Xf8oBgw.png" alt=""> Find  the time for 4KB random read for Cheetah (on average).</li>
<li>Solution:
<ul>
<li>Tseek = 4ms</li>
<li>Trotate = 15000R/60s = 15000R/60000ms = 0.25R/ms = 4 R/ms = 2R/ms on average</li>
<li>Ttransfer = 4KB/(125MB/s) = 4/125 ms</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="workload-performance"><a class="markdownIt-Anchor" href="#workload-performance"></a> Workload Performance</h3>
<ul>
<li>Question: How does two kinds of workload affect performance?
<ul>
<li>Sequential: reads a large number of sectors consecutively from the disk, without jumping around.</li>
<li>Random: issues small (e.g., 4KB) reads to random locations on the disk.</li>
<li>Example:<br>
<img src="https://i.imgur.com/WdGY378.png" alt="">
<ul>
<li>What is throughput (IO rate) for sequential workload and random workload for Cheetah?
<ul>
<li>Sequential: 4ms seek + 2ms rotate + 1s transfer = 1.006s This means effective throughput is almost equal to 125MB/s</li>
<li>Random: IO time = 6ms, 4KB/6ms &lt;&lt;&lt; 125MB/s <strong>much lower throughput than sequential access</strong>.</li>
</ul>
</li>
<li>Conclusion: When at all possible, transfer data to and from disks in a sequential manner. If sequential is not possible, at least think about transferring data in large chunks: the bigger, the better. If I/O is done in little random pieces, I/O performance will suffer dramatically.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="some-techniques-manufacturers-use-to-improve-performance-of-disks"><a class="markdownIt-Anchor" href="#some-techniques-manufacturers-use-to-improve-performance-of-disks"></a> Some techniques manufacturers use to improve performance of disks</h3>
<h4 id="track-skew-skewed-layout"><a class="markdownIt-Anchor" href="#track-skew-skewed-layout"></a> Track Skew (skewed layout):</h4>
<ul>
<li>How should sector number be laid out so that we can continue reading sequentially?</li>
<li>
<img src="https://i.imgur.com/1aGAVKw.png" width="250">
</li>
<li>Goal: We want low overhead and seamless transformation from 15 to 16 when we want to read 16 after 15.</li>
<li>Solution with track skew method:
<ul>
<li>idea: <strong>overlapping seek and rotation</strong></li>
<li>
<img src="https://i.imgur.com/ravLbuh.png" width="250">
</li>
<li>By the time the platter rotate, the head already place at position of 16.</li>
</ul>
</li>
</ul>
<h4 id="zones"><a class="markdownIt-Anchor" href="#zones"></a> Zones</h4>
<ul>
<li>Idea: outer tracks have more area available than inner tracks and thus can store more data. But we fixed sector size. So we can have <strong>non-uniform division</strong>: more sectors on outer tracks to utilize that space.</li>
<li>
<img src="https://i.imgur.com/bULnWS6.png" width="250">
</li>
<li>Zone bit recording: call collection of sectors as zone.</li>
</ul>
<h4 id="cache-inside-drive"><a class="markdownIt-Anchor" href="#cache-inside-drive"></a> Cache inside drive</h4>
<ul>
<li>Idea: Drives may cache both reads and writes. (In addition to OS cache). Cache is not big (2MB-16MB)</li>
<li>Advantages of caching in drive for read:
<ul>
<li>Store recently read sectors. Fetch it from cache.</li>
<li>Read-ahead: read contents of entire track into cache. predictively facilitates sequential workload.</li>
</ul>
</li>
<li>Advantages &amp; Disadvantages of caching in drive for write:
<ul>
<li>Immediate reporting: CPU doesn’t need to wait for write to finish. Can acknowledge a write even before the write actually makes it to the magnetic medieum.</li>
<li>Danger: cached data can be lost on power failure.</li>
</ul>
</li>
<li>Other advantages: multiple outstanding requests
<ul>
<li>Tagged command queuing: Disk can reorder/schedule requests for better performance.</li>
</ul>
</li>
</ul>
<h2 id="io-scheduler-scheduling-policies-and-tradeoff"><a class="markdownIt-Anchor" href="#io-scheduler-scheduling-policies-and-tradeoff"></a> IO scheduler, scheduling policies and tradeoff</h2>
<h3 id="motivation-2"><a class="markdownIt-Anchor" href="#motivation-2"></a> Motivation</h3>
<p>Given a stream of I/O requests, in what <strong>order</strong> should they be served?</p>
<ul>
<li>Example timeline: P1Read___P2Read___P3write__</li>
</ul>
<h3 id="goal"><a class="markdownIt-Anchor" href="#goal"></a> Goal</h3>
<ul>
<li>OS should dispatch requests in certain order to the shared storage device disk.</li>
</ul>
<h3 id="key-problem"><a class="markdownIt-Anchor" href="#key-problem"></a> Key Problem</h3>
<ul>
<li>Much different than CPU scheduling, Position of disk head relative to request position matters more than length of job</li>
<li>Example:
<ul>
<li>FCFS/FIFO: Assume seek+rotate = 10 ms for random request, How long (roughly) does the below workload take? Requests are given in sector numbers:
<ul>
<li>300001, 700001, 300002, 700002, 300003, 700003  = 60ms because each time we need to seek and rotate</li>
<li>300001, 300002, 300003, 700001, 700002, 700003  = 20ms 2 sequential pattern<br>
-This shows why IO scheduling is important.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="crux"><a class="markdownIt-Anchor" href="#crux"></a> Crux</h3>
<ul>
<li>we want to implement an algorithm that <strong>more closely approximates SJF by taking both seek and rotation into account</strong>.</li>
</ul>
<h3 id="sstf-shortest-seek-time-first"><a class="markdownIt-Anchor" href="#sstf-shortest-seek-time-first"></a> SSTF (Shortest SEEK Time First)</h3>
<ul>
<li>Strategy always choose request that requires <strong>least seek time</strong> (time for seeking and rotating)</li>
<li>Greedy algorithm (looks for local optimal)</li>
<li>Implementation in OS: use sector number as a substitite, order by nearest sector number first, try to issue requests that are closely together.</li>
<li>Disadvantages: starvation!
<ul>
<li>ex. 30001,30002,…,70001(starved)</li>
<li>avoid starvation:
<ul>
<li>Scan/Elevator Algorithm: Sweep back and forth, from one end of disk other, serving requests as pass that cylinder; Sorts by cylinder number(order of tracks); ignores rotation delays;
<ul>
<li>
<img src="https://i.imgur.com/ZnJPy5F.png" width="150/">
</li>
<li>
<p>Example: input 101 201 102 301 203; output_order 101 201 301 203 102 (first bit track#)</p>
</li>
<li>
<p>This ensure for example the request at outermost track does not starve!</p>
</li>
<li>
<p>This is a “Best effort” work done on OS side -&gt; logically like sorting</p>
</li>
</ul>
</li>
<li>C-SCAN(Circular Scan Algorithm): Only sweep in one direction. 1-&gt;2-&gt;3 reset 1-&gt;2-&gt;3
<ul>
<li>This is more fair than SCAN because in pure backand-forth SCAN middle one 2 is treated more times on average than peripheral 1 and 3.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Problem: SCAN and SSTF  do not actually adhere as closely to the principle of SJF as they could. In particular, they ignore rotation.</li>
</ul>
<h3 id="sptfshortest-positioning-time-first"><a class="markdownIt-Anchor" href="#sptfshortest-positioning-time-first"></a> SPTF(Shortest Positioning Time First)</h3>
<img src="https://i.imgur.com/gAfQtUL.png" width="200">
<ul>
<li>
<p>Example: we get 2 requests one to 16, one to 8. 16 gets shorter seek but longer rotate, 8 has shorter rotation delay and longer seek. If seek time is higher than rotational delay in the disk in this example, then SSTF related policies are fine = we want to minimize seek time. So go to 16. Otherwise 8 is a better choice because we need to minimize rotation delay to have better performance.</p>
</li>
<li>
<p>This algorithm is complex, for simplicity, many OS only implements shortest seek time first</p>
</li>
</ul>
<h3 id="where-should-io-scheduler-go-os-vs-disk"><a class="markdownIt-Anchor" href="#where-should-io-scheduler-go-os-vs-disk"></a> Where should IO scheduler go? OS vs Disk.</h3>
<ul>
<li>Disk: it knows disk geometry much better but fixed by hardware, can be hard to update firmware or the scheduler.</li>
<li>OS: knows processes that are requesting, so we can do some weighted or fair sharing across processes. Easy to update scheduler software. Can have multiple disks scheudler and change scheduler based on workload pattern.</li>
<li>Typical state of the art approach: has a simple scheduler in OS side that sorts the requests based on sector locations, then has one more complex scheduler on disk side to take account of seek time and rotation time in order to minimize things further. But typically OS sends multiple requests to disk, so disk scheduelr can do some reordering between them.</li>
</ul>
<h3 id="how-busy-should-we-keep-the-disk"><a class="markdownIt-Anchor" href="#how-busy-should-we-keep-the-disk"></a> How busy should we keep the disk?</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This is a procedure that reads from a file </span></span><br><span class="line"><span class="comment">//descriptor 1KB at a time and process that.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];	</span><br><span class="line">    <span class="keyword">int</span>	rv;	</span><br><span class="line">    <span class="keyword">while</span>((rv = read(buf,fd)) != <span class="number">0</span>) &#123;	</span><br><span class="line">	 	    assert(rv);	</span><br><span class="line">	 	    <span class="comment">// takes short time, e.g., 1ms	</span></span><br><span class="line">	 	    process(buf, rv);	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://i.imgur.com/ThnSHG3.png" width="150">
<br>
<ul>
<li>
<p>assume 2 processes calling read() with C-SCAN,consider workload pattern: 100 101 200 201 102 103 202. This pattern is possible because there is maybe 1 ms gap between 101 and 102 so that other threads(processes) can interrupt. This is very inefficient. Should the OS always submit requests waiting present on the queue or should wait to see if other requests arrive (BE work-conserving and let disk be idle at some point so that we can make more efficient progress in the future)?</p>
</li>
<li>
<p>Work conservation (a trick used by linux scheduler)</p>
<ul>
<li>not work conserving/violating work-conservation: might wait for a while to merge or get a better sequence of requests</li>
<li>Work conserving schedulers always try to do work if there’s work to be done <strong>(always run a request if resource is free)</strong>
<ul>
<li>Sometimes, it’s better to wait instead if system anticipates another request will arrive.</li>
<li>example: I/O Merging. OS coalesces several IO requests into ONE. Less IO overhead.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="raid"><a class="markdownIt-Anchor" href="#raid"></a> RAID</h2>
<h3 id="motivation-3"><a class="markdownIt-Anchor" href="#motivation-3"></a> Motivation</h3>
<ul>
<li>Typical scenario</li>
</ul>
<table>
<thead>
<tr>
<th>APP</th>
</tr>
</thead>
<tbody>
<tr>
<td>OS FS</td>
</tr>
<tr>
<td>Storage Devices:most file systems work with one disk</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>sometimes we need many disks for reasons:</p>
<ul>
<li>Capacity</li>
<li>Performance</li>
<li>Reliability</li>
</ul>
</li>
<li>
<p>Solution1 JBOD - Just a bunch of disks<br>
<img src="https://i.imgur.com/0XJooqP.png" alt=""></p>
<ul>
<li>Applications store data on different FS, ex. critical data that app decides to replicate</li>
<li>Downsides: need to know multiple devices, need to be rewritten, not deployable</li>
</ul>
</li>
<li>
<p>Solution2 RAID - Redundant Array of Inexpensive (Independent) Disks<br>
<img src="https://i.imgur.com/A4kPGQM.png" alt=""></p>
<ul>
<li>abstract multiple physical disks into one logical disk to OS</li>
<li>Advantages: transparent to apps, deployable Improved capacity, performance, and reliability!</li>
</ul>
</li>
</ul>
<h3 id="fault-model-of-raid"><a class="markdownIt-Anchor" href="#fault-model-of-raid"></a> Fault Model of RAID</h3>
<ul>
<li>Simple: Fail-stop model</li>
<li>Either works correctly or fails entirely</li>
<li>System can easily detect which part is not working</li>
<li>No silent failures, No corruptions, …etc…</li>
</ul>
<h3 id="general-strategy-of-raid-mapping"><a class="markdownIt-Anchor" href="#general-strategy-of-raid-mapping"></a> General strategy of RAID - Mapping</h3>
<p><img src="https://i.imgur.com/djO9nvL.png" alt=""></p>
<ul>
<li>Mapping blocks: build fast, large disk from smaller ones</li>
<li>Very similar to VM: go from virtual space to physical space by looking up TLB and pagetable</li>
<li>VM mapping is dynamic - mapping can change for example, when memory is free and is reallocated.</li>
<li>RAID mapping is static - translation is simple static calculation: no lookup</li>
</ul>
<h3 id="general-strategy-of-raid-redundancy"><a class="markdownIt-Anchor" href="#general-strategy-of-raid-redundancy"></a> General strategy of RAID - Redundancy</h3>
<p><img src="https://i.imgur.com/hrQi5Rw.png" alt=""></p>
<ul>
<li>Add even more disks for reliability</li>
<li>More redundancy == More fault tolerance</li>
<li>This is a tradeoff
<ul>
<li>Redundancy improves reliability (and maybe performance)</li>
<li>Deduplication improves space efficiency</li>
</ul>
</li>
</ul>
<h3 id="raid-analysis"><a class="markdownIt-Anchor" href="#raid-analysis"></a> RAID analysis</h3>
<ul>
<li>RAID level: different levels</li>
<li>Workload: types of reads/writes issued by app</li>
<li>Metric: capacity, reliability, performance</li>
<li>Analysis mode: given Workload, Raid level, determine/calculate Metric</li>
</ul>
<h3 id="raid-levels"><a class="markdownIt-Anchor" href="#raid-levels"></a> RAID levels</h3>
<ol start="0">
<li>Stripping</li>
<li>Mirroring</li>
<li>Parity</li>
<li>Rotated parity<br>
We will not discuss 2, 3, 6 in this class.</li>
</ol>
<h3 id="workload"><a class="markdownIt-Anchor" href="#workload"></a> Workload</h3>
<p><img src="https://i.imgur.com/x9e3J0f.png" alt=""></p>
<h3 id="metrics"><a class="markdownIt-Anchor" href="#metrics"></a> Metrics</h3>
<p><img src="https://i.imgur.com/hfU880R.png" alt=""></p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://th2zz.github.io/2019/04/11/Operating System - Persistence/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/04/22/Database Management System - Indexing/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Database Management System - Indexing
          
        </div>
      </a>
    
    
      <a href="/2019/04/09/Computer Networking/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Computer Networking</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
<div class="gitalk" id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '24a8a906a3b6e08b0b7a',
    clientSecret: 'a8443a2a0006c8e48692bb49c1ac84a9e51b0426',
    repo: 'gitalk-comment',
    owner: 'th2zz',
    admin: ['th2zz'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2016-2020
        th2zz
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="th2zz"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['生きるとはつまり螺旋のことだったんだよ！','',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>