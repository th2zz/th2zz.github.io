<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="th2zz">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="th2zz">
    
    <meta name="keywords" content="th2zz's blog,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Operating System - Concurrency · th2zz&#39;s blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/torr3.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <script>
        var _hmt = _hmt || [];
        (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?true";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
    <!-- 谷歌统计  -->
    
    <script>
        (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
        ga('create', 'true', 'auto');
        ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
</head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >th2zz&#39;s blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Operating System - Concurrency</a>
            </div>
    </div>
    
    <a class="home-link" href=/>th2zz's blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Operating System - Concurrency
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "OS">OS</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">6.6k</span>Reading time: <span class="post-count reading-time">40 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/04/02</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="cs537-operating-system-summary-part-2-concurrency"><a class="markdownIt-Anchor" href="#cs537-operating-system-summary-part-2-concurrency"></a> <strong>CS537 - Operating System Summary Part 2 Concurrency</strong></h1>
<h1 id="concurrency"><a class="markdownIt-Anchor" href="#concurrency"></a> Concurrency</h1>
<h2 id="thread"><a class="markdownIt-Anchor" href="#thread"></a> Thread</h2>
<h3 id="processes-vs-thread"><a class="markdownIt-Anchor" href="#processes-vs-thread"></a> Processes vs Thread</h3>
<ul>
<li>
<p>Process</p>
<ul>
<li>Example: Chrome (process per tab)</li>
<li>Communicate via pipe() or similar</li>
<li>Pros: Don’t need new abstractions; good for security</li>
<li>Cons:
<ul>
<li>Cumbersome programming</li>
<li>High communication overheads</li>
<li>Expensive context switching</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Thread</p>
<ul>
<li>Multiple threads of same process share an address space</li>
<li>Divide large task across several cooperative threads</li>
<li>Communicate through shared address space</li>
<li>Shared: page directories, page tables, code segment</li>
<li>Not Shared: instruction pointer, stack</li>
</ul>
</li>
<li>
<p>Multiple threads within a single process share:</p>
<ul>
<li>Process ID (PID)</li>
<li>Address space: Code (instructions), Most data (heap)</li>
<li>Open file descriptors</li>
<li>Current working directory</li>
<li>User and group id</li>
</ul>
</li>
<li>
<p>Each thread has its own</p>
<ul>
<li>Thread ID (TID)</li>
<li>Set of registers, including Program counter and Stack pointer</li>
<li>Stack for local variables and return addresses (in same address space)</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/3DmuMbX.png" alt=""></p>
<h3 id="common-programming-models"><a class="markdownIt-Anchor" href="#common-programming-models"></a> Common Programming Models</h3>
<ul>
<li>
<p>Producer/consumer</p>
<ul>
<li>Multiple producer threads create data (or work) that is handled by one of the multiple consumer threads</li>
</ul>
</li>
<li>
<p>Pipeline</p>
<ul>
<li>Task is divided into series of subtasks, each of which is handled in series by a different thread</li>
</ul>
</li>
<li>
<p>Defer work with background thread</p>
<ul>
<li>One thread performs non-critical work in the background (when CPU idle)</li>
</ul>
</li>
</ul>
<h3 id="user-level-threads-many-to-one"><a class="markdownIt-Anchor" href="#user-level-threads-many-to-one"></a> User-level threads: Many-to-one</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Implemented by user-level runtime libraries</li>
<li>Create, schedule, synchronize threads at user-level</li>
<li>OS is not aware of user-level threads</li>
<li>OS thinks each process contains only a single thread of control</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Does not require OS support; Portable</li>
<li>Can tune scheduling policy to meet application demands</li>
<li>Lower overhead thread operations since no system call</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Cannot leverage multiprocessors</li>
<li>Entire process blocks when one thread blocks</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/usa8UOF.png" width="50%" style="margin:auto; display: block;">
<h3 id="kernel-level-threads-one-to-one"><a class="markdownIt-Anchor" href="#kernel-level-threads-one-to-one"></a> Kernel-level threads: One-to-one</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>OS provides each user-level thread with a kernel thread</li>
<li>Each kernel thread scheduled independently</li>
<li>Thread operations (creation, scheduling, synchronization) performed by OS</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Each kernel-level thread can run in parallel on a multiprocessor</li>
<li>When one thread blocks, other threads from process can be scheduled</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Higher overhead for thread operations</li>
<li>OS must scale well with increasing number of threads</li>
</ul>
</li>
</ul>
 <img src="https://i.imgur.com/NVLmaXh.png" width="50%" style="margin:auto; display: block;">
<h3 id="thread-schedule-examples"><a class="markdownIt-Anchor" href="#thread-schedule-examples"></a> Thread Schedule Examples</h3>
<ul>
<li>
<p>Assume <code>M[0x123]</code> = 100 initially, and we want to increment it by 1 twice</p>
</li>
<li>
<p>Example 1</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br><br><br><br></td>
<td><br><br><br><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 102<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 102</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Example 2</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br><br><br><br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br></td>
<td><br><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br><br><br></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="non-determinism"><a class="markdownIt-Anchor" href="#non-determinism"></a> Non-Determinism</h3>
<ul>
<li>
<p>Concurrency leads to non-deterministic results</p>
<ul>
<li>Different results even with same inputs</li>
<li>race conditions</li>
</ul>
</li>
<li>
<p>Whether bug manifests depends on CPU schedule!</p>
</li>
<li>
<p>How to program: imagine scheduler is malicious?!</p>
</li>
</ul>
<h3 id="what-do-we-want"><a class="markdownIt-Anchor" href="#what-do-we-want"></a> What do we want?</h3>
<ul>
<li>
<p>Want 3 instructions to execute as an uninterruptable group</p>
</li>
<li>
<p>That is, we want them to be atomic</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x123, %eax </span><br><span class="line">add $0x1, %eax  </span><br><span class="line">mov %eax, 0x123</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>More general: Need mutual exclusion for critical sections</p>
<ul>
<li>if thread A is in critical section C, thread B isn’t</li>
<li>(okay if other threads do unrelated work)</li>
</ul>
</li>
</ul>
<h3 id="synchronization"><a class="markdownIt-Anchor" href="#synchronization"></a> Synchronization</h3>
<ul>
<li>Build higher-level synchronization primitives in OS</li>
<li>Operations that ensure correct ordering of instructions across threads</li>
<li>Use help from hardware</li>
</ul>
<h3 id="concurrency-objective"><a class="markdownIt-Anchor" href="#concurrency-objective"></a> Concurrency Objective</h3>
<ul>
<li>
<p>Mutual exclusion (e.g., A and B don’t run at same time)</p>
<ul>
<li>solved with locks</li>
</ul>
</li>
<li>
<p>Ordering (e.g., B runs after A does something)</p>
<ul>
<li>solved with condition variables and semaphores</li>
</ul>
</li>
</ul>
<h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3>
<ul>
<li>Concurrency is needed for high performance when using multiple cores</li>
<li>Threads are multiple execution streams within a single process or address space (share PID and address space, own registers and stack)</li>
<li>Context switches within a critical section can lead to non-deterministic bugs</li>
</ul>
<h2 id="locks"><a class="markdownIt-Anchor" href="#locks"></a> Locks</h2>
<h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3>
<ul>
<li>
<p>Goal: Provide mutual exclusion (mutex)</p>
</li>
<li>
<p>Atomic operation: No other instructions can be interleaved</p>
</li>
</ul>
<ol>
<li>
<p>Allocate and Initialize</p>
<ul>
<li>
<figure class="highlight plain"><figcaption><span>mylock </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">2. Acquire</span><br><span class="line">    - Acquire exclusion access to lock;</span><br><span class="line">    - Wait if lock is not available (some other process in critical section)</span><br><span class="line">    - Spin or block (relinquish CPU) while waiting</span><br><span class="line">    - ```Pthread_mutex_lock(&amp;mylock);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Release</p>
<ul>
<li>Release exclusive access to lock; let another process enter critical section</li>
<li>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Implementation Goals</span><br><span class="line">- Correctness</span><br><span class="line">    - Mutual exclusion</span><br><span class="line">        - Only one thread in critical section at a time</span><br><span class="line">    - Progress (deadlock-free) </span><br><span class="line">        - If several simultaneous requests, must allow one to proceed</span><br><span class="line">        - Deadlock happens when all threads are waiting for lock</span><br><span class="line"></span><br><span class="line">    - Bounded (starvation-free)</span><br><span class="line">        - Must eventually allow each waiting thread to enter</span><br><span class="line">        - The waiting time for lock is bounded</span><br><span class="line"></span><br><span class="line">- Fairness: Each thread waits for same amount of time</span><br><span class="line">- Performance: CPU is not used unnecessarily</span><br><span class="line"></span><br><span class="line">### Spin Lock with Interrupts</span><br><span class="line">- Idea</span><br><span class="line">    - Turn off interrupts for critical sections</span><br><span class="line">    - Prevent dispatcher from running another thread</span><br><span class="line">    - Code between interrupts executes atomically</span><br><span class="line"></span><br><span class="line">- Implementation code</span><br><span class="line">    ```c=</span><br><span class="line">    void acquire(lockT *l) &#123;</span><br><span class="line">        disableInterrupts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void release(lockT *l)  &#123; </span><br><span class="line">        enableInterrupts(); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>Disadvantages
<ul>
<li>Only works on uniprocessors</li>
<li>Process can keep control of CPU for arbitrary length</li>
<li>Cannot perform other necessary work</li>
</ul>
</li>
</ul>
<h3 id="spin-lock-with-load-store"><a class="markdownIt-Anchor" href="#spin-lock-with-load-store"></a> Spin Lock with Load + Store</h3>
<ul>
<li>
<p>Idea: uses a single <strong>shared</strong> lock variable</p>
</li>
<li>
<p>Implementation code</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared variable </span></span><br><span class="line">boolean lock = <span class="literal">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(Boolean *lock)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (*lock) <span class="comment">/* wait */</span> ; </span><br><span class="line">    *lock = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Boolean *lock)</span> </span>&#123; </span><br><span class="line">    *lock = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Race condition</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>while (*lock)</code><br><br><br> <code>lock = true;</code></td>
<td><br><code>while (*lock)</code> <br> <code>*lock = true;</code><br><br></td>
</tr>
</tbody>
</table>
<ul>
<li>Both threads grab lock!</li>
<li>Problem: Testing lock and setting lock are not atomic</li>
</ul>
</li>
</ul>
<h3 id="spin-lock-with-xchg"><a class="markdownIt-Anchor" href="#spin-lock-with-xchg"></a> Spin Lock with xchg</h3>
<ul>
<li>
<p>xchg: Atomic exchange or test-and-set</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return what was pointed to by addr</span></span><br><span class="line"><span class="comment">// at the same time, store newval into addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *addr;</span><br><span class="line">    *addr = newval;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implementation code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; <span class="comment">// 0 =&gt; unlocked; 1 =&gt; locked</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit loop when flag changed from 0 (unlocked) to 1 (locked)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; <span class="comment">// set the flag to 0 (unlocked)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="spin-lock-with-cas"><a class="markdownIt-Anchor" href="#spin-lock-with-cas"></a> Spin Lock with CAS</h3>
<ul>
<li>
<p>CAS: Compare and Swap</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomic instruction</span></span><br><span class="line"><span class="comment">// set newval to *addr when *addr == expected</span></span><br><span class="line"><span class="comment">// return what was pointed to by addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> expected, <span class="keyword">int</span> newval)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> actual = *addr; </span><br><span class="line">    <span class="keyword">if</span> (actual == expected)  </span><br><span class="line">        *addr = newval; </span><br><span class="line">    <span class="keyword">return</span> actual; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implementation code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin-wait (do nothing)  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Exercise with xchg and CAS</p>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = xchg(&amp;a, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> c = CompareAndSwap(&amp;b, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> d = CompareAndSwap(&amp;b, <span class="number">1</span>, <span class="number">3</span>) ;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Result:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h3 id="ticket-locks"><a class="markdownIt-Anchor" href="#ticket-locks"></a> Ticket Locks</h3>
<ul>
<li>
<p>Basic spinlocks are unfair</p>
<p><img src="https://i.imgur.com/l2lu5Vn.png" alt=""></p>
<ul>
<li>Scheduler is unaware of locks/unlocks!</li>
</ul>
</li>
<li>
<p>Introduction to Ticket Locks</p>
<ul>
<li>
<p>Idea: reserve each thread’s turn to use a lock.</p>
</li>
<li>
<p>Each thread spins until their turn.</p>
</li>
<li>
<p>Use new atomic primitive, fetch-and-add</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> old = *ptr; </span><br><span class="line">    *ptr = old + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> old; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Acquire: Grab ticket; Spin while not thread’s ticket != turn</p>
</li>
<li>
<p>Release: Advance to next turn</p>
</li>
</ul>
</li>
<li>
<p>Example</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Event</th>
<th>ticket</th>
<th>Turn</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A <code>lock()</code></td>
<td>0</td>
<td>0</td>
<td>A runs</td>
</tr>
<tr>
<td>2</td>
<td>B <code>lock()</code></td>
<td>1</td>
<td></td>
<td>B spins until turn = 1</td>
</tr>
<tr>
<td>3</td>
<td>C <code>lock()</code></td>
<td>2</td>
<td></td>
<td>C spins until turn = 2</td>
</tr>
<tr>
<td>4</td>
<td>A <code>unlock()</code></td>
<td></td>
<td>1</td>
<td>B runs</td>
</tr>
<tr>
<td>5</td>
<td>A <code>lock()</code></td>
<td>3</td>
<td></td>
<td>A spins until turn = 3</td>
</tr>
<tr>
<td>6</td>
<td>B <code>unlock()</code></td>
<td></td>
<td>2</td>
<td>C runs</td>
</tr>
<tr>
<td>7</td>
<td>C <code>unlock()</code></td>
<td></td>
<td>3</td>
<td>A runs</td>
</tr>
<tr>
<td>8</td>
<td>A <code>unlock()</code></td>
<td></td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Ticket Lock Implementation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> ticket; </span><br><span class="line">    <span class="keyword">int</span> turn; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn); <span class="comment">// spin</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ticket-lock-with-yield"><a class="markdownIt-Anchor" href="#ticket-lock-with-yield"></a> Ticket Lock with Yield</h3>
<ul>
<li>
<p>Spinlock Performance</p>
<ul>
<li>
<p>Fast when…</p>
<ul>
<li>many CPUs</li>
<li>locks held a short time</li>
<li>advantage: avoid context switch</li>
</ul>
</li>
<li>
<p>Slow when…</p>
<ul>
<li>one CPU</li>
<li>locks held a long time</li>
<li>disadvantage: spinning is wasteful</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CPU Scheduler is Ignorant</p>
<ul>
<li>CPU scheduler may run B, C, D instead of A even though B, C, D are waiting for A</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/Avi05dZ.png" alt=""></p>
<ul>
<li>
<p>Ticket Locks with Yield</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> ticket; </span><br><span class="line">    <span class="keyword">int</span> turn; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn) &#123;</span><br><span class="line">        yield(); <span class="comment">// yield instead of spin</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Yield instead of Spin</p>
</li>
</ul>
<p><img src="https://i.imgur.com/cXfmvjp.png" alt=""></p>
<ul>
<li>Time Comparison: Yield vs Spin
<ul>
<li>
<p>Assumption</p>
<ul>
<li>Round robin scheduling, 10ms time slice</li>
<li>Process A, B, C, D, E, F, G, H, I, J in the system</li>
</ul>
</li>
<li>
<p>Timeline</p>
<ul>
<li>A: lock() … compute … unlock()</li>
<li>B: lock() … compute … unlock()</li>
<li>…</li>
<li>J: lock() … compute … unlock()</li>
<li>A: lock() … compute … unlock()</li>
<li>…</li>
</ul>
</li>
<li>
<p>If A’s compute is 20ms long, starting at t = 0, when does B get lock with spin ?</p>
<ul>
<li>
<p>110 ms</p>
<table>
<thead>
<tr>
<th>A…J</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>If B’s compute is 30ms long, when does C get lock with spin ?</p>
<ul>
<li>
<p>320 ms</p>
<table>
<thead>
<tr>
<th>A…J</th>
<th>A…J</th>
<th>A…J</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>If context switch time = 1ms, when does B get lock with yield ?</p>
<ul>
<li>29 ms</li>
<li>
<table>
<thead>
<tr>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>9</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="queue-lock"><a class="markdownIt-Anchor" href="#queue-lock"></a> Queue Lock</h3>
<ul>
<li>
<p>Motivation</p>
<ul>
<li>
<p>Time complexity of spinlock</p>
<ul>
<li>Without yield: O(threads * time_slice)</li>
<li>With yield: O(threads * context_switch)</li>
</ul>
</li>
<li>
<p>Even with yield, spinning is slow with high thread contention</p>
</li>
</ul>
</li>
<li>
<p>Idea</p>
<ul>
<li>Block and put thread on waiting queue instead of spinning</li>
<li>Remove waiting threads from scheduler ready queue</li>
<li>(e.g., <code>park()</code> and <code>unpark(threadID)</code>)</li>
<li>Scheduler runs any thread that is ready</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>A &amp; C has 60ms of work</li>
<li>A, B, D contend for lock</li>
<li>C not contending</li>
<li>Context switch + yield takes 5ms</li>
</ul>
</li>
<li>
<p>Timeline</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Event</th>
<th>Running</th>
<th>Runnable</th>
<th>Waiting</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td></td>
<td>A, B, C, D</td>
<td></td>
</tr>
<tr>
<td>0-20</td>
<td>A scheduled</td>
<td>A</td>
<td>B, C, D</td>
<td></td>
</tr>
<tr>
<td>20-25</td>
<td>B scheduled &amp; blocked</td>
<td></td>
<td>C, D, A</td>
<td>B</td>
</tr>
<tr>
<td>25-45</td>
<td>C scheduled</td>
<td>C</td>
<td>D, A</td>
<td>B</td>
</tr>
<tr>
<td>45-50</td>
<td>D scheduled &amp; blocked</td>
<td></td>
<td>A, C</td>
<td>B, D</td>
</tr>
<tr>
<td>50-70</td>
<td>A scheduled</td>
<td>A</td>
<td>C</td>
<td>B, D</td>
</tr>
<tr>
<td>70-90</td>
<td>C scheduled</td>
<td>C</td>
<td>A</td>
<td>B, D</td>
</tr>
<tr>
<td>90-110</td>
<td>A scheduled &amp; finished</td>
<td>A</td>
<td>C</td>
<td>B, D</td>
</tr>
<tr>
<td>110-130</td>
<td>C scheduled &amp; finished</td>
<td>C</td>
<td>B</td>
<td>D</td>
</tr>
<tr>
<td>130-150</td>
<td>B scheduled &amp; finished</td>
<td>B</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>150-170</td>
<td>D scheduled &amp; finished</td>
<td>D</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Incorrect Implementation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> guard = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">queue_t</span> q;</span><br><span class="line">&#125; LockT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Grab guard</span></span><br><span class="line"><span class="comment">// 2. If lock is held, add to queue and park</span></span><br><span class="line"><span class="comment">// 3. If lock is not held, grab the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;lock) &#123; </span><br><span class="line">        qadd(l-&gt;q, tid); </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">        park();     <span class="comment">// blocked  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        l-&gt;lock = <span class="literal">true</span>; </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Grab guard</span></span><br><span class="line"><span class="comment">// 2. If queue is empty, release hte lock</span></span><br><span class="line"><span class="comment">// 3. If the queue is not empty, unpark head of queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (qempty(l-&gt;q))</span><br><span class="line">        l-&gt;lock=<span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(qremove(l-&gt;q));  </span><br><span class="line">    l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Questions and Answers</p>
<ul>
<li>
<p>Why is guard used?<br>
To ensure queue operations is thread safe</p>
</li>
<li>
<p>Why OK to spin on guard?<br>
Very shhort critical section</p>
</li>
<li>
<p>In release(), why not set <code>lock = false</code> when unpark?<br>
<code>lock == true</code> is passed from one thread to the next</p>
</li>
</ul>
</li>
<li>
<p>Race Condition for Previous Implementation</p>
<table>
<thead>
<tr>
<th>Thread 1 (in lock)</th>
<th>Thread 2 (in unlock)</th>
</tr>
</thead>
<tbody>
<tr>
<td>if (l-&gt;lock) {<br> qadd(l-&gt;q, tid); <br> l-&gt;guard = false; <br> <br> <br> <br><br>  park()</td>
<td><br> <br> <br> while (TAS(&amp;l-&gt;guard, true)); <br> if (qempty(l-&gt;q)) // false!!  <br> else unpark(qremove(l-&gt;q)); <br> l-&gt;guard = false;   <br> <br></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Correct Implementation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> guard = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">queue_t</span> q;</span><br><span class="line">&#125; LockT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;lock) &#123; </span><br><span class="line">        qadd(l-&gt;q, tid); </span><br><span class="line">        setpark(pid); <span class="comment">// notify of plan</span></span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">        park();     <span class="comment">// blocked  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        l-&gt;lock = <span class="literal">true</span>; </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (qempty(l-&gt;q))</span><br><span class="line">        l-&gt;lock=<span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(qremove(l-&gt;q));  </span><br><span class="line">    l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Time Comparison: Yield vs Blocking</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>Round robin scheduling, 10ms time slice</li>
<li>Process A, B, C, D, E, F, G, H, I, J in the system</li>
<li>Context switch takes 1ms</li>
</ul>
</li>
<li>
<p>Timeline</p>
<ul>
<li>A: lock() … compute … unlock()</li>
<li>B: lock() … compute … unlock()</li>
<li>…</li>
<li>J: lock() … compute … unlock()</li>
<li>A: lock() … compute … unlock()</li>
<li>…</li>
</ul>
</li>
<li>
<p>If A’s compute is 30ms long, starting at t = 0, when does B get lock with yield?</p>
<ul>
<li>
<p>48 ms</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>9</td>
<td>10</td>
<td>9</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>If A’s compute is 30ms long, starting at t = 0, when does B get lock with blocking?</p>
<ul>
<li>
<p>39 ms</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B…J</th>
<th>A</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>9</td>
<td>10</td>
<td>10</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="queue-lock-vs-spin-lock"><a class="markdownIt-Anchor" href="#queue-lock-vs-spin-lock"></a> Queue Lock vs Spin Lock</h3>
<ul>
<li>
<p>Each approach is better under different circumstances</p>
</li>
<li>
<p>Uniprocessor</p>
<ul>
<li>Waiting process is scheduled à Process holding lock isn’t</li>
<li>Waiting process should always relinquish processor</li>
<li>Associate queue of waiters with each lock (as in previous implementation)</li>
</ul>
</li>
<li>
<p>Multiprocessor</p>
<ul>
<li>Waiting process is scheduled -&gt; Process holding lock might be</li>
<li>Spin or block depends on how long, t, before lock is released
<ul>
<li>Lock released quickly -&gt; Spin-wait</li>
<li>Lock released slowly -&gt; Block</li>
<li>Quick and slow are relative to context-switch cost, C</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="condition-variables"><a class="markdownIt-Anchor" href="#condition-variables"></a> Condition Variables</h2>
<h3 id="ordering"><a class="markdownIt-Anchor" href="#ordering"></a> Ordering</h3>
<ul>
<li>
<p>Idea: Thread A runs after Thread B does something</p>
</li>
<li>
<p>Example: Join</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> p1, p2; </span><br><span class="line">Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>); </span><br><span class="line">Pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>); </span><br><span class="line"><span class="comment">// join waits for the threads to finish </span></span><br><span class="line">Pthread_join(p1, <span class="literal">NULL</span>); </span><br><span class="line">Pthread_join(p2, <span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="condition-variables-2"><a class="markdownIt-Anchor" href="#condition-variables-2"></a> Condition Variables</h3>
<ul>
<li>
<p>Condition Variable: queue of waiting threads</p>
</li>
<li>
<p>B waits for a signal on CV before running: <code>wait(CV, …)</code></p>
</li>
<li>
<p>A sends signal to CV when time for B to run: <code>signal(CV, …)</code></p>
</li>
<li>
<p><code>wait(cond_t *cv, mutex_t *lock)</code></p>
<ul>
<li>assumes the lock is held when wait() is called</li>
<li>puts caller to sleep + releases the lock (atomically)</li>
<li>when awoken, reacquires lock before returning</li>
</ul>
</li>
<li>
<p><code>signal(cond_t *cv)</code></p>
<ul>
<li>wake a single waiting thread (if &gt;= 1 thread is waiting)</li>
<li>if there is no waiting thread, just return, doing nothing</li>
</ul>
</li>
</ul>
<h3 id="join-attempt-1-no-state"><a class="markdownIt-Anchor" href="#join-attempt-1-no-state"></a> Join Attempt 1: No State</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);     <span class="comment">// x </span></span><br><span class="line">   Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);   <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a </span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// b </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// c </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Intended schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td>x</td>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td>z</td>
</tr>
<tr>
<td>Child</td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>y</td>
</tr>
<tr>
<td>Child</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>Parent is stuck because nobody will call signal</li>
</ul>
</li>
<li>
<p>Rule of Thumb 1</p>
<ul>
<li>Keep state in addition to CV’s</li>
<li>CV’s are used to signal threads when state changes</li>
<li>If state is already as needed, thread doesn’t wait for a signal!</li>
</ul>
</li>
</ul>
<h3 id="join-attempt-2-no-mutex-lock"><a class="markdownIt-Anchor" href="#join-attempt-2-no-mutex-lock"></a> Join Attempt 2: No Mutex Lock</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="comment">// If the child process already finished executing</span></span><br><span class="line">   <span class="comment">// the parent process doesn't need to wait</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// a</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// b </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Intended schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td></td>
<td></td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
</tr>
<tr>
<td>Child</td>
<td>a</td>
<td>b</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td>w</td>
<td>x</td>
<td></td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>Child</td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>Parent is stuck again</li>
</ul>
</li>
</ul>
<h3 id="join-attempt-3-state-mutex-lock"><a class="markdownIt-Anchor" href="#join-attempt-3-state-mutex-lock"></a> Join Attempt 3: State + Mutex Lock</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a</span></span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// b</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// c </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parent</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td>z</td>
</tr>
<tr>
<td>Child</td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Rule of Thumb 2</p>
<ul>
<li>Hold mutex lock while calling wait/signal</li>
<li>Ensures no race between interacting with state and wait/signal</li>
</ul>
</li>
</ul>
<h3 id="producerconsumer-problem"><a class="markdownIt-Anchor" href="#producerconsumer-problem"></a> Producer/Consumer Problem</h3>
<ul>
<li>Example: UNIX pipes
<ul>
<li>
<p>A pipe may have many writers and readers</p>
</li>
<li>
<p>Internally, there is a finite-sized buffer</p>
</li>
<li>
<p>Writers add data to the buffer</p>
<ul>
<li>Writers have to wait if buffer is full</li>
</ul>
</li>
<li>
<p>Readers remove data from the buffer</p>
<ul>
<li>Readers have to wait if buffer is empty</li>
</ul>
</li>
<li>
<p>Implementation:</p>
<ul>
<li>reads/writes to buffer require locking</li>
<li>when buffers are full, writers must wait</li>
<li>when buffers are empty, readers must wait</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre>
               Start (consumer)
               |
     +---------v---------------------------+------+
Buf: |         |          data             |      |
     +---------+---------------------------^------+
                                           |
                                           End (producer)
</pre>
<ul>
<li>Producer/Consumer Problem
<ul>
<li>
<p>Producers generate data (like pipe writers)</p>
</li>
<li>
<p>Consumers grab data and process it (like pipe readers)</p>
</li>
<li>
<p>Producer/consumer problems are frequent in systems (e.g. web servers)</p>
</li>
<li>
<p>General strategy use condition variables to:</p>
<ul>
<li>make producers wait when buffers are full</li>
<li>make consumers wait when there is nothing to consume</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pc-attempt-1-one-cv"><a class="markdownIt-Anchor" href="#pc-attempt-1-one-cv"></a> P/C Attempt 1: One CV</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Producer grabs the lock</span></span><br><span class="line"><span class="comment">// 2. Check whether the buffer is full. If so, wait.</span></span><br><span class="line"><span class="comment">// 3. Put something to the buffer</span></span><br><span class="line"><span class="comment">// 4. Signal consumers to read</span></span><br><span class="line"><span class="comment">// 5. Release the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == max)      <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;cond, &amp;m);  <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;cond);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Consumer grabs the lock</span></span><br><span class="line"><span class="comment">// 2. Check whether the buffer is empty. If so, wait.</span></span><br><span class="line"><span class="comment">// 3. Get the content from buffer and remove it.</span></span><br><span class="line"><span class="comment">// 4. Signal consumers to write</span></span><br><span class="line"><span class="comment">// 5. Release the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == <span class="number">0</span>)       <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;cond, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;cond);     <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>p1</td>
<td>p2</td>
<td>p4</td>
<td>p5</td>
<td>p6</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C1</td>
<td>c1</td>
<td>c2</td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C2</td>
<td></td>
<td></td>
<td></td>
<td>c1</td>
<td>c2</td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>c5</td>
</tr>
</tbody>
</table>
<ul>
<li>At time 16, Consumer 1 could signal Consumer 2 to wake up</li>
</ul>
</li>
</ul>
<h3 id="pc-attempt-2-two-cvs"><a class="markdownIt-Anchor" href="#pc-attempt-2-two-cvs"></a> P/C Attempt 2: Two CVs</h3>
<ul>
<li>
<p>How to wake the right thread? Use two condition variables</p>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == max)      <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;empty, &amp;m); <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;fill);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == <span class="number">0</span>)       <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;fill, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;empty);    <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Broken schedule</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td></td>
<td></td>
<td></td>
<td>p1</td>
<td>p4</td>
<td>p5</td>
<td>p6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C1</td>
<td>c1</td>
<td>c2</td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c4</td>
</tr>
<tr>
<td>C2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c1</td>
<td>c4</td>
<td>c5</td>
<td>c6</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>At time 12, Consumer 1 wakes up but has nothing to read</li>
<li>Note: When <code>signal()</code> is called, the thread may not resume immediately</li>
</ul>
</li>
</ul>
<h3 id="pc-attempt-3-two-cvs-with-while"><a class="markdownIt-Anchor" href="#pc-attempt-3-two-cvs-with-while"></a> P/C Attempt 3: Two CVs with While</h3>
<ul>
<li>
<p>Idea: Recheck the shared variable is still in the state you want after waking up</p>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">while</span> (numfull == max)   <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;empty, &amp;m); <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;fill);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">while</span> (numfull == <span class="number">0</span>)    <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;fill, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;empty);    <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Rule of Thumb 3</p>
<ul>
<li>Whenever a lock is acquired, recheck assumptions about state!</li>
<li>Another thread could grab lock in between signal and wakeup from wait</li>
<li>Note that some libraries also have “spurious wakeups”</li>
<li>(may wake multiple waiting threads at signal or at any time)</li>
</ul>
</li>
</ul>
<h3 id="summary-2"><a class="markdownIt-Anchor" href="#summary-2"></a> Summary</h3>
<ul>
<li>
<p>Rules of Thumb for CVs</p>
<ol>
<li>Keep state in addition to CV’s</li>
<li>Always do wait/signal with lock held</li>
<li>Whenever thread wakes from waiting, recheck state</li>
</ol>
</li>
<li>
<p><code>wait(cond_t *cv, mutex_t *lock)</code></p>
<ul>
<li>assumes the lock is held when wait() is called</li>
<li>puts caller to sleep + releases the lock (atomically)</li>
<li>when awoken, reacquires lock before returning</li>
</ul>
</li>
<li>
<p><code>signal(cond_t *cv)</code></p>
<ul>
<li>wake a single waiting thread (if &gt;= 1 thread is waiting)</li>
<li>if there is no waiting thread, just return, doing nothing</li>
</ul>
</li>
</ul>
<h2 id="semaphores"><a class="markdownIt-Anchor" href="#semaphores"></a> Semaphores</h2>
<h3 id="introduction-2"><a class="markdownIt-Anchor" href="#introduction-2"></a> Introduction</h3>
<ul>
<li>
<p>Condition variables have no state (other than waiting queue)</p>
<ul>
<li>Programmer must track additional state</li>
</ul>
</li>
<li>
<p>Semaphores have state: track integer value</p>
<ul>
<li>State cannot be directly accessed by user program</li>
<li>But state determines behavior of semaphore operations</li>
</ul>
</li>
</ul>
<h3 id="semaphore-operations"><a class="markdownIt-Anchor" href="#semaphore-operations"></a> Semaphore Operations</h3>
<ul>
<li>
<p>Allocate and Initialize</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_init(<span class="keyword">sem_t</span> *s, <span class="keyword">int</span> initval) &#123;</span><br><span class="line">    s-&gt;value = initval; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>User cannot read or write value directly after initialization</li>
</ul>
</li>
<li>
<p>Wait or Test (sometime P() for Dutch) <code>sem_wait(sem_t*)</code></p>
<ul>
<li>Decrements sem value, Waits until value of sem is &gt;= 0</li>
</ul>
</li>
<li>
<p>Signal or Post (sometime V() for Dutch) <code>sem_post(sem_t*)</code></p>
<ul>
<li>Increment sem value, then wake a single waiter</li>
</ul>
</li>
</ul>
<h3 id="build-lock-from-semaphore"><a class="markdownIt-Anchor" href="#build-lock-from-semaphore"></a> Build Lock from Semaphore</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">sem_t</span> sem; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    sem_init(&amp;lock-&gt;sem, <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;lock-&gt;sem);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    sem_post(&amp;lock-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="join-with-cv-vs-semaphores"><a class="markdownIt-Anchor" href="#join-with-cv-vs-semaphores"></a> Join with CV vs Semaphores</h3>
<ul>
<li>
<p>Join with Condition Variable</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a</span></span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// b</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// c </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Join with Semaphores</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Join with Semaphores Example 1</p>
  <pre>
    s                       s                      s
  +---+   parent wait()   +---+   child post()   +---+
  | 0 |+----------------->| -1|+---------------->| 0 |
  +---+                   +---+                  +---+
                            ^                      ^
                            |                      |
                            Parent blocked         Parent resumes
  </pre>
</li>
<li>
<p>Join with Semaphores Example 2</p>
  <pre>
    s                       s                      s
  +---+   child post()    +---+  parent wait()   +---+
  | 0 |+----------------->| 1 |+---------------->| 0 |
  +---+                   +---+                  +---+
  </pre>
</li>
</ul>
<h3 id="pc-1-producer-1-consumer-with-buffer-of-size-1"><a class="markdownIt-Anchor" href="#pc-1-producer-1-consumer-with-buffer-of-size-1"></a> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size 1</h3>
<ul>
<li>
<p>Use 2 semaphores</p>
<ul>
<li>emptyBuffer: Initialize to 1</li>
<li>fullBuffer: Initialize to 0</li>
</ul>
</li>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer);</span><br><span class="line">    Fill(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer);</span><br><span class="line">    Use(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example 1: Producer comes first</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Current Thread</th>
<th>emptyBuffer</th>
<th>fullBuffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>Producer</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Consumer</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>Producer</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Example 2: Consumer comes first</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Current Thread</th>
<th>emptyBuffer</th>
<th>fullBuffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>Consumer</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>2</td>
<td>Producer</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>Consumer</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="pc-1-producer-1-consumer-with-buffer-of-size-n"><a class="markdownIt-Anchor" href="#pc-1-producer-1-consumer-with-buffer-of-size-n"></a> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size N</h3>
<ul>
<li>
<p>Use 2 semaphores</p>
<ul>
<li>emptyBuffer: Initialize to N</li>
<li>fullBuffer: Initialize to 0</li>
</ul>
</li>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer);</span><br><span class="line">    Fill(&amp;buffer[i]); </span><br><span class="line">    i = (i + <span class="number">1</span>) % N;</span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer);</span><br><span class="line">    Use(&amp;buffer[j]);</span><br><span class="line">    j = (j + <span class="number">1</span>) % N;</span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example 1: Producer comes first (N = 3)</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Curr</th>
<th>empty<br>Buffer</th>
<th>full<br>Buffer</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>3</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>P1</td>
<td>2</td>
<td>1</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>2</td>
<td>P2</td>
<td>1</td>
<td>2</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>3</td>
<td>P3</td>
<td>0</td>
<td>3</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>4</td>
<td>P4</td>
<td>-1</td>
<td>3</td>
<td>wait(emptyBuffer)</td>
</tr>
<tr>
<td>5</td>
<td>C1</td>
<td>0</td>
<td>2</td>
<td>wait(fullBuffer) + use + signal(emptyBuffer)</td>
</tr>
<tr>
<td>6</td>
<td>C2</td>
<td>1</td>
<td>1</td>
<td>wait(fullBuffer) + use + signal(emptyBuffer)</td>
</tr>
<tr>
<td>7</td>
<td>P4</td>
<td>0</td>
<td>2</td>
<td>fill + signal(fullBuffer)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Example 2: Two consumers come first (N = 3)</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Curr</th>
<th>empty<br>Buffer</th>
<th>full<br>Buffer</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>3</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>C1</td>
<td>3</td>
<td>-1</td>
<td>wait(fullBuffer)</td>
</tr>
<tr>
<td>2</td>
<td>C2</td>
<td>3</td>
<td>-2</td>
<td>wait(fullBuffe)</td>
</tr>
<tr>
<td>3</td>
<td>P</td>
<td>2</td>
<td>-1</td>
<td>wait(emptyBuffer) + fill + signal(fullBuffer)</td>
</tr>
<tr>
<td>4</td>
<td>C1</td>
<td>3</td>
<td>-1</td>
<td>use + signal(emptyBuffer)</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="pc-multiple-producers-consumers"><a class="markdownIt-Anchor" href="#pc-multiple-producers-consumers"></a> P/C: Multiple Producers &amp; Consumers</h3>
<ul>
<li>
<p>Requirements</p>
<ul>
<li>Each consumer must grab unique filled element</li>
<li>Each producer must grab unique empty element</li>
</ul>
</li>
<li>
<p>Attempt 1</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Problem: <code>findfull</code> and <code>findempty</code> are not thread-safe</p>
</li>
</ul>
</li>
<li>
<p>Attempt 2</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Problem</p>
<ul>
<li>Deadlock: Consumer grabs <code>mutex</code> and wait for <code>fullBuffer</code> for ever</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Attempt 3</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Problem</p>
<ul>
<li>Cannot operate on multiple buffer locations at the same time</li>
<li>Only 1 thread at at time can be using of filling different buffers</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Attempt 4</p>
<ul>
<li>
<p>Producer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Advantage</p>
<ul>
<li>Works and increases concurrency; only finding a buffer is protected by mutex;</li>
<li>Filling or Using different buffers can proceed concurrently</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="readerwriter-locks"><a class="markdownIt-Anchor" href="#readerwriter-locks"></a> Reader/Writer Locks</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Let multiple reader threads grab lock (shared)</li>
<li>Only one writer thread can grab lock (exclusive)
<ul>
<li>No reader threads</li>
<li>No other writer threads</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct_rwlock_t</span> &#123;</span><br><span class="line">    <span class="keyword">sem_t</span> lock; <span class="comment">// reader lock</span></span><br><span class="line">    <span class="keyword">sem_t</span> writelock;</span><br><span class="line">    <span class="keyword">int</span> readers; <span class="comment">// number of readers</span></span><br><span class="line">&#125; <span class="keyword">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_init</span><span class="params">(<span class="keyword">rwlock_t</span>*rw)</span> </span>&#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// initialize locks to 1, similar to mutex initialization</span></span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">1</span>);  </span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123; </span><br><span class="line">    sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">    rw-&gt;readers++; </span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>) </span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">    sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123; </span><br><span class="line">    sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">    rw-&gt;readers--; </span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>) </span><br><span class="line">        sem_post(&amp;rw-&gt;writelock); <span class="comment">// let other writes</span></span><br><span class="line">    sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Example</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Current Action</th>
<th>lock</th>
<th>writelock</th>
<th>readers</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td></td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>T1 <code>acquire_readlock</code></td>
<td><del>0</del> 1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>T2 <code>acquire_readlock</code></td>
<td><del>0</del> 1</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>T3 <code>acquire_writelock</code></td>
<td>1</td>
<td>-1</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>T1 <code>release_readlock</code></td>
<td><del>0</del> 1</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>T2 <code>release_readlock</code></td>
<td><del>0</del> 1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Quiz 1</p>
<ul>
<li>T1: <code>acquire_readlock()</code> =&gt; T1 running</li>
<li>T2: <code>acquire_readlock()</code> =&gt; T2 running</li>
<li>T3: <code>acquire_writelock()</code> =&gt; T3 blocked, waiting for write lock</li>
</ul>
</li>
<li>
<p>Quiz 2</p>
<ul>
<li>T6: <code>acquire_writelock()</code> =&gt; T6 running</li>
<li>T4: <code>acquire_readlock()</code> =&gt; T4 blocked, waiting for read lock</li>
<li>T5: <code>acquire_readlock()</code> =&gt; T5 blocked, waiting for read lock</li>
</ul>
</li>
</ul>
<h3 id="build-zemaphore-from-lock-and-cv"><a class="markdownIt-Anchor" href="#build-zemaphore-from-lock-and-cv"></a> Build Zemaphore from Lock and CV</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">cond_t</span> cond; </span><br><span class="line">    <span class="keyword">lock_t</span> lock; </span><br><span class="line">&#125; <span class="keyword">zem_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_init</span><span class="params">(<span class="keyword">zem_t</span> *z, <span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">    z-&gt;value = value; </span><br><span class="line">    cond_init(&amp;z-&gt;cond); </span><br><span class="line">    lock_init(&amp;z-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// waits until value &gt; 0. and decrement</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_wait</span><span class="params">(<span class="keyword">zem_t</span> *z)</span> </span>&#123; </span><br><span class="line">    lock_acquire(&amp;z-&gt;lock); </span><br><span class="line">    z-&gt;value--; </span><br><span class="line">    <span class="keyword">while</span> (z-&gt;value &lt; <span class="number">0</span>) </span><br><span class="line">       cond_wait(&amp;z-&gt;cond); </span><br><span class="line">    lock_release(&amp;z-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// increment value, then wake a single waiter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_post</span><span class="params">(<span class="keyword">zem_t</span> *z)</span> </span>&#123; </span><br><span class="line">    lock_acquire(&amp;z-&gt;lock); </span><br><span class="line">    z-&gt;value++; </span><br><span class="line">    cond_signal(&amp;z-&gt;cond); </span><br><span class="line">    lock_release(&amp;z-&gt;lock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="summary-3"><a class="markdownIt-Anchor" href="#summary-3"></a> Summary</h3>
<ul>
<li>
<p>Semaphores are equivalent to locks + condition variables</p>
<ul>
<li>Can be used for both mutual exclusion and ordering</li>
</ul>
</li>
<li>
<p>Semaphores contain state</p>
<ul>
<li>How they are initialized depends on how they will be used</li>
<li>Init to 0: Join (1 thread must arrive first, then other)</li>
<li>Init to N: Number of available resources</li>
</ul>
</li>
<li>
<p>sem_wait(): Decrement and waits until value &gt;= 0</p>
</li>
<li>
<p>sem_post(): Increment value, then wake a single waiter (atomic)</p>
</li>
<li>
<p>Can use semaphores in producer/consumer and for reader/writer locks</p>
</li>
</ul>
<h2 id="concurrency-bugs"><a class="markdownIt-Anchor" href="#concurrency-bugs"></a> Concurrency Bugs</h2>
<h3 id="concurrency-in-medicine-therac-25-1980s"><a class="markdownIt-Anchor" href="#concurrency-in-medicine-therac-25-1980s"></a> Concurrency in Medicine: Therac-25 (1980’s)</h3>
<blockquote>
<p>“The accidents occurred when the high-power electron beam was activated<br>
instead of the intended low power beam, and without the beam spreader plate<br>
rotated into place. Previous models had hardware interlocks in place to prevent<br>
this, but Therac-25 had removed them, depending instead on software interlocks<br>
for safety. The software interlock could fail due to a race condition.”</p>
</blockquote>
<blockquote>
<p>“…in three cases, the injured patients later died.”</p>
</blockquote>
<ul>
<li>Source: <a href="http://en.wikipedia.org/wiki/Therac-25" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Therac-25</a></li>
</ul>
<h3 id="concurrency-study"><a class="markdownIt-Anchor" href="#concurrency-study"></a> Concurrency Study</h3>
<p><img src="https://i.imgur.com/77XWz8c.png" alt=""></p>
<h3 id="atomicity-mysql"><a class="markdownIt-Anchor" href="#atomicity-mysql"></a> Atomicity: MySQL</h3>
<ul>
<li>
<p>Bug</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="built_in">fputs</span>(thd-&gt;proc_info, <span class="comment">/*...*/</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Fix</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="built_in">fputs</span>(thd-&gt;proc_info, <span class="comment">/*...*/</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ordering-mozilla"><a class="markdownIt-Anchor" href="#ordering-mozilla"></a> Ordering: Mozilla</h3>
<ul>
<li>
<p>Bug</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, <span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">(<span class="comment">/*...*/</span>)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Fix</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, <span class="comment">/*...*/</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    mtInit = <span class="number">1</span>; </span><br><span class="line">    pthread_cond_signal(&amp;mtCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">(<span class="comment">/*...*/</span>)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    <span class="keyword">while</span> (mtInit == <span class="number">0</span>) </span><br><span class="line">        pthread_cond_wait(&amp;mtCond, &amp;mtLock);  </span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);  </span><br><span class="line">    </span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="deadlock"><a class="markdownIt-Anchor" href="#deadlock"></a> Deadlock</h2>
<h3 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h3>
<ul>
<li>No progress can be made because two or more threads are waiting for the other to take some action and thus neither ever does</li>
</ul>
<h3 id="example-1-circular-dependency"><a class="markdownIt-Anchor" href="#example-1-circular-dependency"></a> Example 1: Circular Dependency</h3>
<ul>
<li>
<p>Code</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lock(&amp;A);</code> <br><br><br> <code>lock(&amp;B);</code>(blocked)</td>
<td><br><code>lock(&amp;B);</code>  <br> <code>lock(&amp;A);</code>(blocked)<br><br></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Circular Dependency<br>
<img src="https://i.imgur.com/dG4Krbd.png" alt=""></p>
<ul>
<li>Cycle in dependency graph -&gt; possible to have deadlock</li>
</ul>
</li>
<li>
<p>Fix Deadlock Code</p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lock(&amp;A);</code> <br><code>lock(&amp;B);</code></td>
<td><code>lock(&amp;A);</code>  <br> <code>lock(&amp;A);</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Non-Circular Dependency<br>
<img src="https://i.imgur.com/yJibQZG.png" alt=""></p>
</li>
</ul>
<h3 id="example-2-encapsulation"><a class="markdownIt-Anchor" href="#example-2-encapsulation"></a> Example 2: Encapsulation</h3>
<ul>
<li>Code</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_t</span> *set_intersection(<span class="keyword">set_t</span> *s1, <span class="keyword">set_t</span> *s2) &#123;</span><br><span class="line">   <span class="keyword">set_t</span> *rv = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*rv));</span><br><span class="line">   mutex_lock(&amp;s1-&gt;lock);</span><br><span class="line">   mutex_lock(&amp;s2-&gt;lock);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1-&gt;len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set_contains(s2, s1-&gt;items[i])) &#123;</span><br><span class="line">         set_add(rv, s1-&gt;items[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   mutex_unlock(&amp;s2-&gt;lock);</span><br><span class="line">   mutex_unlock(&amp;s1-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Deadlock scenario</p>
<ul>
<li>Thread 1: <code>rv = set_intersection(setA, setB);</code></li>
<li>Thread 2: <code>rv = set_intersection(setB, setA);</code></li>
</ul>
</li>
<li>
<p>Encapsulation</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m1 &gt; m2) &#123;</span><br><span class="line">  <span class="comment">// grab locks in high-to-low address order</span></span><br><span class="line">  pthread_mutex_lock(m1);</span><br><span class="line">  pthread_mutex_lock(m2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pthread_mutex_lock(m2);</span><br><span class="line">  pthread_mutex_lock(m1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Problem: Deadlock happens when <code>m1 == m2</code></li>
</ul>
</li>
</ul>
<h3 id="deadlock-theory"><a class="markdownIt-Anchor" href="#deadlock-theory"></a> Deadlock Theory</h3>
<ul>
<li>
<p>Deadlocks can only happen with these four conditions:</p>
<ol>
<li>mutual exclusion</li>
<li>hold-and-wait</li>
<li>no preemption</li>
<li>circular wait</li>
</ol>
</li>
<li>
<p>Can eliminate deadlock by eliminating any one condition</p>
</li>
</ul>
<h3 id="1-mutual-exclusion"><a class="markdownIt-Anchor" href="#1-mutual-exclusion"></a> 1. Mutual Exclusion</h3>
<ul>
<li>
<p>Problem: Threads claim exclusive control of resources that they require</p>
</li>
<li>
<p>Strategy: Eliminate locks! Replace locks with atomic primitive</p>
</li>
<li>
<p>Lock-free <code>add</code></p>
<ul>
<li>
<p>Implement <code>add</code> using lock</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *val, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  Mutex_lock(&amp;m);</span><br><span class="line">  *val += amt;</span><br><span class="line">  Mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Atomic primitive <code>CompareAndSwap</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *address, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*address == expected) &#123;</span><br><span class="line">    *address = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// success</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implement <code>add</code> without lock</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *val, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> old = *value;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!CompareAndSwap(val, old, old + amt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Wait-free Linked List Insert</p>
<ul>
<li>
<p>Implement <code>insert</code> using lock</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*n));</span><br><span class="line">  n-&gt;val = val;</span><br><span class="line">  lock(&amp;m);</span><br><span class="line">  n-&gt;next = head;</span><br><span class="line">  head = n;</span><br><span class="line">  unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Implement <code>insert</code> using while loop</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *n = Malloc(<span class="keyword">sizeof</span>(*n));</span><br><span class="line">  n-&gt;val = val;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!CompareAndSwap(&amp;head, n-&gt;next, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-hold-and-wait"><a class="markdownIt-Anchor" href="#2-hold-and-wait"></a> 2. Hold and Wait</h3>
<ul>
<li>
<p>Problem: Threads hold resources allocated to them while waiting for additional resources</p>
</li>
<li>
<p>Strategy: Acquire all locks atomically once. Can release locks over time, but cannot acquire again until all have been released</p>
</li>
<li>
<p>How to do this? Use a meta lock:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock(&amp;meta);</span><br><span class="line">lock(&amp;L1); <span class="comment">/*...*/</span> lock(&amp;L10);</span><br><span class="line">unlock(&amp;L10); <span class="comment">/*...*/</span> unlock(&amp;L1);</span><br><span class="line">unlock(&amp;meta);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Locks are not fine-grained</li>
</ul>
</li>
</ul>
<h3 id="3-no-preemption"><a class="markdownIt-Anchor" href="#3-no-preemption"></a> 3. No Preemption</h3>
<ul>
<li>
<p>Problem: Resources (e.g., locks) cannot be forcibly removed from threads that are</p>
</li>
<li>
<p>Strategy: if thread can’t get what it wants, release what it holds</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top: </span><br><span class="line">lock(A);</span><br><span class="line"><span class="keyword">if</span> (trylock(B) == <span class="number">-1</span>) &#123; <span class="comment">// try to lock B</span></span><br><span class="line">  unlock(A); <span class="comment">// if failed, also unlock A</span></span><br><span class="line">  <span class="keyword">goto</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Live lock: A situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work</li>
</ul>
</li>
</ul>
<h3 id="circular-wait"><a class="markdownIt-Anchor" href="#circular-wait"></a> Circular Wait</h3>
<ul>
<li>
<p>Circular chain of threads such that each thread holds a resource (e.g., lock)<br>
being requested by next thread in the chain.</p>
</li>
<li>
<p>Strategy:</p>
<ul>
<li>decide which locks should be acquired before others</li>
<li>if A before B, never acquire A if B is already held!</li>
<li>document this, and write code accordingly</li>
</ul>
</li>
<li>
<p>Works well if system has distinct layers</p>
</li>
</ul>
<h2 id="concurrent-data-structures"><a class="markdownIt-Anchor" href="#concurrent-data-structures"></a> Concurrent Data Structures</h2>
<h3 id="scalability-measure"><a class="markdownIt-Anchor" href="#scalability-measure"></a> Scalability Measure</h3>
<ul>
<li>
<p>N times as much work on N cores as done on 1 core.</p>
</li>
<li>
<p>Strong scalability</p>
<ul>
<li>
<p>Fix input size, increase number of cores, can have better performance</p>
</li>
<li>
<p>e.g. Matrix multiplication: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>B</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{m\times n}\times B_{n\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mbin mtight">×</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">×</span><span class="mord mathit mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span></span></span></span> requires <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mnd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mclose">)</span></span></span></span> FLOPS (floating point operations per second)</p>
</li>
</ul>
  <pre>
 Time 
   ^
   |
   |     **
   |     **
   |     **
   |     **
   |     **     **
   |     **     **
   |     **     **     **
   |     **     **     **     **
   +-----++-----++-----++-----++----> Number of Cores
   0     1      2      3      4
</pre></li>
</ul>

<ul>
<li>
<p>Weak scaling:</p>
<ul>
<li>
<p>Increase input size with number of cores</p>
</li>
<li>
<p>e.g. Matrix multiplication</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>FLOPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 core</td>
<td>100 × 100</td>
<td>100 × 100</td>
<td>10<sup>6</sup></td>
</tr>
<tr>
<td>2 core</td>
<td>100 × 200</td>
<td>200 × 100</td>
<td>2×10<sup>6</sup></td>
</tr>
<tr>
<td>3 core</td>
<td>100 × 300</td>
<td>300 × 100</td>
<td>2×10<sup>6</sup></td>
</tr>
<tr>
<td>4 core</td>
<td>100 × 400</td>
<td>400 × 100</td>
<td>4×10<sup>6</sup></td>
</tr>
</tbody>
</table>
  <pre>
 Time 
   ^
   |
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   |     **     **     **     **
   +-----++-----++-----++-----++----> Number of Cores
   0     1      2      3      4
  </pre>
</li>
</ul>
<h3 id="counter"><a class="markdownIt-Anchor" href="#counter"></a> Counter</h3>
<ul>
<li>
<p>Non-thread-safe Counter</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Problem: Two threads calls <code>increment</code> at the same time</li>
</ul>
</li>
<li>
<p>Thread-safe counter</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Linearizability</p>
<ul>
<li>
<p>Even if two threads execute in parallel on multiple cores, the effect that you see should be as if all of them are executed in some linear order.</p>
</li>
<li>
<p>Example: T1 and T2 call <code>increment</code> first, then T3 calls <code>get</code>.</p>
</li>
<li>
<p>Since T3 arrived after T1 and T2, we would want T3 to see the values after T1 and T2 have finished executing as if these were three instructions executed by a single processor</p>
</li>
</ul>
</li>
<li>
<p>The Underlying Problem</p>
<ul>
<li>Ticket lock</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> current_ticket; <span class="comment">// turn</span></span><br><span class="line">    <span class="keyword">int</span> next_ticket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    t = atomic_inc(lock-&gt;next_ticket)</span><br><span class="line">    <span class="keyword">while</span> (t != lock-&gt;current_ticket); <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;current_ticket++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>If one of the thread holds the lock,  all of the other threads need to check the lock</li>
<li>So each lock acquisition becomes more and more expensive as you go from like two to four to eight…</li>
</ul>
</li>
</ul>
<h3 id="approximate-counter-sloppy-counter"><a class="markdownIt-Anchor" href="#approximate-counter-sloppy-counter"></a> Approximate Counter (Sloppy Counter)</h3>
<ul>
<li>
<p>Motivation</p>
<ul>
<li>with standard thread-safe counter (strongest possible consistency) performance is poor under multithreads. Scalability is poor.</li>
<li>Cross-core messages are expensive under multicore system (Conclusion from “An analysis of Linux Scalability to Many Cores - Boyd-Wickizer et. al OSDI 2010, in the article they use 48core machine to benchmark linux”). This is because ticket lock in linux: if one of the core holds the lock all other cores need to check with this core holdiing the lock what is the next turn value going to be. We want to reduce the number of cross-core messages, which is very expensive under this situation. One way is to relax consistency.</li>
</ul>
</li>
<li>
<p>Idea</p>
<ul>
<li>Maintain a counter per-core and a global counter</li>
<li>Global counter lock</li>
<li>Per-core locks if more than 1 thread per-core</li>
</ul>
</li>
<li>
<p>Increment:</p>
<ul>
<li>update local counters at threshold update global</li>
</ul>
</li>
<li>
<p>Read:</p>
<ul>
<li>global counter (maybe inaccurate?)</li>
</ul>
</li>
<li>
<p>Code</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> global;                      <span class="comment">// global count</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> glock;           <span class="comment">// global lock</span></span><br><span class="line">  <span class="keyword">int</span> local[NUMCPUS];              <span class="comment">// local count (per cpu)</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> llock[NUMCPUS];  <span class="comment">// ... and locks</span></span><br><span class="line">  <span class="keyword">int</span> threshold;                   <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init: record threshold, init locks, init values of all local counts and</span></span><br><span class="line"><span class="comment">// global count</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span>* c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">  c-&gt;threshold = threshold;</span><br><span class="line">  c-&gt;global = <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">    c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usually, just grab local lock and update local amount once local</span></span><br><span class="line"><span class="comment">// count has risen by ’threshold’, grab global lock and transfer local values to it</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span>* c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">  c-&gt;local[threadID] += amt;                 <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123;  <span class="comment">// transfer to global</span></span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get: just return global amount (which may not be perfect)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span>* c)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">  <span class="keyword">int</span> val = c-&gt;global;</span><br><span class="line">  pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">  <span class="keyword">return</span> val;  <span class="comment">// only approximate!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="concurrent-linked-list"><a class="markdownIt-Anchor" href="#concurrent-linked-list"></a> Concurrent Linked List</h3>
<ul>
<li>
<p>First Attempt</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//  fail</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">  <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">  L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">//  success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Better Implementation (Shorter Critical Section)</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//  fail</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">  <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">  L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">//  success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="hash-table-from-list"><a class="markdownIt-Anchor" href="#hash-table-from-list"></a> Hash Table from List</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>Avoid contention by using different locks in each buckets — more fine-grained locks &amp; reduce cross threads contentions, leads to better scalling under multithreads performane</li>
</ul>
</li>
<li>
<p>Code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">  <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="concurrent-queue"><a class="markdownIt-Anchor" href="#concurrent-queue"></a> Concurrent Queue</h3>
<ul>
<li>Idea: use 2 locks to ensure that threads can enqueue/dequeue without conflicting with each other</li>
<li>One more thing to check in the following implementation: when there is only 1 elment – head and tail points to the same thing in queue, grab both locks</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Enqueue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">  tmp-&gt;value = value;</span><br><span class="line">  tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;q-&gt;tailLock);</span><br><span class="line">  q-&gt;tail-&gt;next = tmp;</span><br><span class="line">  q-&gt;tail = tmp;</span><br><span class="line">  pthread_mutex_unlock(&amp;q-&gt;tailLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Dequeue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;q-&gt;headLock);</span><br><span class="line">  <span class="keyword">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">  <span class="keyword">node_t</span> *newHead = tmp-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// queue was empty</span></span><br><span class="line">  &#125;</span><br><span class="line">  *value = newHead-&gt;value;</span><br><span class="line">  q-&gt;head = newHead;</span><br><span class="line">  pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="summary-4"><a class="markdownIt-Anchor" href="#summary-4"></a> Summary</h3>
<ul>
<li>
<p>Simple approach: Add a lock to each method’s start and end!  example: java keyword synchronized<br>
public synchronized get(){} This kind of synchronoized keyword is very standard in high level language but this may reduce performance under multicore scalablility</p>
</li>
<li>
<p>Check for scalability – weak scaling, strong scaling</p>
</li>
<li>
<p>If you are not happy with scalability properties, try to optimize by: Avoid cross-thread, cross-core traffic, using methods such as</p>
<ul>
<li>Per-core(sloppy) counter, relax consistency</li>
<li>Buckets in hashtable, reduce cross threads contention, more fine grained locks</li>
<li>keep critical section small</li>
<li>not using locks is faster than using locks</li>
</ul>
</li>
</ul>

	
    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://th2zz.github.io">th2zz</a>
            <p>原文链接：<a href="http://th2zz.github.io/2019/04/03/Operating System - Concurrency/">http://th2zz.github.io/2019/04/03/Operating System - Concurrency/</a>
            <p>发表日期：<a href="http://th2zz.github.io/2019/04/03/Operating System - Concurrency/">April 3rd 2019, 9:06:41 am</a>
            <p>更新日期：<a href="http://th2zz.github.io/2019/04/03/Operating System - Concurrency/">April 11th 2019, 10:01:38 am</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2019/04/09/Computer Networking/" title= "Computer Networking">
                    <div class="nextTitle">Computer Networking</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/03/25/Boyer–Moore majority vote algorithm/" title= "Boyer–Moore majority vote algorithm">
                    <div class="prevTitle">Boyer–Moore majority vote algorithm</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid="MTAyMC80MzMwMy8xOTg0NA==">
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->

    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>

            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:tzhang329@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/th2zz" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/qr.png" />
                </span>
            
        
    
        
            
                <span class="iconfont-archer qq" title=qq>
                  
                  <img class="profile-qr" src="/assets/qrqq.jpg" />
                </span>
            
        
    
        
    
        
    
        
            
                <a href="https://www.zhihu.com/people/vince-zzz/" class="iconfont-archer zhihu" target="_blank" title=zhihu></a>
            
        
    
        
            
                <a href="https://www.douban.com/people/55328071/" class="iconfont-archer douban" target="_blank" title=douban></a>
            
        
    
        
    
        
    
        
            
                <a href="https://www.instagram.com/th2zz3/" class="iconfont-archer instagram" target="_blank" title=instagram></a>
            
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://space.bilibili.com/38725165" class="iconfont-archer bilibili" target="_blank" title=bilibili></a>
            
        
    
        
    
        
            
                <a href="https://steamcommunity.com/id/th2zz/" class="iconfont-archer steam" target="_blank" title=steam></a>
            
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cs537-operating-system-summary-part-2-concurrency"><span class="toc-number">1.</span> <span class="toc-text"> CS537 - Operating System Summary Part 2 Concurrency</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#concurrency"><span class="toc-number">2.</span> <span class="toc-text"> Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread"><span class="toc-number">2.1.</span> <span class="toc-text"> Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#processes-vs-thread"><span class="toc-number">2.1.1.</span> <span class="toc-text"> Processes vs Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#common-programming-models"><span class="toc-number">2.1.2.</span> <span class="toc-text"> Common Programming Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#user-level-threads-many-to-one"><span class="toc-number">2.1.3.</span> <span class="toc-text"> User-level threads: Many-to-one</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel-level-threads-one-to-one"><span class="toc-number">2.1.4.</span> <span class="toc-text"> Kernel-level threads: One-to-one</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-schedule-examples"><span class="toc-number">2.1.5.</span> <span class="toc-text"> Thread Schedule Examples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-determinism"><span class="toc-number">2.1.6.</span> <span class="toc-text"> Non-Determinism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#what-do-we-want"><span class="toc-number">2.1.7.</span> <span class="toc-text"> What do we want?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronization"><span class="toc-number">2.1.8.</span> <span class="toc-text"> Synchronization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrency-objective"><span class="toc-number">2.1.9.</span> <span class="toc-text"> Concurrency Objective</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#summary"><span class="toc-number">2.1.10.</span> <span class="toc-text"> Summary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locks"><span class="toc-number">2.2.</span> <span class="toc-text"> Locks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#introduction"><span class="toc-number">2.2.1.</span> <span class="toc-text"> Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-lock-with-load-store"><span class="toc-number">2.2.2.</span> <span class="toc-text"> Spin Lock with Load + Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-lock-with-xchg"><span class="toc-number">2.2.3.</span> <span class="toc-text"> Spin Lock with xchg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spin-lock-with-cas"><span class="toc-number">2.2.4.</span> <span class="toc-text"> Spin Lock with CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ticket-locks"><span class="toc-number">2.2.5.</span> <span class="toc-text"> Ticket Locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ticket-lock-with-yield"><span class="toc-number">2.2.6.</span> <span class="toc-text"> Ticket Lock with Yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue-lock"><span class="toc-number">2.2.7.</span> <span class="toc-text"> Queue Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue-lock-vs-spin-lock"><span class="toc-number">2.2.8.</span> <span class="toc-text"> Queue Lock vs Spin Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#condition-variables"><span class="toc-number">2.3.</span> <span class="toc-text"> Condition Variables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ordering"><span class="toc-number">2.3.1.</span> <span class="toc-text"> Ordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-variables-2"><span class="toc-number">2.3.2.</span> <span class="toc-text"> Condition Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-attempt-1-no-state"><span class="toc-number">2.3.3.</span> <span class="toc-text"> Join Attempt 1: No State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-attempt-2-no-mutex-lock"><span class="toc-number">2.3.4.</span> <span class="toc-text"> Join Attempt 2: No Mutex Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-attempt-3-state-mutex-lock"><span class="toc-number">2.3.5.</span> <span class="toc-text"> Join Attempt 3: State + Mutex Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#producerconsumer-problem"><span class="toc-number">2.3.6.</span> <span class="toc-text"> Producer/Consumer Problem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-attempt-1-one-cv"><span class="toc-number">2.3.7.</span> <span class="toc-text"> P/C Attempt 1: One CV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-attempt-2-two-cvs"><span class="toc-number">2.3.8.</span> <span class="toc-text"> P/C Attempt 2: Two CVs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-attempt-3-two-cvs-with-while"><span class="toc-number">2.3.9.</span> <span class="toc-text"> P/C Attempt 3: Two CVs with While</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#summary-2"><span class="toc-number">2.3.10.</span> <span class="toc-text"> Summary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphores"><span class="toc-number">2.4.</span> <span class="toc-text"> Semaphores</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#introduction-2"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore-operations"><span class="toc-number">2.4.2.</span> <span class="toc-text"> Semaphore Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-lock-from-semaphore"><span class="toc-number">2.4.3.</span> <span class="toc-text"> Build Lock from Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-with-cv-vs-semaphores"><span class="toc-number">2.4.4.</span> <span class="toc-text"> Join with CV vs Semaphores</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-1-producer-1-consumer-with-buffer-of-size-1"><span class="toc-number">2.4.5.</span> <span class="toc-text"> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-1-producer-1-consumer-with-buffer-of-size-n"><span class="toc-number">2.4.6.</span> <span class="toc-text"> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size N</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc-multiple-producers-consumers"><span class="toc-number">2.4.7.</span> <span class="toc-text"> P/C: Multiple Producers &amp; Consumers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readerwriter-locks"><span class="toc-number">2.4.8.</span> <span class="toc-text"> Reader/Writer Locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-zemaphore-from-lock-and-cv"><span class="toc-number">2.4.9.</span> <span class="toc-text"> Build Zemaphore from Lock and CV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#summary-3"><span class="toc-number">2.4.10.</span> <span class="toc-text"> Summary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrency-bugs"><span class="toc-number">2.5.</span> <span class="toc-text"> Concurrency Bugs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrency-in-medicine-therac-25-1980s"><span class="toc-number">2.5.1.</span> <span class="toc-text"> Concurrency in Medicine: Therac-25 (1980’s)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrency-study"><span class="toc-number">2.5.2.</span> <span class="toc-text"> Concurrency Study</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomicity-mysql"><span class="toc-number">2.5.3.</span> <span class="toc-text"> Atomicity: MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ordering-mozilla"><span class="toc-number">2.5.4.</span> <span class="toc-text"> Ordering: Mozilla</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deadlock"><span class="toc-number">2.6.</span> <span class="toc-text"> Deadlock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#definition"><span class="toc-number">2.6.1.</span> <span class="toc-text"> Definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#example-1-circular-dependency"><span class="toc-number">2.6.2.</span> <span class="toc-text"> Example 1: Circular Dependency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#example-2-encapsulation"><span class="toc-number">2.6.3.</span> <span class="toc-text"> Example 2: Encapsulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deadlock-theory"><span class="toc-number">2.6.4.</span> <span class="toc-text"> Deadlock Theory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mutual-exclusion"><span class="toc-number">2.6.5.</span> <span class="toc-text"> 1. Mutual Exclusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-hold-and-wait"><span class="toc-number">2.6.6.</span> <span class="toc-text"> 2. Hold and Wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-no-preemption"><span class="toc-number">2.6.7.</span> <span class="toc-text"> 3. No Preemption</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#circular-wait"><span class="toc-number">2.6.8.</span> <span class="toc-text"> Circular Wait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrent-data-structures"><span class="toc-number">2.7.</span> <span class="toc-text"> Concurrent Data Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scalability-measure"><span class="toc-number">2.7.1.</span> <span class="toc-text"> Scalability Measure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#counter"><span class="toc-number">2.7.2.</span> <span class="toc-text"> Counter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#approximate-counter-sloppy-counter"><span class="toc-number">2.7.3.</span> <span class="toc-text"> Approximate Counter (Sloppy Counter)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrent-linked-list"><span class="toc-number">2.7.4.</span> <span class="toc-text"> Concurrent Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-table-from-list"><span class="toc-number">2.7.5.</span> <span class="toc-text"> Hash Table from List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrent-queue"><span class="toc-number">2.7.6.</span> <span class="toc-text"> Concurrent Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#summary-4"><span class="toc-number">2.7.7.</span> <span class="toc-text"> Summary</span></a></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 22
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span><a class="archive-post-title" href= "/2019/10/01/java-jvm/" >JVM</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/21</span><a class="archive-post-title" href= "/2019/04/22/Database Management System - Indexing/" >Database Management System - Indexing</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2019/04/11/Operating System - Persistence/" >Operating System - Persistence</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2019/04/09/Computer Networking/" >Computer Networking</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2019/04/03/Operating System - Concurrency/" >Operating System - Concurrency</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/24</span><a class="archive-post-title" href= "/2019/03/25/Boyer–Moore majority vote algorithm/" >Boyer–Moore majority vote algorithm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/22</span><a class="archive-post-title" href= "/2019/03/23/Threaded Binary Tree and Morris Traversal/" >Threaded Binary Tree and Morris Traversal</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2019/03/19/Database/" >Database Management System - Relational Design Theory</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span><a class="archive-post-title" href= "/2019/03/16/Operating System - Virtualization/" >Operating System - Virtualization</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/10</span><a class="archive-post-title" href= "/2019/02/11/process control/" >Process Control</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/24</span><a class="archive-post-title" href= "/2018/12/25/TCS/" >Automata, language, and computational complexity</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span><a class="archive-post-title" href= "/2018/12/10/real-analysis/" >real analysis</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span><a class="archive-post-title" href= "/2018/12/09/Compiler/" >Programming language and Compiler</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/01</span><a class="archive-post-title" href= "/2018/12/02/probability/" >Math431-probability theory</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span><a class="archive-post-title" href= "/2018/05/22/Digital-system-fundamental/" >Digital system fundamental</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2018/05/20/ai/" >CS540 Intro to AI Notesheet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2018/05/06/algorithm/" >CS577 Algorithm Notesheet</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href= "/2017/12/12/Linear-algebra/" >Linear algebra</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span><a class="archive-post-title" href= "/2017/09/30/chmod/" >chmod</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/21</span><a class="archive-post-title" href= "/2017/09/22/link/" >link</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span><a class="archive-post-title" href= "/2017/08/30/chown/" >chown</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span><a class="archive-post-title" href= "/2017/08/13/hello-world/" >Hello world</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Algorithm and Data Structures"><span class="iconfont-archer">&#xe606;</span>Algorithm and Data Structures</span>
    
        <span class="sidebar-tag-name" data-tags="Compiler"><span class="iconfont-archer">&#xe606;</span>Compiler</span>
    
        <span class="sidebar-tag-name" data-tags="Computer Network"><span class="iconfont-archer">&#xe606;</span>Computer Network</span>
    
        <span class="sidebar-tag-name" data-tags="Database"><span class="iconfont-archer">&#xe606;</span>Database</span>
    
        <span class="sidebar-tag-name" data-tags="Computer Science"><span class="iconfont-archer">&#xe606;</span>Computer Science</span>
    
        <span class="sidebar-tag-name" data-tags="Math"><span class="iconfont-archer">&#xe606;</span>Math</span>
    
        <span class="sidebar-tag-name" data-tags="OS"><span class="iconfont-archer">&#xe606;</span>OS</span>
    
        <span class="sidebar-tag-name" data-tags="Theory of computation"><span class="iconfont-archer">&#xe606;</span>Theory of computation</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "th2zz"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    <div style="display: none">
        <script src="https://s13.cnzz.com/z_stat.php?id=true&web_id=true" language="JavaScript"></script>
        
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->    
     
    </body>
</html>


