<!DOCTYPE html>
<html lang="en">

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Database Concurrency Summary |  th2zz
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/assets/torr3.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

</head>

</html>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-database_concurrency" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Database Concurrency Summary
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/01/database_concurrency/" class="article-date">
  <time datetime="2019-10-01T08:35:04.000Z" itemprop="datePublished">2019-10-01</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.6k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">20分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="数据库并发控制"><a class="markdownIt-Anchor" href="#数据库并发控制"></a> 数据库并发控制</h1>
<h1 id="concurrency-control"><a class="markdownIt-Anchor" href="#concurrency-control"></a> Concurrency control</h1>
<h2 id="acid-principle-for-transaction-management"><a class="markdownIt-Anchor" href="#acid-principle-for-transaction-management"></a> ACID principle for transaction management</h2>
<h3 id="atomicity-原子性-all-or-none"><a class="markdownIt-Anchor" href="#atomicity-原子性-all-or-none"></a> Atomicity 原子性 “all or none”</h3>
<p>事务所做操作要么全部提交要么全部失败回滚</p>
<ul>
<li>实现： 日志,   Shadow paging</li>
</ul>
<h3 id="consistency-一致性-looks-correct"><a class="markdownIt-Anchor" href="#consistency-一致性-looks-correct"></a> Consistency 一致性 “looks correct”</h3>
<ul>
<li>
<p>数据库一致性 仍遵循完整性约束 未来事务能看到过去事务造成的后果</p>
</li>
<li>
<p>事务一致性  事务前后数据库内容一致 一致意味着多个事务访问相同数据得到相同结果</p>
</li>
</ul>
<h3 id="isolation-隔离性-lives-alone"><a class="markdownIt-Anchor" href="#isolation-隔离性-lives-alone"></a> Isolation 隔离性 “lives alone”</h3>
<p>事务所作修改提交前对其他事务不可见</p>
<ul>
<li>两种类别的并发控制协议来保证隔离性
<ul>
<li>悲观  从最初就避免问题的发生</li>
<li>乐观  假设冲突发生不常见，发生后再处理</li>
</ul>
</li>
</ul>
<h3 id="durability-持久性-survives-failure"><a class="markdownIt-Anchor" href="#durability-持久性-survives-failure"></a> Durability 持久性 “survives failure”</h3>
<p>事务提交的修改应被持久化，即便系统崩溃也不受影响</p>
<h2 id="conflict-serializability-in-transaction-scheduling"><a class="markdownIt-Anchor" href="#conflict-serializability-in-transaction-scheduling"></a> Conflict Serializability in transaction scheduling</h2>
<ul>
<li><strong>Schedules are equivalent to some serial schedule.</strong></li>
<li>This is what (almost) every DBMS supports when you ask for the SERIALIZABLE isolation level.</li>
<li>Schedule S is <strong>conflict serializable</strong> if you are able to <strong>transform</strong> S into a <strong>serial schedule</strong> by <strong>swapping</strong> consecutive non-conflicting operations of different transactions.</li>
<li>Verify using either the swapping method or dependency graphs.</li>
<li>A schedule is <strong>conflict serializable</strong> if and only if its dependency graph is <strong>acyclic</strong>.</li>
</ul>
<h2 id="consistency-conflicts-in-transaction-management"><a class="markdownIt-Anchor" href="#consistency-conflicts-in-transaction-management"></a> Consistency Conflicts in transaction management</h2>
<ul>
<li>读写冲突：
<ul>
<li>不可重复读 “non-repeatable read”   两个读的中间数据被另一个事务<strong>覆写并提交</strong> 导致第二次读的<strong>同一行值</strong>不同
<ul>
<li>transaction reads committed <strong>UPDATES</strong> from another transaction. The same row now has different values than it did when your transaction began.</li>
<li>A non-repeatable read occurs, when during the course of a transaction, a row is retrieved twice and the <strong>values within the row differ</strong> between reads.</li>
</ul>
</li>
<li>幻读 “phantom read” 两个读的中间<strong>被另一个事务插入/删除行并提交</strong> 导致第二次读<strong>返回的行不同</strong>
<ul>
<li>Phantom reads are similar but when reading from committed <strong>INSERTS</strong> and/or <strong>DELETES</strong> from another transaction. There are new rows or rows that have disappeared since you began the transaction.</li>
<li>A phantom read occurs when, in the course of a transaction, two identical queries are executed, and the <strong>collection of rows</strong> returned by the second query is different from the first.</li>
</ul>
</li>
<li>避免不可重复读锁行就足够，避免幻影读则需要锁表</li>
</ul>
</li>
<li>写读冲突： 脏读 “dirty reads” Reading uncommitted data 读了另一个事务没有提交的数据</li>
<li>写写冲突：丢失修改 “lost updates” overwriting uncommitted data 一个事务覆盖另一个事务没有提交的数据</li>
</ul>
<h2 id="pessimistic-concurrency-control"><a class="markdownIt-Anchor" href="#pessimistic-concurrency-control"></a> Pessimistic Concurrency Control</h2>
<h3 id="two-phase-locking-cc-protocol"><a class="markdownIt-Anchor" href="#two-phase-locking-cc-protocol"></a> Two-Phase Locking CC protocol</h3>
<ul>
<li>
<p><strong>Pessmistic 悲观的</strong> assume there are a lot of contentions in transactions 因此安全程度高 但并发能力会有所限制 (not allow all serializable schedules)</p>
</li>
<li>
<p>Two basic types of locks &amp; compatibility matrix</p>
<ul>
<li>Write lock X (exclusive) Read lock S (shared)</li>
</ul>
</li>
<li>
<p>2PL <strong>always</strong> gurantee conflicts-serializable schedule = grantee serializable schedule</p>
</li>
<li>
<p>二个阶段      “/\”</p>
<ul>
<li>生长期 只允许拿锁</li>
<li>收缩期 一旦释放第一个锁 进入收缩期
<ul>
<li>只允许释放锁 或不释放锁</li>
<li>不允许拿锁</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Problem: can have <strong>cascading abort</strong> in case of <strong>dirty reads</strong> 例如t1写 t2读 此时t1还没commit便abort 此时t2不得不abort…如果t2也写了还没来的及提交后面还有读的那这个反应会连锁下去</p>
</li>
<li>
<p>Solution: Strong Strict 2PL  (SS2PL) 一个事务提交/abort后才允许放锁 一次放完</p>
</li>
<li>
<p>Deadlock handling:</p>
<ul>
<li>Detection:
<ul>
<li>run backgroud task that periodically checks for cycles in waits-for graph / 超时检测</li>
<li>selects a victim to rollback and breaks the cycle 选择标准和rollback程度取决于具体设计</li>
</ul>
</li>
<li>Prevention:
<ul>
<li>assign priority based on timestamp  older timestamp = higher priority</li>
<li>after comparison, one will get lock, the other waits, this essentially breaks deadlock.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="locking-granularities-and-hierarchy"><a class="markdownIt-Anchor" href="#locking-granularities-and-hierarchy"></a> Locking Granularities and hierarchy</h3>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。<br>
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>
但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>
在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<ul>
<li>一个事务想要更新1billion tuples = ask for locks 1 billion times  VERY SLOW</li>
<li>WE NEED a lock hierarchy that reflects what is down there (行级) at high level (表级)</li>
</ul>
<h4 id="如何更方便的进行多粒度封锁-意向锁"><a class="markdownIt-Anchor" href="#如何更方便的进行多粒度封锁-意向锁"></a> 如何更方便的进行多粒度封锁： 意向锁</h4>
<ul>
<li>
<p>意向锁Intention lock: “lock escalation” 细粒度锁太多时动态的分配可用的粗粒度锁  大大减少lock manager需要处理的锁的请求数量</p>
<p>Intention locks <strong>allow a higher level node to be locked in shared or exclusive mode without having to check all descendant nodes.</strong> If a node is in an intention mode, then explicit locking is being done at a lower level in the tree. <strong>基本相当于告诉你下面有什么样的锁 通过兼容矩阵 可以从hierarchy高处如表级快速判断能不能读/写下层具体行的数据</strong></p>
</li>
<li>
<p>Intention-Shared (IS):下面某个地方有读锁</p>
<ul>
<li>Intention-Exclusive (IX):下面某个地方有写锁</li>
</ul>
</li>
<li>
<p>Shared+Intention-Exclusive (SIX):  整个子树可共享读，下面某个孩子有写锁</p>
</li>
<li>
<p>各种锁的兼容关系如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png"> </div><br>
解释如下：
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T<sub>1</sub> 想要对数据行 R<sub>1</sub> 加 X 锁，事务 T<sub>2</sub> 想要对同一个表的数据行 R<sub>2</sub> 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
</li>
</ul>
<h3 id="三级封锁协议"><a class="markdownIt-Anchor" href="#三级封锁协议"></a> 三级封锁协议</h3>
<ul>
<li><strong>一级封锁协议</strong>  事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题</li>
<li><strong>二级封锁协议</strong>  在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题</li>
<li><strong>三级封锁协议</strong>  在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题</li>
</ul>
<h3 id="mysql-隐式与显示锁定"><a class="markdownIt-Anchor" href="#mysql-隐式与显示锁定"></a> MySQL 隐式与显示锁定</h3>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会<strong>根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定</strong>。<br>
InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h2 id="optimistic-concurrency-control"><a class="markdownIt-Anchor" href="#optimistic-concurrency-control"></a> Optimistic Concurrency Control</h2>
<p>Ensure ordering using different methods. Assume they are good, handle problems later.</p>
<h3 id="basic-timestamp-ordering-to-cc-protocol"><a class="markdownIt-Anchor" href="#basic-timestamp-ordering-to-cc-protocol"></a> Basic Timestamp ordering (T/O) CC protocol</h3>
<ul>
<li>
<p>Basic idea: assign <strong>unique fixed monotonically increasing numeric</strong> value “timestamp” to determine <strong>commit order</strong>.</p>
<ul>
<li>different schemes for implementing timestamp: system clock, logical counter…</li>
</ul>
</li>
<li>
<p>Timestamp smaller TS(i) &lt; TS(j) = transaction i appears before j.</p>
</li>
<li>
<p>Method:</p>
<ul>
<li>Transaction r/w object without locks.</li>
<li>Every object X is tagged with timestamp of last txn that successfully did read / write. R-TS(X) / W-TS(X)</li>
<li>Reads
<ul>
<li>Check timestamp for every operations, if txn k tries to access an object from the future, <strong>TS(k) &lt; W-TS(X)</strong>, (timestamp order of k violates writer of X), k aborts and restarts with <strong>newer</strong> TS.</li>
<li>Otherwise allow txn k to read X, update R-TS(X) = max(R-TS(X), TS(k)), make a local copy of X to ensure repeatable reads for k. (subsequent read occurs in local copy)</li>
</ul>
</li>
<li>Writes
<ul>
<li>If TS(k) &lt; R-TS(X) or TS(k) &lt; W-TS(X) abort and restart k.
<ul>
<li>opitimization: in case of write can simply <strong>ignore and continue</strong> “thomas write rule” this allow us to even commit it. Somewhat useful but will not give us a conflict serializable schedule.</li>
</ul>
</li>
<li>else allow k to write X and update W-TS(X), make a local copy of X to ensure repeatable reads for k. (subsequent read occurs in local copy)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Comments:</p>
<ul>
<li>Can gurantee to generate a conflict serializable schedule if do not use “Thomas write rule”</li>
<li>No deadlocks because no “waiting” at all.</li>
<li>Can have starvation for long tens if shorter one keep causeing conflicts.</li>
<li>permits schedules that are not recoverable 可恢复事务: 他读到的所有事务在他之前commit</li>
<li>high overhead of copying data to local workspace and updating timestamps.</li>
</ul>
</li>
</ul>
<h3 id="optimistic-cc-occ-protocol"><a class="markdownIt-Anchor" href="#optimistic-cc-occ-protocol"></a> Optimistic CC (OCC) protocol</h3>
<ul>
<li>
<p>Basic idea:  No locks at all.</p>
<ul>
<li>DBMS creates a private workspace for each transaction</li>
<li>any obj read is copied into thread local workspace for following r/w, perform modifications at local workspace</li>
<li>Validation: when commits, DBMS compares local workspace to see if it incurrs conflicts with other txns. Get a timestamp.</li>
<li>Atomic install to global database if no conflicts.</li>
</ul>
</li>
<li>
<p>3 Phases</p>
<ul>
<li>
<ol>
<li>Read: make w/r modifications at private thread local workspace</li>
<li>Validation: check if conflicts exist before commit, get a timestamp</li>
<li>Write: valid =&gt; apply local changes to global database, abort &amp; restart otherwise.</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Serial Validation Explained</p>
<ul>
<li>Maintain a global view of all active txns.</li>
<li>record w/r set while txns running and write into private workspace</li>
<li>execute validation and write phase in a protected critical section</li>
<li>when txn invokes COMMIT, DBMS checks existence of conflicts through methods like the following, <strong>it checks if 双方write set intersects</strong>, if so, abort (myself) .
<ul>
<li>Backward Validation: look at all older txns in the system</li>
<li>Forward Validation: look at all younger txns in the system.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Comments:</p>
<ul>
<li>OCC Works well when #conflicts is low, transactions read heavy, mostly accessing disjoint subsets of data.  In this case locking is wasteful.</li>
<li>High overhead of copying data to local space. Serial Validation/Write bottlenecks. Aborts more wasteful than 2PL because txns have already executed.   The validation step also need latches when comparing read write sets because maybe T2 is writing while T1 is reading. latch contention when a lot of concurrent txns ?</li>
</ul>
</li>
</ul>
<h3 id="partition-based-timestamp-ordering-protocol"><a class="markdownIt-Anchor" href="#partition-based-timestamp-ordering-protocol"></a> Partition-based Timestamp ordering protocol</h3>
<ul>
<li>Idea:
<ul>
<li>partition db into disjoint subsets called partitions / <strong>shards</strong> so that we do not need locks.</li>
<li>Queued up &amp; assign timestamps upon arrival to order txns for serial execution at each partition. <strong>NO Concurrency  THIS IS SINGLE-THREADED</strong>.</li>
<li>Partitions are protected by a single lock. A txn acquires the partition’s lock if it has the lowest timestamp in queue, it starts when it has all the locks of partitions it needs (r/w).
<ul>
<li>A txn can read anything in the partition it have locked</li>
<li>write occurs in place, maintains a in-mem buffer to undo changes if aborted.</li>
<li>abort &amp; restart if accessing a partition that it does not have the lock.</li>
</ul>
</li>
<li>Only check conflicts between txns within same partitions.</li>
<li>The finer-grained each partition is the more parallelism we get on disjoint sets of data</li>
</ul>
</li>
<li>Comments:
<ul>
<li>Fast: when DBMS knows what partitions txn needs before it starts, most txns only need to access a single partition.</li>
<li>Mult-partition txns are slower, some partitions can be idle.</li>
</ul>
</li>
</ul>
<h3 id="phantom-problem"><a class="markdownIt-Anchor" href="#phantom-problem"></a> Phantom problem</h3>
<ul>
<li>The above discussed protocols only deal with read/update. But if we have insertions / updates / deletions, we can have the phantom problem.
<ul>
<li>2PL cannot solve this because these new rows do not even have locks.</li>
<li>Predicate locking can solve it but too hard to implement.</li>
<li>Index locking can solves it</li>
</ul>
</li>
</ul>
<h2 id="isolation-level"><a class="markdownIt-Anchor" href="#isolation-level"></a> Isolation Level</h2>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<p><img src="https://s2.ax1x.com/2020/02/02/1J7MlR.png" alt="isl"></p>
<ul>
<li>RU: 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>RC: 一个事务只能读取已经提交的事务所做的修改。</li>
<li>RR: 保证在同一个事务中多次读取同一数据的结果是一样的。</li>
<li>S: 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。从MVCC并发控制退化为基于锁的并发控制。不区别快照读和当前读，所有的读操作都是当前读，读加读锁（S锁），写加写锁（X锁）。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</li>
</ul>
<h2 id="multi-version-concurrency-control"><a class="markdownIt-Anchor" href="#multi-version-concurrency-control"></a> Multi-version concurrency control</h2>
<ul>
<li>
<p>“Let writers make a “new” copy while readers use an appropriate “old” copy.”</p>
</li>
<li>
<p>最常见的并发控制方法 DBMS. 非常适合读多写少的OLTP workload 可以提供rr级别的隔离程度</p>
</li>
<li>
<p>读=读一个版本 写=创建一个新版本 版本号一般是通过时间戳机制分配</p>
</li>
<li>
<p>只有 写写冲突 通过first commiter/first updater win 解决</p>
</li>
<li>
<p>RC RR隔离级别下使用版本链 多个版本的快照存在undo日志中，日志通过回滚指针把一个数据行的所有快照连起来</p>
</li>
<li>
<p>MVCC 维护一个read view结构 读的时候判断数据行快照是否可以使用</p>
</li>
<li>
<p>mvcc下快照读select…不需要锁，当前读（涉及插入删除更新）仍需要锁</p>
</li>
<li>
<p>mysql为了解决rr级别下当前读的幻读问题，使用了next-key lock本质上是索引锁+间隙锁 = 不仅锁定了索引还锁定了索引之间的间隙 就相当于数学上一个大区间中间很多个小区间  我在小区间端点上加锁之外还要在间隙上加锁才能保证安全性</p>
</li>
</ul>
<h1 id="关系数据库设计理论"><a class="markdownIt-Anchor" href="#关系数据库设计理论"></a> 关系数据库设计理论</h1>
<h2 id="函数依赖"><a class="markdownIt-Anchor" href="#函数依赖"></a> 函数依赖</h2>
<p>记 A-&gt;B 表示 A uniquely determines B，也可以说 B functionaly dependent on A。</p>
<p><strong>Full Functional Dependency :</strong> X is functionally dependent on Y and is not functionally dependent on any proper subset of Y.</p>
<p>A <strong>Partial Functional Dependency</strong> is when you have a Composite Primary Key (a primary key that is made up of multiple columns), and one of the non-key columns is functionally dependent on a proper subset of the columns that make up the Composite Primary Key.</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<p>For example : Let there be a relation R ( Course, Sid , Sname , fid, schedule ,  room , marks )</p>
<p>Full Functional Dependencies : {Course , Sid) -&gt; Sname , {Course , Sid} -&gt; Marks, etc.</p>
<p>Partial Functional Dependencies : Course -&gt; Schedule ,  Course -&gt; Room</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h3 id="1-第一范式-1nf"><a class="markdownIt-Anchor" href="#1-第一范式-1nf"></a> 1. 第一范式 (1NF)</h3>
<p>原子属性不可分。</p>
<h3 id="2-第二范式-2nf"><a class="markdownIt-Anchor" href="#2-第二范式-2nf"></a> 2. 第二范式 (2NF)</h3>
<p>1NF+每个非主属性不存在<strong>部分函数依赖</strong>(完全函数依赖于主属性/主键)。</p>
<p>可以通过分解来满足。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为主键，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于主键，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于主键，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size="4">  <strong>分解后</strong>  </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade  完全函数依赖</li>
</ul>
<h3 id="3-第三范式-3nf"><a class="markdownIt-Anchor" href="#3-第三范式-3nf"></a> 3. 第三范式 (3NF)</h3>
<p>2NF + 非主属性不存在“<strong>传递函数依赖</strong>”。</p>
<p>关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以把它分解成以下两个表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h1 id="er-图"><a class="markdownIt-Anchor" href="#er-图"></a> ER 图</h1>
<ul>
<li>一对多：带箭头的线</li>
<li>一对一：双向带箭头线</li>
<li>多对多：不带箭头的线</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/02/1JfQVH.png" alt="erdiagram"></p>
<h2 id="表示出现多次的关系"><a class="markdownIt-Anchor" href="#表示出现多次的关系"></a> 表示出现多次的关系</h2>
<p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" width="250px"> </div><br>
## 表示子类
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" width="450px"> </div><br>
# Indexing
<ul>
<li>
<p>data can only have one actual order sorted by a order</p>
</li>
<li>
<p><a href="https://blog.csdn.net/jiadajing267/article/details/54581262" target="_blank" rel="noopener">https://blog.csdn.net/jiadajing267/article/details/54581262</a></p>
</li>
<li>
<p>Clustered : actually order data the same way as index key</p>
</li>
<li>
<p>non-clustered: only a list of reference</p>
</li>
<li>
<p>index-key  what the sort order is based on</p>
</li>
<li>
<p>b+树 叶子层有序数组链表+非叶子层平衡多叉树有序索引   同时支持高效等值查询和范围查询 （节点内有序可以2分搜索）</p>
</li>
<li>
<p>b+树与b树区别： b+树非叶节点 相当于多级索引，不含指向record的指针 （节省空间储存更多索引项）  叶子层是有序数组<strong>链表</strong></p>
</li>
<li>
<p>为什么适合储存：b+树节点要求半满 而且因为是多路查找树 节点内容多 相比红黑 高度压缩非常明显 树的访问查找效率和高度直接相关 b+树非常矮 大大减少IO次数 更适合文件系统和数据储存  支持bulk-loading 更适合文件系统和数据储存</p>
</li>
<li></li>
<li>
<p>InnoDB和MyISAM的区别</p>
<ol>
<li>
<p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
<li>
<p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</p>
</li>
<li>
<p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
</li>
<li>
<p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>
</li>
<li>
<p>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
</ol>
</li>
</ul>
<h1 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> Nosql</h1>
<p>better suited for unstructured data</p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://th2zz.github.io/2019/10/01/database_concurrency/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/12/02/computer_network/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            计网总结
          
        </div>
      </a>
    
    
      <a href="/2019/10/01/java-jvm/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JVM</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
<div class="gitalk" id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '24a8a906a3b6e08b0b7a',
    clientSecret: 'a8443a2a0006c8e48692bb49c1ac84a9e51b0426',
    repo: 'gitalk-comment',
    owner: 'th2zz',
    admin: ['th2zz'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2016-2020
        th2zz
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="th2zz"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['生きるとはつまり螺旋のことだったんだよ！','',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>