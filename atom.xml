<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>th2zz</title>
  
  <subtitle>th2zz&#39;s notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://th2zz.github.io/"/>
  <updated>2019-03-29T20:07:06.177Z</updated>
  <id>http://th2zz.github.io/</id>
  
  <author>
    <name>th2zz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Operating System</title>
    <link href="http://th2zz.github.io/2019/03/29/Operating%20System/"/>
    <id>http://th2zz.github.io/2019/03/29/Operating System/</id>
    <published>2019-03-29T20:06:41.000Z</published>
    <updated>2019-03-29T20:07:06.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs537-operating-system-summary"><a class="markdownIt-Anchor" href="#cs537-operating-system-summary"></a> <strong>CS537 - Operating System Summary</strong></h1><h1 id="cpu-virtualization"><a class="markdownIt-Anchor" href="#cpu-virtualization"></a> CPU Virtualization</h1><h2 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process</h2><h3 id="what-is-a-process"><a class="markdownIt-Anchor" href="#what-is-a-process"></a> What is a process</h3><ul><li>A running program is a process</li><li>Stream of executing instructions and their “context”</li></ul><h3 id="thread"><a class="markdownIt-Anchor" href="#thread"></a> Thread</h3><ul><li>Can have multiple threads within a single process</li><li>Lightweight process</li><li>Share an address space</li></ul><h3 id="why-do-we-need-processes"><a class="markdownIt-Anchor" href="#why-do-we-need-processes"></a> Why do we need processes?</h3><ul><li>Share CPU: Time sharing</li></ul><h3 id="os-scheduler"><a class="markdownIt-Anchor" href="#os-scheduler"></a> OS Scheduler</h3><ul><li>Scheduler save context when process is pause</li><li>Restore context on resumption</li></ul><h3 id="goals-for-cpu-virtualization"><a class="markdownIt-Anchor" href="#goals-for-cpu-virtualization"></a> Goals for CPU Virtualization</h3><ul><li><p>Policy goals</p><ul><li>Virtualize CPU resource using processes</li><li>Reschedule process for fairness? efficiency?</li></ul></li><li><p>Mechanism goals</p><ul><li>Efficiency: Time sharing should not add overhead</li><li>Control: OS should be able to intervene when required</li></ul></li></ul><h2 id="mechanism"><a class="markdownIt-Anchor" href="#mechanism"></a> Mechanism</h2><h3 id="system-call"><a class="markdownIt-Anchor" href="#system-call"></a> System call</h3><ul><li><p>User mode and kernel mode</p><ul><li>User processes run in user mode (restricted mode)</li><li>OS runs in kernel mode (not restricted)</li></ul></li><li><p>System call</p><ul><li>Separate user mode from kernel mode for security</li><li>Use system call to invoke kernel mode functions</li></ul></li><li><p>Procedure for calling read()</p><ol><li>Set system call table index to 6 <code>movl $6, %eax</code></li><li>Call trap with id 64 <code>int $64</code></li></ol></li></ul><p><img src="https://i.imgur.com/7hmjTrj.png" alt=""></p><h3 id="dispatch-mechanism"><a class="markdownIt-Anchor" href="#dispatch-mechanism"></a> Dispatch mechanism</h3><ul><li><p>Dispatch loop</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">    runprocessA for some time-slice</span><br><span class="line">    stop process A and save its context</span><br><span class="line">    load context of another process B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Cooperative Multi-tasking</p><ul><li>Trust process to relinquish CPU through traps</li><li>Provide special yield() system call</li><li>Processes can <strong>misbehave</strong></li></ul></li><li><p>Timer-based Multi-tasking</p><ul><li>Hardware generates timer interrupt (CPU or separate chip)</li><li>User must not be able to mask timer interrupt</li></ul></li></ul><p><img src="https://i.imgur.com/eE325zz.png" alt=""></p><h2 id="policy"><a class="markdownIt-Anchor" href="#policy"></a> Policy</h2><h3 id="vocabulary"><a class="markdownIt-Anchor" href="#vocabulary"></a> Vocabulary</h3><ul><li>Workload: set of jobs (arrival time, run_time)</li><li>Job ~ Current execution of a process</li><li>Scheduler: Decides which ready job to run</li><li>Metric: measurement of scheduling quality</li><li>Turnaround time = completion time - arrival time</li><li>Response time = first run time - arrival time</li></ul><h3 id="fifo-first-in-first-out"><a class="markdownIt-Anchor" href="#fifo-first-in-first-out"></a> FIFO (First In, First Out)</h3><ul><li>Disadvantage: Turnaround time suffers when short jobs must wait for long jobs (Convoy Effect)</li></ul><img src="https://i.imgur.com/p6B5iuB.png" width="75%" style="margin:auto; display: block;"><h3 id="sjf-shortest-job-first"><a class="markdownIt-Anchor" href="#sjf-shortest-job-first"></a> SJF (Shortest job first)</h3><ul><li>Disadvantage: Only schedule new job when previous job voluntarily relinquishes CPU</li></ul><img src="https://i.imgur.com/4L0JHF6.png" width="75%" style="margin:auto; display: block;"><h3 id="stcf-shortest-time-to-completion-first"><a class="markdownIt-Anchor" href="#stcf-shortest-time-to-completion-first"></a> STCF (Shortest Time-to-Completion First)</h3><ul><li>Preemptive: Schedule different job by taking CPU away from running job</li><li>Always run job that will complete the quickest</li></ul><img src="https://i.imgur.com/F97B6qw.png" width="75%" style="margin:auto; display: block;"><h3 id="round-robin"><a class="markdownIt-Anchor" href="#round-robin"></a> Round Robin</h3><ul><li>Goal: reduce response time</li><li>Trade-off: increase turnaround time</li></ul><img src="https://i.imgur.com/aNCUwiF.png" width="75%" style="margin:auto; display: block;"><h3 id="io-aware-scheduling"><a class="markdownIt-Anchor" href="#io-aware-scheduling"></a> I/O Aware Scheduling</h3><ul><li>Goal: process won’t hold CPU when doing IO</li></ul><img src="https://i.imgur.com/S8TUga8.png" width="75%" style="margin:auto; display: block;"><h3 id="multilevel-feedback-queue"><a class="markdownIt-Anchor" href="#multilevel-feedback-queue"></a> Multilevel Feedback Queue</h3><ul><li><p>Motivation: Run-time of each job is not known</p></li><li><p>Approach</p><ul><li>Multiple levels of round-robin</li><li>Each level has higher priority than lower level</li><li>Can preempt them</li></ul></li><li><p>Rules</p><ol><li>If priority(A) &gt; Priority(B), A runs</li><li>If priority(A) == Priority(B), A &amp; B run in RR</li><li>Processes start at top priority</li><li>If job uses whole slice, demote process (longer time slices at lower priorities)</li></ol></li><li><p>Avoid starvation</p><ul><li>Problem: Low priority job may never get scheduled</li><li>Solution: Periodically boost priority of all jobs (or all jobs thathaven’t been scheduled)</li></ul></li></ul><img src="https://i.imgur.com/RL4PuJC.png" width="50%" style="margin:auto; display: block;"><h1 id="memory-virtualization"><a class="markdownIt-Anchor" href="#memory-virtualization"></a> Memory Virtualization</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><h3 id="goals"><a class="markdownIt-Anchor" href="#goals"></a> Goals</h3><ul><li><strong>Transparency</strong>: Process is unaware of sharing</li><li><strong>Protection</strong>: Cannot corrupt OS or other process memory</li><li><strong>Efficiency</strong>: Do not waste memory or slow down processes</li><li><strong>Sharing</strong>: Enable sharing between cooperating processes</li></ul><h3 id="address-space"><a class="markdownIt-Anchor" href="#address-space"></a> Address space</h3><ul><li>Stack: No fragmentation</li><li>Heap: Consists of allocated and free areas (holes)<br><img src="https://i.imgur.com/we79L5F.png" alt=""></li></ul><h3 id="memory-access-example"><a class="markdownIt-Anchor" href="#memory-access-example"></a> Memory Access Example</h3><table><thead><tr><th>Assembly</th><th>Access for Instruction</th><th>Access for Execution</th></tr></thead><tbody><tr><td><code>0x10: movl 0x8(%rbp), %edi</code></td><td>Fetch instruction at 0x10</td><td>Load from 0x208</td></tr><tr><td><code>0x13: addl $0x3, %edi</code></td><td>Fetch instruction at 0x13</td><td>No memory access</td></tr><tr><td><code>0x19: movl %edi, 0x8(%rbp)</code></td><td>Fetch instruction at 0x19</td><td>Store to 0x208</td></tr></tbody></table><h2 id="basic-mechanisms"><a class="markdownIt-Anchor" href="#basic-mechanisms"></a> Basic Mechanisms</h2><h3 id="time-sharing"><a class="markdownIt-Anchor" href="#time-sharing"></a> Time Sharing</h3><ul><li>On process switch, save current process’s memory to disk and load another process’s memory from disk.</li><li>Ridiculously poor performance</li></ul><h3 id="static-relocation"><a class="markdownIt-Anchor" href="#static-relocation"></a> Static Relocation</h3><ul><li><p>Idea</p><ul><li>OS rewrites each program before loading it as a process in memory</li><li>Each rewrite for different process uses different addresses and pointers</li><li>Change jumps, loads of static data</li></ul></li><li><p>Disadvantage</p><ul><li>Process can destroy OS or other processes</li><li>No privacy</li><li>Cannot move address space after it has been placed</li><li>May not be able to allocate new process</li></ul></li></ul><p><img src="https://i.imgur.com/840IDak.png" alt=""></p><h3 id="dynamic-relocation-introduction"><a class="markdownIt-Anchor" href="#dynamic-relocation-introduction"></a> Dynamic Relocation: Introduction</h3><ul><li><p>Goal: Protect processes from one another</p></li><li><p>Memory Management Unit (MMU)</p><ul><li>MMU dynamically changes process address at every memory reference</li><li>Process generates <strong>logical</strong> or <strong>virtual</strong> addresses (in their address space)</li><li>Memory hardware uses <strong>physical</strong> or <strong>real</strong> addresses</li></ul></li></ul><p><img src="https://i.imgur.com/1rZVwO8.png" alt=""></p><ul><li>Two operating modes<ul><li><p>Kernel mode</p><ul><li>Can manipulate contents of MMU</li><li>Allows OS to access all of physical memory</li></ul></li><li><p>User mode</p><ul><li>Perform translation of logical address to physical address</li></ul></li></ul></li></ul><h3 id="dynamic-relocation-base-register"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-register"></a> Dynamic Relocation: Base Register</h3><ul><li>Translation on every memory access of user process</li><li>MMU adds base register to logical address to form physical address</li><li>Store offset in base register</li><li>Each process has different value in base register</li><li>Dynamic relocation by changing value of base register.</li></ul><p><img src="https://i.imgur.com/Eika7Rs.png" alt=""></p><ul><li><p>Quiz</p><ul><li>What entity should do translation of addresses with base register? <strong>Hardware</strong></li><li>What entity should modify the base register? <strong>OS</strong></li></ul></li><li><p>Problem: No protection</p></li></ul><h3 id="dynamic-relocation-base-bounds"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-bounds"></a> Dynamic Relocation: Base + Bounds</h3><ul><li><p>Idea</p><ul><li>limit the address space with a bounds register</li><li>Base register: smallest physical addr (or starting location)</li><li>Bounds register: size of this process’s virtual address space</li><li>OS kills process if process loads/stores beyond bounds</li></ul></li><li><p>Implementation</p><ul><li>MMU compares logical address to bounds register</li><li>if logical address is greater, then generate error</li><li>MMU adds base register to logical address to form physical address</li></ul></li></ul><p><img src="https://i.imgur.com/Qoqdgtb.png" alt=""></p><ul><li><p>Context switch</p><ol><li>Change to privileged mode</li><li>Save base and bounds registers of old process</li><li>Load base and bounds registers of new process</li><li>Change to user mode and jump to new process</li></ol></li><li><p>Advantages</p><ul><li>Provides protection (both read and write) across address spaces</li><li>Supports dynamic relocation</li><li>Simple, inexpensive implementation: Few registers, little logic in MMU</li><li>Fast: Add and compare in parallel</li></ul></li><li><p>Disadvantages</p><ul><li>Each process must be allocated contiguously in physical memory</li><li>Must allocate memory that may not be used by process</li><li>No partial sharing: Cannot share limited parts of address space</li></ul></li></ul><h3 id="segmentation"><a class="markdownIt-Anchor" href="#segmentation"></a> Segmentation</h3><ul><li><p>Idea</p><ul><li>MMU contains Segment Table (per process)</li><li>Each segment has own base and bounds, protection bits</li><li>Example: 14 bit logical address, 4 segments;</li></ul></li><li><p>Example</p><ul><li><p>Segment Table</p><table><thead><tr><th>Segment</th><th>Base</th><th>Bounds</th><th>R W</th></tr></thead><tbody><tr><td>0</td><td>0x2000</td><td>0x6ff</td><td>1 0</td></tr><tr><td>1</td><td>0x0000</td><td>0x4ff</td><td>1 1</td></tr><tr><td>2</td><td>0x3000</td><td>0xfff</td><td>1 1</td></tr><tr><td>3</td><td>0x0000</td><td>0x000</td><td>0 0</td></tr></tbody></table></li><li><p>Translation</p><table><thead><tr><th>Logical address</th><th>Segment</th><th>Base</th><th>Physical address</th></tr></thead><tbody><tr><td>0x0240</td><td>0</td><td>0x2000</td><td>0x2240</td></tr><tr><td>0x1108</td><td>1</td><td>0x0000</td><td>0x1108</td></tr><tr><td>0x256c</td><td>2</td><td>0x3000</td><td>0x356c</td></tr><tr><td>0x3002</td><td>3</td><td>0x0000</td><td>Fail</td></tr></tbody></table></li></ul></li><li><p>Advantages</p><ul><li>No extra memory access</li><li>Enables sparse allocation of address space</li><li>Stack and heap can grow independently</li><li>Enables sharing of selected segments</li><li>Read-only status for code</li><li>Supports dynamic relocation of each segment</li></ul></li><li><p>Disadvantages</p><ul><li>Each segment must be allocated contiguously</li><li>May not have sufficient physical memory for large segments?</li><li>External Fragmentation</li></ul></li></ul><h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3><table><thead><tr><th>Description</th><th>Name of approach</th></tr></thead><tbody><tr><td>One process uses RAM at a time</td><td>Time Sharing</td></tr><tr><td>Rewrite code and addresses before running</td><td>Static Relocation</td></tr><tr><td>Add per-process starting location to virt addr to obtain phys addr</td><td>Base</td></tr><tr><td>dynamic approach that verifies address is in valid range</td><td>Base + Bounds</td></tr><tr><td>Several base+bound pairs per process</td><td>Segmentation</td></tr></tbody></table><h2 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h2><h3 id="fragmentation"><a class="markdownIt-Anchor" href="#fragmentation"></a> Fragmentation</h3><ul><li><p>Definition</p><ul><li>Free memory that can’t be usefully allocated</li></ul></li><li><p>Types of fragmentation</p><ul><li>External: Visible to allocator (e.g., OS)</li><li>Internal: Visible to requester</li></ul></li></ul><h3 id="introduction-for-paging"><a class="markdownIt-Anchor" href="#introduction-for-paging"></a> Introduction for Paging</h3><ul><li><p>Goal</p><ul><li>Eliminate requirement that address space is contiguous</li><li>Eliminate external fragmentation</li><li>Grow segments as needed</li></ul></li><li><p>Idea</p><ul><li>Divide address spaces and physical memory into fixed-sized pages (usually 4KB)</li></ul></li></ul><h3 id="translation-of-page-addresses"><a class="markdownIt-Anchor" href="#translation-of-page-addresses"></a> Translation of Page Addresses</h3><ul><li>Logical address<ul><li>High-order bits of address designate page number</li><li>Low-order bits of address designate offset within page</li></ul></li></ul><p><img src="https://i.imgur.com/EuMGAwS.png" alt=""></p><ul><li><p>Address Format</p><table><thead><tr><th>Page Size</th><th>Low Bits</th><th>Virt Addr Bits</th><th>High Bits</th><th>Virt Pages</th></tr></thead><tbody><tr><td>16 bytes</td><td>log(16) = 4</td><td>10</td><td>10 - 4 = 6</td><td>2 ^ 6 = 64</td></tr><tr><td>1 KB</td><td>log(1K) = 10</td><td>20</td><td>20 - 10 = 10</td><td>2 ^ 10 = 1024</td></tr><tr><td>1 MB</td><td>log(1M) = 20</td><td>32</td><td>32 - 20 = 12</td><td>2 ^ 12 = 4K</td></tr><tr><td>512 bytes</td><td>log(512) = 9</td><td>16</td><td>16 - 9 = 7</td><td>2 ^ 7 = 128</td></tr><tr><td>4 KB</td><td>log(4K) = 12</td><td>32</td><td>32 -12 = 20</td><td>2 ^ 20 = 1M</td></tr></tbody></table></li><li><p>Address Translation</p><ul><li>Number of bits in virtual address <strong>need not equal</strong> number of bits in physical address</li></ul></li></ul><p><img src="https://i.imgur.com/HZcAtTC.png" alt=""></p><h3 id="pagetables"><a class="markdownIt-Anchor" href="#pagetables"></a> Pagetables</h3><ul><li><p>How should OS translate VPN to PPN?</p><ul><li>Simple solution: Linear page table aka array</li></ul></li><li><p>Example<br><img src="https://i.imgur.com/uWlRJnw.png" alt=""></p><ul><li>Page table for P1: 3, 1, 7, 10</li><li>Page table for P2: 0, 4, 2, 6</li><li>Page table for P3: 8, 5, 9, 11</li></ul></li><li><p>How big is a pagetable</p><ul><li>Given 32-bit address space, 4KB pages, 4 byte entries</li><li>4KB pages =&gt; 12 bit for offset</li><li>32-bit address space =&gt; 20 bit for VPN =&gt; 2 ^ 20 = 1MB entries</li><li>1MB entries * 4 byte per entry = 4MB</li></ul></li><li><p>Where are pagetables stored</p><ul><li>Store each page table in memory</li><li>Hardware finds page table base with register (e.g., CR3 on x86)</li></ul></li><li><p>What happens on a context-switch?</p><ul><li>Change contents of page table base register to newly scheduled process</li><li>Save old page table base register in PCB of descheduled process</li></ul></li><li><p>What other info is in pagetable entries besides translation?</p><ul><li>valid bit</li><li>protection bits</li><li>present bit (needed later)</li><li>reference bit (needed later)</li><li>dirty bit (needed later)</li></ul></li></ul><h3 id="memory-access-with-paging"><a class="markdownIt-Anchor" href="#memory-access-with-paging"></a> Memory Access with Paging</h3><ul><li><p>Given</p><ul><li>Current instruction: <code>0x0010: movl 0x1100, %edi</code></li><li>Assume PT is at phys addr 0x5000</li><li>Assume PTE’s are 4 bytes</li><li>Assume 4KB pages =&gt; 12 bits for offset</li><li>Page table for current process: 2, 0, 80, 99</li></ul></li><li><p>Fetch instruction at logical addr 0x0010</p><ul><li>Access page table to get ppn for vpn 0</li><li>Mem ref 1: 0x5000</li><li>Learn vpn 0 is at ppn 2</li><li>Fetch instruction at 0x2010 (Mem ref 2)</li></ul></li><li><p>Exec, load from logical addr 0x1100</p><ul><li>Access page table to get ppn for vpn 1</li><li>Mem ref 3: 0x5000</li><li>Learn vpn 1 is at ppn 0</li><li>movl from 0x0100 into reg (Mem ref 4)</li></ul></li></ul><h3 id="advantages-of-paging"><a class="markdownIt-Anchor" href="#advantages-of-paging"></a> Advantages of Paging</h3><ul><li><p>No external fragmentation</p><ul><li>Any page can be placed in any frame in physical memory</li></ul></li><li><p>Fast to allocate and free</p><ul><li>Alloc: No searching for suitable free space</li><li>Free: Doesn’t have to coalesce with adjacent free space</li></ul></li><li><p>Simple to swap-out portions of memory to disk (later lecture)</p><ul><li>Page size matches disk block size</li><li>Can run process when some pages are on disk</li><li>Add “present” bit to PTE</li></ul></li></ul><h3 id="disadvantages-of-paging"><a class="markdownIt-Anchor" href="#disadvantages-of-paging"></a> Disadvantages of Paging</h3><ul><li><p>Internal fragmentation: Page size may not match size needed by process</p><ul><li>Wasted memory grows with larger pages</li><li>Tension?</li></ul></li><li><p>Additional memory reference to page table -&gt; Very inefficient</p><ul><li>Page table must be stored in memory</li><li>MMU stores only base address of page table</li></ul></li><li><p>Storage for page tables may be substantial</p><ul><li>Simple page table: Requires PTE for all pages in address space</li><li>Entry needed even if page not allocated?</li></ul></li></ul><h3 id="paging-translation-steps"><a class="markdownIt-Anchor" href="#paging-translation-steps"></a> Paging Translation Steps</h3><ol><li>extract VPN (virt page num) from VA (virt addr)</li><li>calculate addr of PTE (page table entry)</li><li>read PTE from memory</li><li>extract PFN (page frame num)</li><li>build PA (phys addr)</li><li>read contents of PA from memory into register</li></ol><h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2><h3 id="motivative-example-iterating-array"><a class="markdownIt-Anchor" href="#motivative-example-iterating-array"></a> Motivative Example: Iterating Array</h3><ul><li><p>Code</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Memory Access</p><table><thead><tr><th>What virtual addresses?</th><th>What physical addresses?</th></tr></thead><tbody><tr><td>load 0x3000</td><td>load 0x100C <br>load 0x7000</td></tr><tr><td>load 0x3004</td><td>load 0x100C <br>load 0x7004</td></tr><tr><td>load 0x3008</td><td>load 0x100C <br>load 0x7008</td></tr><tr><td>load 0x300C</td><td>load 0x100C <br>load 0x7008</td></tr></tbody></table></li></ul><h3 id="introduction-2"><a class="markdownIt-Anchor" href="#introduction-2"></a> Introduction</h3><ul><li>Strategy: Cache Page Translations</li><li>TLB stands for Translation Lookaside Buffer<br><img src="https://i.imgur.com/mEwtslZ.png" alt=""></li></ul><h3 id="tlb-organization"><a class="markdownIt-Anchor" href="#tlb-organization"></a> TLB Organization</h3><ul><li><p>TLB Entry</p><table><thead><tr><th>Tag (virtual page number)</th><th>Physical page number (page table entry)</th></tr></thead><tbody></tbody></table></li><li><p>Fully associative</p><ul><li>Any given translation can be anywhere in the TLB</li><li>Hardware will search the entire TLB in parallel</li></ul></li></ul><h3 id="example-iterating-array-with-tlb"><a class="markdownIt-Anchor" href="#example-iterating-array-with-tlb"></a> Example: Iterating Array with TLB</h3><ul><li><p>Code</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Page table for current process (starting at 0x0000)</p>  <table>      <tbody>          <tr>              <td>PPN</td>              <td>1</td>              <td>5</td>              <td>4</td>              <td>…</td>          </tr>          <tr>              <td>VPN</td>              <td>0</td>              <td>1</td>              <td>2</td>              <td>3</td>          </tr>      </tbody>  </table></li><li><p>TLB</p><table><thead><tr><th>Valid</th><th>VPN</th><th>PPN</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>5</td></tr><tr><td>1</td><td>2</td><td>4</td></tr></tbody></table></li><li><p>Memory Access</p><table><thead><tr><th>What virtual addresses?</th><th>What physical addresses?</th></tr></thead><tbody><tr><td>load 0x1000</td><td>load 0x0004 <br>load 0x5000</td></tr><tr><td>load 0x1004</td><td>(TLB hit) <br>load 0x5004</td></tr><tr><td>load 0x1008</td><td>(TLB hit) <br>load 0x5008</td></tr><tr><td>load 0x100C</td><td>(TLB hit) <br>load 0x500C</td></tr><tr><td>…</td><td>…</td></tr><tr><td>load 0x2000</td><td>load 0x0008 <br>load 0x4000</td></tr><tr><td>load 0x2004</td><td>(TLB hit) <br>load 0x4004</td></tr></tbody></table></li><li><p>Performance</p><ul><li># TLB lookups = number of accesses to a = 2048</li><li># TLB misses = 2</li><li>Miss rate = 2/2048 = 0.1%</li><li>Hit rate = 1 – miss rate = 99.9%</li></ul></li></ul><h3 id="tlb-replacement-policies"><a class="markdownIt-Anchor" href="#tlb-replacement-policies"></a> TLB Replacement Policies</h3><ul><li><p>Access Patterns</p><ul><li>Sequential array accesses almost always hit in TLB: Very fast!</li><li>Highly random, with no repeat accesses: Slow</li></ul></li><li><p>Code Example</p><table><thead><tr><th>Workload A</th><th>Workload B</th></tr></thead><tbody><tr><td><img src="https://i.imgur.com/fg4fYXO.png" alt=""></td><td><img src="https://i.imgur.com/b3eYUnz.png" alt=""></td></tr><tr><td></td><td></td></tr><tr><td><img src="https://i.imgur.com/HWMGImG.png" alt=""></td><td><img src="https://i.imgur.com/iMYOS03.png" alt=""></td></tr></tbody></table></li><li><p>Workload Locality</p><ul><li>Spatial Locality: future access will be to nearby addresses</li><li>Temporal Locality: future access will be repeats to the same data</li></ul></li><li><p>What TLB characteristics are best for each type?</p><ul><li><p>Spatial:</p><ul><li>Access same page repeatedly; need same vpn à ppn translation</li><li>Same TLB entry re-used</li></ul></li><li><p>Temporal:</p><ul><li>Access same address near in future</li><li>Same TLB entry re-used in near future</li><li>How near in future? How many TLB entries are there?</li></ul></li></ul></li><li><p>Replacement policies</p><ul><li>LRU: evict Least-Recently Used TLB slot when needed</li><li>Random: Evict randomly choosen entry</li></ul></li></ul><h3 id="context-switches"><a class="markdownIt-Anchor" href="#context-switches"></a> Context Switches</h3><ul><li><p>What happens if a process uses cached TLB entries from another process?</p><ol><li><p>Flush TLB on each switch</p><ul><li>Costly</li><li>lose all recently cached translations</li></ul></li><li><p>Track which entries are for which process</p><ul><li>Address Space Identifier</li><li>Tag each TLB entry with an 8-bit ASID</li></ul></li></ol></li><li><p>TLB Example with ASID</p><ul><li><p>Pagetable</p><ul><li>P1 (ASID 11): 1, 5, 4, …</li><li>P2 (ASID 12): 6, 2, 3, …</li></ul></li><li><p>TLB</p><table><thead><tr><th>Valid</th><th>Virt</th><th>Phys</th><th>ASID</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>9</td><td>11</td></tr><tr><td>1</td><td>1</td><td>5</td><td>11</td></tr><tr><td>1</td><td>1</td><td>2</td><td>12</td></tr><tr><td>1</td><td>0</td><td>1</td><td>11</td></tr></tbody></table></li><li><p>Memory access</p><table><thead><tr><th>Virtual</th><th>Physical</th></tr></thead><tbody><tr><td>load 0x1444 with ASID 12</td><td>0x2444</td></tr><tr><td>load 0x1444 with ASID 11</td><td>0x5444</td></tr></tbody></table></li></ul></li><li><p>TLB Performance</p><ul><li><p>Context switches are expensive</p></li><li><p>Even with ASID, other processes “pollute” TLB</p><ul><li>Discard process A’s TLB entries for process B’s entries</li></ul></li><li><p>Architectures can have multiple TLBs</p><ul><li>1 TLB for data, 1 TLB for instructions</li><li>1 TLB for regular pages, 1 TLB for “super pages”</li></ul></li></ul></li></ul><h3 id="tlb-misses"><a class="markdownIt-Anchor" href="#tlb-misses"></a> TLB Misses</h3><ul><li><p>Who Handles TLB MISS? Hardware or OS?</p></li><li><p>Hardware: CPU must know where pagetables are</p><ul><li>CR3 register on x86</li><li>Pagetable structure fixed and agreed upon between HW and OS</li><li>HW “walks” the pagetable and fills TLB</li></ul></li><li><p>OS: “Software-managed TLB”</p><ul><li>CPU traps into OS upon TLB miss</li><li>OS interprets pagetables as it chooses</li><li>Modifying TLB entries is privileged</li><li>Need same protection bits in TLB as pagetable - rwx</li></ul></li></ul><h3 id="summary-2"><a class="markdownIt-Anchor" href="#summary-2"></a> Summary</h3><ul><li><p>Pages are great, but accessing page tables for every memory access is slow</p></li><li><p>Cache recent page translations -&gt; TLB</p><ul><li>Hardware performs TLB lookup on every memory access</li></ul></li><li><p>TLB performance depends strongly on workload</p><ul><li>Sequential workloads perform well</li><li>Workloads with temporal locality can perform well</li></ul></li><li><p>In different systems, hardware or OS handles TLB misses</p></li><li><p>TLBs increase cost of context switches</p><ul><li>Flush TLB on every context switch</li><li>Add ASID to every TLB entry</li></ul></li></ul><h2 id="smaller-page-tables"><a class="markdownIt-Anchor" href="#smaller-page-tables"></a> Smaller Page Tables</h2><h3 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h3><ul><li><p>How big are page tables</p><ol><li><p>PTE’s are 2 bytes, and 32 possible virtual page numbers</p><ul><li>2 bytes * 32 = 64 bytes</li></ul></li><li><p>PTE’s are 2 bytes, virtual addrs are 24 bits, pages are 16 bytes</p><ul><li>16 bytes page =&gt; 4 bit offset =&gt; 20 bit VPN</li><li>=&gt; 2^20 Pages =&gt;  2^20 * 2 = 2MB for page tables</li></ul></li><li><p>PTE’s are 4 bytes, virtual addrs are 32 bits, and pages are 4 KB</p><ul><li>4KB page =&gt; 12 bit offset =&gt; 20 bit VPN</li><li>=&gt; 2^20 Pages =&gt;  2^20 * 4 = 4MB for page tables</li></ul></li><li><p>PTE’s are 4 bytes, virtual addrs are 64 bits, and pages are 4 KB</p><ul><li>4KB page =&gt; 12 bit offset =&gt; 52 bit VPN</li><li>=&gt; 2^52 Pages =&gt;  2^52 * 4 = 18.0143985 PB for page tables</li></ul></li></ol></li><li><p>Why are Page Tables so Large?</p><ul><li>Many invalid PT entries</li></ul></li></ul><p><img src="https://i.imgur.com/hw6UrkL.png" alt=""></p><ul><li>Summary<ul><li><p>Storage for page tables may be substantial</p></li><li><p>Simple page table: Requires PTE for all pages in address space</p></li><li><p>Entry needed even if page not allocated.</p></li></ul></li></ul><h3 id="smaller-page-tables-2"><a class="markdownIt-Anchor" href="#smaller-page-tables-2"></a> Smaller Page Tables</h3><ul><li><p>Use more complex page tables, instead of just big array</p></li><li><p>Any data structure is possible with software-managed TLB</p><ul><li><p>Hardware looks for vpn in TLB on every memory access</p></li><li><p>If TLB does not contain vpn, TLB miss</p><ul><li>Trap into OS and let OS find vpn-&gt;ppn translation</li><li>OS notifies TLB of vpn-&gt;ppn for future accesses</li></ul></li></ul></li><li><p>Other approaches</p><ol><li><p>Segmented Pagetables</p></li><li><p>Multi-level Pagetables</p><ul><li>Page the page tables</li><li>Page the pagetables of page tables…</li></ul></li><li><p>Inverted Pagetables</p></li></ol></li></ul><h3 id="paging-with-segmentation"><a class="markdownIt-Anchor" href="#paging-with-segmentation"></a> Paging with Segmentation</h3><ul><li><p>Idea</p><ul><li><p>Divide address space into segments (code, heap, stack)</p></li><li><p>Divide each segment into fixed-sized pages</p></li><li><p>Logical address divided into three portions</p><table><thead><tr><th>seg # (4 bits)</th><th>page number (8 bits)</th><th>page offset (12 bits)</th></tr></thead><tbody></tbody></table></li></ul></li><li><p>Implementation</p><ul><li>Each segment has a page table</li><li>Each segment track base (physical address) and bounds of the page table</li></ul></li><li><p>Quiz</p><ul><li><p>Logical address layout</p><table><thead><tr><th>seg # (4 bits)</th><th>page number (8 bits)</th><th>page offset (12 bits)</th></tr></thead><tbody></tbody></table></li><li><p>Segment Table</p><table><thead><tr><th>Segment</th><th>Base</th><th>Bounds</th><th>R W</th></tr></thead><tbody><tr><td>0</td><td>0x002000</td><td>0xff</td><td>1 0</td></tr><tr><td>1</td><td>0x000000</td><td>0x00</td><td>0 0</td></tr><tr><td>2</td><td>0x001000</td><td>0x0f</td><td>1 1</td></tr></tbody></table></li><li><p>Translation</p><table><thead><tr><th>Virtual</th><th>Seg</th><th>Base</th><th>Offset</th><th>PPN</th><th>Physical</th><th>Note</th></tr></thead><tbody><tr><td>0x002070 R</td><td>0</td><td>0x002000</td><td>2</td><td>0x004</td><td>0x004070</td><td></td></tr><tr><td>0x202016 R</td><td>2</td><td>0x001000</td><td>2</td><td>0x003</td><td>0x003016</td><td></td></tr><tr><td>0x104c84 R</td><td>1</td><td>-</td><td>-</td><td>-</td><td>-</td><td>R = 0</td></tr><tr><td>0x010424 W</td><td>0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>W = 0</td></tr><tr><td>0x210014 W</td><td>2</td><td>-</td><td>-</td><td>-</td><td>-</td><td>bounds</td></tr><tr><td>0x203568 W</td><td>2</td><td>0x001000</td><td>3</td><td>0x02a</td><td>0x02a568</td><td></td></tr></tbody></table></li></ul></li><li><p>Advantages</p><ul><li><p>Advantages of Segments</p><ul><li>Supports sparse address spaces.</li><li>Decreases size of page tables. If segment not used, not need for page table</li></ul></li><li><p>Advantages of Pages</p><ul><li>No external fragmentation</li><li>Segments can grow without any reshuffling</li><li>Can run process when some pages are swapped to disk (next lecture)</li></ul></li><li><p>Advantages of Both</p><ul><li>Increases flexibility of sharing: Share either single page or entire segment</li></ul></li></ul></li><li><p>Disadvantages</p><ul><li>Potentially large page tables (for each segment)</li><li>Must allocate each page table contiguously</li><li>More problematic with more address bits</li></ul></li></ul><h3 id="multilevel-page-tables"><a class="markdownIt-Anchor" href="#multilevel-page-tables"></a> Multilevel Page Tables</h3><ul><li><p>Goal: Allow each page tables to be allocated non-contiguously</p></li><li><p>Idea: Page the page tables</p><ul><li>Creates multiple levels of page tables; outer level “page directory”</li><li>Only allocate page tables for pages in use</li><li>Used in x86 architectures (hardware can walk known structure)</li></ul></li></ul><p><img src="https://i.imgur.com/9bSULQI.png" alt=""></p><ul><li><p>Multilevel Pagetable Translation</p><ul><li><p>Page directory and page tables</p><table><thead><tr><th></th><th>0x0</th><th>0x1</th><th>…</th><th>0xE</th><th>0xF</th></tr></thead><tbody><tr><td>Page directory</td><td>0x3</td><td>-</td><td>…</td><td>-</td><td>0x92</td></tr><tr><td>PT @PPN 0x3</td><td>0x10</td><td>0x23</td><td>…</td><td>-</td><td>-</td></tr><tr><td>PT @PPN 0x92</td><td>-</td><td>-</td><td>…</td><td>0x55</td><td>0x45</td></tr></tbody></table></li><li><p>Address layout</p><table><thead><tr><th>outer page (4)</th><th>inner page (4)</th><th>page offset (12)</th></tr></thead><tbody></tbody></table></li></ul><ol><li><p>Translate 0x01ABC</p><ul><li>Outer page = 0x0 =&gt; Use page table at 0x3</li><li>Inner page = 0x1 =&gt; PPN = 0x23</li><li>Physical address = 0x23ABC</li></ul></li><li><p>Translate 0xFEED0</p><ul><li>Outer page = 0xF =&gt; Use page table at 0x92</li><li>Inner page = 0xE =&gt; PPN = 0x55</li><li>Physical address = 0x55ED0</li></ul></li></ol></li><li><p>Address Format for Multilevel Paging</p><ul><li>Given 30-bit address with 4KB page size</li><li>#bits for page offset = log(4K) = 12</li><li>4 bytes per PTE =&gt; 1K entries per page =&gt; #bits for inner page = log(1K) = 10</li><li>#bits for outer page = 30 - 10 - 12 = 8</li></ul></li><li><p>Pagetable with 3 levels</p><ul><li><p>Problem</p><ul><li>Page directories (outer level) may not fit in a page</li></ul></li><li><p>Solution</p><ul><li>Split page directories into pieces</li><li>Use another page dir to refer to the page dir pieces.</li></ul></li><li><p>Memory Addressability Comparison</p><ul><li>1 level = 2<sup>10</sup> * 2<sup>12</sup> = 4MB</li><li>2 level = (2<sup>10</sup>)<sup>2</sup> * 2<sup>12</sup> = 4GB</li><li>3 level = (2<sup>10</sup>)<sup>3</sup> * 2<sup>12</sup> = 4TB</li></ul></li></ul></li><li><p>Quiz: Count Memory Access</p><ul><li><p>Assumption</p><ul><li>3-level page table</li><li>256-byte pages</li><li>16-bit addresses</li><li>ASIC of current process is 211</li></ul></li><li><p>TLB</p><table><thead><tr><th>ASID</th><th>VPN</th><th>PFN</th><th>Valid</th></tr></thead><tbody><tr><td>211</td><td>0xbb</td><td>0x91</td><td>1</td></tr><tr><td>211</td><td>0xff</td><td>0x23</td><td>1</td></tr><tr><td>122</td><td>0x05</td><td>0x91</td><td>1</td></tr><tr><td>211</td><td>0x05</td><td>0x12</td><td>0</td></tr></tbody></table></li></ul><ol><li><p>0xAA10: movl 0x1111, %edi</p><ul><li><p>TLB miss for 0xAA10 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p></li><li><p>TLB miss for 0x1111 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p></li><li><p>Total: 4 memory accesses</p></li></ul></li><li><p>0xBB13: addl $0x3, %edi</p><ul><li>TLB hit for 0xBB13 =&gt; 1 access more to get the instruction</li></ul></li><li><p>0x0519: movl %edi, 0xFF10</p><ul><li><p>TLB miss for 0x0519 =&gt; 3 memory access for page table + 1 more to get the instruction</p></li><li><p>TLB hit for 0xFF10 =&gt; 1 access more to get the instruction</p></li><li><p>Total: 5 memory accesses</p></li></ul></li></ol></li></ul><h3 id="inverted-page-table"><a class="markdownIt-Anchor" href="#inverted-page-table"></a> Inverted Page Table</h3><ul><li><p>Only need entries for virtual pages w/ valid physical mappings</p></li><li><p>Naïve approach:</p><ul><li>Search through data structure &lt;ppn, vpn+asid&gt; to find match</li><li>Too much time to search entire table</li></ul></li><li><p>Better:</p><ul><li>Find possible matches entries by hashing vpn+asid</li><li>Smaller number of entries to search for exact match</li></ul></li><li><p>Managing inverted page table requires software-controlled TLB</p></li></ul><h2 id="swapping"><a class="markdownIt-Anchor" href="#swapping"></a> Swapping</h2><h3 id="motivation-2"><a class="markdownIt-Anchor" href="#motivation-2"></a> Motivation</h3><ul><li>Support processes when not enough physical memory</li><li>Single process with very large address space</li><li>Multiple processes with combined address spaces</li></ul><h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3><ul><li><p>OS keeps unreferenced pages on disk</p><ul><li>Slower, cheaper backing store than memory</li></ul></li><li><p>Process can run when not all pages are loaded into main memory</p></li><li><p>OS and hardware cooperate to make large disk seem like memory</p><ul><li>Same behavior as if all of address space in main memory</li></ul></li></ul><h3 id="locality-of-reference"><a class="markdownIt-Anchor" href="#locality-of-reference"></a> Locality of Reference</h3><ul><li><p>Leverage locality of reference within processes</p><ul><li>Spatial: reference memory addresses near previously referenced addresses</li><li>Temporal: reference memory addresses that have referenced in the past</li><li>Processes spend majority of time in small portion of code</li></ul></li><li><p>Implication:</p><ul><li>Process only uses small amount of address space at any moment</li><li>Only small amount of address space must be resident in physical memory</li></ul></li><li><p>Memory Hierarchy</p><p><img src="https://i.imgur.com/pi58bfR.png" alt=""></p></li></ul><h3 id="mechanism-2"><a class="markdownIt-Anchor" href="#mechanism-2"></a> Mechanism</h3><ul><li><p>Each page in virtual address space maps to one of three locations:</p><ul><li>Physical main memory: Small, fast, expensive</li><li>Disk (backing store): Large, slow, cheap</li><li>Nothing (error): Free</li></ul></li><li><p>Extend page tables with an extra bit: present</p><ul><li>permissions (r/w), valid, present</li><li>Page in memory: present bit set in PTE</li><li>Page on disk: present bit cleared<ul><li>PTE points to block on disk</li><li>Causes trap into OS when page is referenced</li></ul></li></ul></li><li><p>Procedure</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hardware checks TLB</span><br><span class="line"><span class="keyword">if</span> TLB hit</span><br><span class="line">    address translation is done</span><br><span class="line">    page in physical memory</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB miss</span></span><br><span class="line">    Hardware <span class="keyword">or</span> OS walk page tables</span><br><span class="line">    <span class="keyword">if</span> PTE designates page is present</span><br><span class="line">        page in physical memory (i.e., present bit is cleared)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// page fault</span></span><br><span class="line">        Trap into OS (<span class="keyword">not</span> handled by hardware)</span><br><span class="line">        OS selects victim page in memory to replace</span><br><span class="line">        <span class="keyword">if</span> victim page is modified</span><br><span class="line">            write victim page out to disk</span><br><span class="line">        OS reads referenced page from disk into memory</span><br><span class="line">        Page table is updated, present bit is <span class="built_in">set</span></span><br><span class="line">        Process continues execution</span><br></pre></td></tr></table></figure></li></ul><h3 id="policy-page-selection"><a class="markdownIt-Anchor" href="#policy-page-selection"></a> Policy: Page selection</h3><ul><li><p>When should a page on disk be brought into memory?</p></li><li><p>Demand paging: Load page only when page fault occurs</p><ul><li>Intuition: Wait until page must absolutely be in memory</li><li>When process starts: No pages are loaded in memory</li><li>Problems: Pay cost of page fault for every newly accessed page</li></ul></li><li><p>Prepaging (anticipatory, prefetching): Load page before referenced</p><ul><li>OS predicts future accesses (oracle) and brings pages into memory early</li><li>Works well for some access patterns (e.g., sequential)</li></ul></li><li><p>Hints: Combine above with user-supplied hints about page references</p><ul><li>User specifies: may need page in future, don’t need this page anymore, or sequential access pattern, …</li><li>Example: madvise() in Unix</li></ul></li></ul><h3 id="policy-page-replacement"><a class="markdownIt-Anchor" href="#policy-page-replacement"></a> Policy: Page replacement</h3><ul><li><p>Which resident page in memory should be thrown out to disk?</p></li><li><p>OPT: Replace page not used for longest time in future</p><ul><li>Advantages: Guaranteed to minimize number of page faults</li><li>Disadvantages: Requires that OS predict the future; Not practical, but good for comparison</li></ul></li><li><p>FIFO: Replace page that has been in memory the longest</p><ul><li>Intuition: First referenced long time ago, done with it now</li><li>Advantages: Fair: All pages receive equal residency; Easy to implement</li><li>Disadvantage: Some pages may always be needed</li></ul></li><li><p>LRU: Replace page not used for longest time in past</p><ul><li>Intuition: Use past to predict the future</li><li>Advantages: With locality, LRU approximates OPT</li><li>Disadvantages: Harder to implement and does not handle all workloads well</li></ul></li><li><p>Comparison</p><table><thead><tr><th>LRU, OPT</th><th>FIFO</th></tr></thead><tbody><tr><td>Guaranteed to  have fewer page faults<br>Smaller memory sizes ⊆ larger memory sizes<br>Smaller cache ⊆ bigger cache</td><td>Usually have fewer page faults <br>May actually have more page faults!</td></tr></tbody></table></li></ul><h3 id="implementing-lru"><a class="markdownIt-Anchor" href="#implementing-lru"></a> Implementing LRU</h3><ul><li><p>Software Perfect LRU</p><ul><li>OS maintains ordered list of physical pages by reference time</li><li>When page is referenced: Move page to front of list</li><li>When need victim: Pick page at back of list</li><li>Trade-off: Slow on memory reference, fast on replacement</li></ul></li><li><p>Hardware Perfect LRU</p><ul><li>Associate timestamp register with each page</li><li>When page is referenced: Store system clock in register</li><li>When need victim: Scan through registers to find oldest clock</li><li>Trade-off: Fast on memory reference, slow on replacement (especially as size of memory grows)</li></ul></li><li><p>Approximating LRU: Clock Algorithm</p><ul><li><p>Hardware</p><ul><li>Keep use (or reference) bit for each page frame</li><li>When page is referenced: set use bit (page was used recently)</li></ul></li><li><p>Operating System</p><ul><li>Page replacement: Look for page with use bit cleared (has not been referenced for a while)</li></ul><ol><li>Keep pointer to last examined page frame</li><li>Traverse pages in circular buffer</li><li>Clear use bits as search</li><li>Stop when find page with already cleared use bit, replace this page</li></ol></li></ul></li></ul><img src="https://i.imgur.com/WYNCIhZ.png" style="margin:auto; display: block;"><h2 id="summary-3"><a class="markdownIt-Anchor" href="#summary-3"></a> Summary</h2><ul><li><p>Abstraction: Virtual address space with code, heap, stack</p></li><li><p>Address translation</p><ul><li>Contiguous memory: base, bounds, segmentation</li><li>Using fixed sizes pages with page tables</li></ul></li><li><p>Challenges with paging</p><ul><li>Extra memory references: avoid with TLB</li><li>Page table size: avoid with multi-level paging, inverted page tables etc.</li></ul></li><li><p>Larger address spaces: Swapping mechanisms, policies (LRU, Clock)</p></li></ul><h1 id="concurrency"><a class="markdownIt-Anchor" href="#concurrency"></a> Concurrency</h1><h2 id="thread-2"><a class="markdownIt-Anchor" href="#thread-2"></a> Thread</h2><h3 id="processes-vs-thread"><a class="markdownIt-Anchor" href="#processes-vs-thread"></a> Processes vs Thread</h3><ul><li><p>Process</p><ul><li>Example: Chrome (process per tab)</li><li>Communicate via pipe() or similar</li><li>Pros: Don’t need new abstractions; good for security</li><li>Cons:<ul><li>Cumbersome programming</li><li>High communication overheads</li><li>Expensive context switching</li></ul></li></ul></li><li><p>Thread</p><ul><li>Multiple threads of same process share an address space</li><li>Divide large task across several cooperative threads</li><li>Communicate through shared address space</li><li>Shared: page directories, page tables, code segment</li><li>Not Shared: instruction pointer, stack</li></ul></li><li><p>Multiple threads within a single process share:</p><ul><li>Process ID (PID)</li><li>Address space: Code (instructions), Most data (heap)</li><li>Open file descriptors</li><li>Current working directory</li><li>User and group id</li></ul></li><li><p>Each thread has its own</p><ul><li>Thread ID (TID)</li><li>Set of registers, including Program counter and Stack pointer</li><li>Stack for local variables and return addresses (in same address space)</li></ul></li></ul><p><img src="https://i.imgur.com/3DmuMbX.png" alt=""></p><h3 id="common-programming-models"><a class="markdownIt-Anchor" href="#common-programming-models"></a> Common Programming Models</h3><ul><li><p>Producer/consumer</p><ul><li>Multiple producer threads create data (or work) that is handled by one of the multiple consumer threads</li></ul></li><li><p>Pipeline</p><ul><li>Task is divided into series of subtasks, each of which is handled in series by a different thread</li></ul></li><li><p>Defer work with background thread</p><ul><li>One thread performs non-critical work in the background (when CPU idle)</li></ul></li></ul><h3 id="user-level-threads-many-to-one"><a class="markdownIt-Anchor" href="#user-level-threads-many-to-one"></a> User-level threads: Many-to-one</h3><ul><li><p>Idea</p><ul><li>Implemented by user-level runtime libraries</li><li>Create, schedule, synchronize threads at user-level</li><li>OS is not aware of user-level threads</li><li>OS thinks each process contains only a single thread of control</li></ul></li><li><p>Advantages</p><ul><li>Does not require OS support; Portable</li><li>Can tune scheduling policy to meet application demands</li><li>Lower overhead thread operations since no system call</li></ul></li><li><p>Disadvantages</p><ul><li>Cannot leverage multiprocessors</li><li>Entire process blocks when one thread blocks</li></ul></li></ul><img src="https://i.imgur.com/usa8UOF.png" width="50%" style="margin:auto; display: block;"><h3 id="kernel-level-threads-one-to-one"><a class="markdownIt-Anchor" href="#kernel-level-threads-one-to-one"></a> Kernel-level threads: One-to-one</h3><ul><li><p>Idea</p><ul><li>OS provides each user-level thread with a kernel thread</li><li>Each kernel thread scheduled independently</li><li>Thread operations (creation, scheduling, synchronization) performed by OS</li></ul></li><li><p>Advantages</p><ul><li>Each kernel-level thread can run in parallel on a multiprocessor</li><li>When one thread blocks, other threads from process can be scheduled</li></ul></li><li><p>Disadvantages</p><ul><li>Higher overhead for thread operations</li><li>OS must scale well with increasing number of threads</li></ul></li></ul> <img src="https://i.imgur.com/NVLmaXh.png" width="50%" style="margin:auto; display: block;"><h3 id="thread-schedule-examples"><a class="markdownIt-Anchor" href="#thread-schedule-examples"></a> Thread Schedule Examples</h3><ul><li><p>Assume <code>M[0x123]</code> = 100 initially, and we want to increment it by 1 twice</p></li><li><p>Example 1</p><table><thead><tr><th>Thread 1</th><th>Thread 2</th></tr></thead><tbody><tr><td><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br><br><br><br></td><td><br><br><br><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 102<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 102</td></tr></tbody></table></li><li><p>Example 2</p><table><thead><tr><th>Thread 1</th><th>Thread 2</th></tr></thead><tbody><tr><td><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br><br><br><br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br></td><td><br><code>mov 0x123, %eax</code> =&gt; <code>%eax</code> = 100<br> <code>add $0x1, %eax</code> =&gt; <code>%eax</code> = 101<br> <code>mov %eax, 0x123</code> =&gt;<code>M[0x123]</code> = 101<br><br><br></td></tr></tbody></table></li></ul><h3 id="non-determinism"><a class="markdownIt-Anchor" href="#non-determinism"></a> Non-Determinism</h3><ul><li><p>Concurrency leads to non-deterministic results</p><ul><li>Different results even with same inputs</li><li>race conditions</li></ul></li><li><p>Whether bug manifests depends on CPU schedule!</p></li><li><p>How to program: imagine scheduler is malicious?!</p></li></ul><h3 id="what-do-we-want"><a class="markdownIt-Anchor" href="#what-do-we-want"></a> What do we want?</h3><ul><li><p>Want 3 instructions to execute as an uninterruptable group</p></li><li><p>That is, we want them to be atomic</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x123, %eax </span><br><span class="line">add $0x1, %eax  </span><br><span class="line">mov %eax, 0x123</span><br></pre></td></tr></table></figure></li><li><p>More general: Need mutual exclusion for critical sections</p><ul><li>if thread A is in critical section C, thread B isn’t</li><li>(okay if other threads do unrelated work)</li></ul></li></ul><h3 id="synchronization"><a class="markdownIt-Anchor" href="#synchronization"></a> Synchronization</h3><ul><li>Build higher-level synchronization primitives in OS</li><li>Operations that ensure correct ordering of instructions across threads</li><li>Use help from hardware</li></ul><h3 id="concurrency-objective"><a class="markdownIt-Anchor" href="#concurrency-objective"></a> Concurrency Objective</h3><ul><li><p>Mutual exclusion (e.g., A and B don’t run at same time)</p><ul><li>solved with locks</li></ul></li><li><p>Ordering (e.g., B runs after A does something)</p><ul><li>solved with condition variables and semaphores</li></ul></li></ul><h3 id="summary-4"><a class="markdownIt-Anchor" href="#summary-4"></a> Summary</h3><ul><li>Concurrency is needed for high performance when using multiple cores</li><li>Threads are multiple execution streams within a single process or address space (share PID and address space, own registers and stack)</li><li>Context switches within a critical section can lead to non-deterministic bugs</li></ul><h2 id="locks"><a class="markdownIt-Anchor" href="#locks"></a> Locks</h2><h3 id="introduction-3"><a class="markdownIt-Anchor" href="#introduction-3"></a> Introduction</h3><ul><li><p>Goal: Provide mutual exclusion (mutex)</p></li><li><p>Atomic operation: No other instructions can be interleaved</p></li></ul><ol><li><p>Allocate and Initialize</p><ul><li><figure class="highlight plain"><figcaption><span>mylock </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">2. Acquire</span><br><span class="line">    - Acquire exclusion access to lock;</span><br><span class="line">    - Wait if lock is not available (some other process in critical section)</span><br><span class="line">    - Spin or block (relinquish CPU) while waiting</span><br><span class="line">    - ```Pthread_mutex_lock(&amp;mylock);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Release</p><ul><li>Release exclusive access to lock; let another process enter critical section</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Implementation Goals</span><br><span class="line">- Correctness</span><br><span class="line">    - Mutual exclusion</span><br><span class="line">        - Only one thread in critical section at a time</span><br><span class="line">    - Progress (deadlock-free) </span><br><span class="line">        - If several simultaneous requests, must allow one to proceed</span><br><span class="line">        - Deadlock happens when all threads are waiting for lock</span><br><span class="line"></span><br><span class="line">    - Bounded (starvation-free)</span><br><span class="line">        - Must eventually allow each waiting thread to enter</span><br><span class="line">        - The waiting time for lock is bounded</span><br><span class="line"></span><br><span class="line">- Fairness: Each thread waits for same amount of time</span><br><span class="line">- Performance: CPU is not used unnecessarily</span><br><span class="line"></span><br><span class="line">### Spin Lock with Interrupts</span><br><span class="line">- Idea</span><br><span class="line">    - Turn off interrupts for critical sections</span><br><span class="line">    - Prevent dispatcher from running another thread</span><br><span class="line">    - Code between interrupts executes atomically</span><br><span class="line"></span><br><span class="line">- Implementation code</span><br><span class="line">    ```c=</span><br><span class="line">    void acquire(lockT *l) &#123;</span><br><span class="line">        disableInterrupts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void release(lockT *l)  &#123; </span><br><span class="line">        enableInterrupts(); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>Disadvantages<ul><li>Only works on uniprocessors</li><li>Process can keep control of CPU for arbitrary length</li><li>Cannot perform other necessary work</li></ul></li></ul><h3 id="spin-lock-with-load-store"><a class="markdownIt-Anchor" href="#spin-lock-with-load-store"></a> Spin Lock with Load + Store</h3><ul><li><p>Idea: uses a single <strong>shared</strong> lock variable</p></li><li><p>Implementation code</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared variable </span></span><br><span class="line">boolean lock = <span class="literal">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(Boolean *lock)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (*lock) <span class="comment">/* wait */</span> ; </span><br><span class="line">    *lock = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Boolean *lock)</span> </span>&#123; </span><br><span class="line">    *lock = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Race condition</p><table><thead><tr><th>Thread 1</th><th>Thread 2</th></tr></thead><tbody><tr><td><code>while (*lock)</code><br><br><br> <code>lock = true;</code></td><td><br><code>while (*lock)</code> <br> <code>*lock = true;</code><br><br></td></tr></tbody></table><ul><li>Both threads grab lock!</li><li>Problem: Testing lock and setting lock are not atomic</li></ul></li></ul><h3 id="spin-lock-with-xchg"><a class="markdownIt-Anchor" href="#spin-lock-with-xchg"></a> Spin Lock with xchg</h3><ul><li><p>xchg: Atomic exchange or test-and-set</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return what was pointed to by addr</span></span><br><span class="line"><span class="comment">// at the same time, store newval into addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *addr;</span><br><span class="line">    *addr = newval;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implementation code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; <span class="comment">// 0 =&gt; unlocked; 1 =&gt; locked</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit loop when flag changed from 0 (unlocked) to 1 (locked)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; <span class="comment">// set the flag to 0 (unlocked)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="spin-lock-with-cas"><a class="markdownIt-Anchor" href="#spin-lock-with-cas"></a> Spin Lock with CAS</h3><ul><li><p>CAS: Compare and Swap</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomic instruction</span></span><br><span class="line"><span class="comment">// set newval to *addr when *addr == expected</span></span><br><span class="line"><span class="comment">// return what was pointed to by addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> expected, <span class="keyword">int</span> newval)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> actual = *addr; </span><br><span class="line">    <span class="keyword">if</span> (actual == expected)  </span><br><span class="line">        *addr = newval; </span><br><span class="line">    <span class="keyword">return</span> actual; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implementation code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// spin-wait (do nothing)  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Exercise with xchg and CAS</p><ul><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = xchg(&amp;a, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> c = CompareAndSwap(&amp;b, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> d = CompareAndSwap(&amp;b, <span class="number">1</span>, <span class="number">3</span>) ;</span><br></pre></td></tr></table></figure></li><li><p>Result:</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td></tr><tr><td>2</td><td>1</td><td></td><td></td></tr><tr><td>2</td><td>1</td><td>1</td><td></td></tr><tr><td>2</td><td>3</td><td>1</td><td>1</td></tr></tbody></table></li></ul></li></ul><h3 id="ticket-locks"><a class="markdownIt-Anchor" href="#ticket-locks"></a> Ticket Locks</h3><ul><li><p>Basic spinlocks are unfair</p><p><img src="https://i.imgur.com/l2lu5Vn.png" alt=""></p><ul><li>Scheduler is unaware of locks/unlocks!</li></ul></li><li><p>Introduction to Ticket Locks</p><ul><li><p>Idea: reserve each thread’s turn to use a lock.</p></li><li><p>Each thread spins until their turn.</p></li><li><p>Use new atomic primitive, fetch-and-add</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> old = *ptr; </span><br><span class="line">    *ptr = old + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> old; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Acquire: Grab ticket; Spin while not thread’s ticket != turn</p></li><li><p>Release: Advance to next turn</p></li></ul></li><li><p>Example</p><table><thead><tr><th>Time</th><th>Event</th><th>ticket</th><th>Turn</th><th>Result</th></tr></thead><tbody><tr><td>1</td><td>A <code>lock()</code></td><td>0</td><td>0</td><td>A runs</td></tr><tr><td>2</td><td>B <code>lock()</code></td><td>1</td><td></td><td>B spins until turn = 1</td></tr><tr><td>3</td><td>C <code>lock()</code></td><td>2</td><td></td><td>C spins until turn = 2</td></tr><tr><td>4</td><td>A <code>unlock()</code></td><td></td><td>1</td><td>B runs</td></tr><tr><td>5</td><td>A <code>lock()</code></td><td>3</td><td></td><td>A spins until turn = 3</td></tr><tr><td>6</td><td>B <code>unlock()</code></td><td></td><td>2</td><td>C runs</td></tr><tr><td>7</td><td>C <code>unlock()</code></td><td></td><td>3</td><td>A runs</td></tr><tr><td>8</td><td>A <code>unlock()</code></td><td></td><td>4</td><td></td></tr></tbody></table></li><li><p>Ticket Lock Implementation</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> ticket; </span><br><span class="line">    <span class="keyword">int</span> turn; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn); <span class="comment">// spin</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ticket-lock-with-yield"><a class="markdownIt-Anchor" href="#ticket-lock-with-yield"></a> Ticket Lock with Yield</h3><ul><li><p>Spinlock Performance</p><ul><li><p>Fast when…</p><ul><li>many CPUs</li><li>locks held a short time</li><li>advantage: avoid context switch</li></ul></li><li><p>Slow when…</p><ul><li>one CPU</li><li>locks held a long time</li><li>disadvantage: spinning is wasteful</li></ul></li></ul></li><li><p>CPU Scheduler is Ignorant</p><ul><li>CPU scheduler may run B, C, D instead of A even though B, C, D are waiting for A</li></ul></li></ul><p><img src="https://i.imgur.com/Avi05dZ.png" alt=""></p><ul><li><p>Ticket Locks with Yield</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> ticket; </span><br><span class="line">    <span class="keyword">int</span> turn; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn) &#123;</span><br><span class="line">        yield(); <span class="comment">// yield instead of spin</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Yield instead of Spin</p></li></ul><p><img src="https://i.imgur.com/cXfmvjp.png" alt=""></p><ul><li>Time Comparison: Yield vs Spin<ul><li><p>Assumption</p><ul><li>Round robin scheduling, 10ms time slice</li><li>Process A, B, C, D, E, F, G, H, I, J in the system</li></ul></li><li><p>Timeline</p><ul><li>A: lock() … compute … unlock()</li><li>B: lock() … compute … unlock()</li><li>…</li><li>J: lock() … compute … unlock()</li><li>A: lock() … compute … unlock()</li><li>…</li></ul></li><li><p>If A’s compute is 20ms long, starting at t = 0, when does B get lock with spin ?</p><ul><li><p>110 ms</p><table><thead><tr><th>A…J</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>100</td><td>10</td><td></td></tr></tbody></table></li></ul></li><li><p>If B’s compute is 30ms long, when does C get lock with spin ?</p><ul><li><p>320 ms</p><table><thead><tr><th>A…J</th><th>A…J</th><th>A…J</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>100</td><td>100</td><td>100</td><td>10</td><td>10</td><td></td></tr></tbody></table></li></ul></li><li><p>If context switch time = 1ms, when does B get lock with yield ?</p><ul><li>29 ms</li><li><table><thead><tr><th>A</th><th>B…J</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>10</td><td>9</td><td>10</td><td></td></tr></tbody></table></li></ul></li></ul></li></ul><h3 id="queue-lock"><a class="markdownIt-Anchor" href="#queue-lock"></a> Queue Lock</h3><ul><li><p>Motivation</p><ul><li><p>Time complexity of spinlock</p><ul><li>Without yield: O(threads * time_slice)</li><li>With yield: O(threads * context_switch)</li></ul></li><li><p>Even with yield, spinning is slow with high thread contention</p></li></ul></li><li><p>Idea</p><ul><li>Block and put thread on waiting queue instead of spinning</li><li>Remove waiting threads from scheduler ready queue</li><li>(e.g., <code>park()</code> and <code>unpark(threadID)</code>)</li><li>Scheduler runs any thread that is ready</li></ul></li><li><p>Example</p><ul><li><p>Assumption</p><ul><li>A &amp; C has 60ms of work</li><li>A, B, D contend for lock</li><li>C not contending</li><li>Context switch + yield takes 5ms</li></ul></li><li><p>Timeline</p><table><thead><tr><th>Time</th><th>Event</th><th>Running</th><th>Runnable</th><th>Waiting</th></tr></thead><tbody><tr><td>Initial</td><td></td><td></td><td>A, B, C, D</td><td></td></tr><tr><td>0-20</td><td>A scheduled</td><td>A</td><td>B, C, D</td><td></td></tr><tr><td>20-25</td><td>B scheduled &amp; blocked</td><td></td><td>C, D, A</td><td>B</td></tr><tr><td>25-45</td><td>C scheduled</td><td>C</td><td>D, A</td><td>B</td></tr><tr><td>45-50</td><td>D scheduled &amp; blocked</td><td></td><td>A, C</td><td>B, D</td></tr><tr><td>50-70</td><td>A scheduled</td><td>A</td><td>C</td><td>B, D</td></tr><tr><td>70-90</td><td>C scheduled</td><td>C</td><td>A</td><td>B, D</td></tr><tr><td>90-110</td><td>A scheduled &amp; finished</td><td>A</td><td>C</td><td>B, D</td></tr><tr><td>110-130</td><td>C scheduled &amp; finished</td><td>C</td><td>B</td><td>D</td></tr><tr><td>130-150</td><td>B scheduled &amp; finished</td><td>B</td><td>D</td><td></td></tr><tr><td>150-170</td><td>D scheduled &amp; finished</td><td>D</td><td></td><td></td></tr></tbody></table></li></ul></li><li><p>Incorrect Implementation</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> guard = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">queue_t</span> q;</span><br><span class="line">&#125; LockT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Grab guard</span></span><br><span class="line"><span class="comment">// 2. If lock is held, add to queue and park</span></span><br><span class="line"><span class="comment">// 3. If lock is not held, grab the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;lock) &#123; </span><br><span class="line">        qadd(l-&gt;q, tid); </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">        park();     <span class="comment">// blocked  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        l-&gt;lock = <span class="literal">true</span>; </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Grab guard</span></span><br><span class="line"><span class="comment">// 2. If queue is empty, release hte lock</span></span><br><span class="line"><span class="comment">// 3. If the queue is not empty, unpark head of queue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (qempty(l-&gt;q))</span><br><span class="line">        l-&gt;lock=<span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(qremove(l-&gt;q));  </span><br><span class="line">    l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Questions and Answers</p><ul><li><p>Why is guard used?<br>To ensure queue operations is thread safe</p></li><li><p>Why OK to spin on guard?<br>Very shhort critical section</p></li><li><p>In release(), why not set <code>lock = false</code> when unpark?<br><code>lock == true</code> is passed from one thread to the next</p></li></ul></li><li><p>Race Condition for Previous Implementation</p><table><thead><tr><th>Thread 1 (in lock)</th><th>Thread 2 (in unlock)</th></tr></thead><tbody><tr><td>if (l-&gt;lock) {<br> qadd(l-&gt;q, tid); <br> l-&gt;guard = false; <br> <br> <br> <br><br>  park()</td><td><br> <br> <br> while (TAS(&amp;l-&gt;guard, true)); <br> if (qempty(l-&gt;q)) // false!!  <br> else unpark(qremove(l-&gt;q)); <br> l-&gt;guard = false;   <br> <br></td></tr></tbody></table></li><li><p>Correct Implementation</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> guard = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">queue_t</span> q;</span><br><span class="line">&#125; LockT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;lock) &#123; </span><br><span class="line">        qadd(l-&gt;q, tid); </span><br><span class="line">        setpark(pid); <span class="comment">// notify of plan</span></span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">        park();     <span class="comment">// blocked  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        l-&gt;lock = <span class="literal">true</span>; </span><br><span class="line">        l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LockT *l)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (XCHG(&amp;l-&gt;guard, <span class="literal">true</span>)); </span><br><span class="line">    <span class="keyword">if</span> (qempty(l-&gt;q))</span><br><span class="line">        l-&gt;lock=<span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(qremove(l-&gt;q));  </span><br><span class="line">    l-&gt;guard = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Time Comparison: Yield vs Blocking</p><ul><li><p>Assumption</p><ul><li>Round robin scheduling, 10ms time slice</li><li>Process A, B, C, D, E, F, G, H, I, J in the system</li><li>Context switch takes 1ms</li></ul></li><li><p>Timeline</p><ul><li>A: lock() … compute … unlock()</li><li>B: lock() … compute … unlock()</li><li>…</li><li>J: lock() … compute … unlock()</li><li>A: lock() … compute … unlock()</li><li>…</li></ul></li><li><p>If A’s compute is 30ms long, starting at t = 0, when does B get lock with yield?</p><ul><li><p>48 ms</p><table><thead><tr><th>A</th><th>B…J</th><th>A</th><th>B…J</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>10</td><td>9</td><td>10</td><td>9</td><td>10</td><td></td></tr></tbody></table></li></ul></li><li><p>If A’s compute is 30ms long, starting at t = 0, when does B get lock with blocking?</p><ul><li><p>39 ms</p><table><thead><tr><th>A</th><th>B…J</th><th>A</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>10</td><td>9</td><td>10</td><td>10</td><td></td></tr></tbody></table></li></ul></li></ul></li></ul><h3 id="queue-lock-vs-spin-lock"><a class="markdownIt-Anchor" href="#queue-lock-vs-spin-lock"></a> Queue Lock vs Spin Lock</h3><ul><li><p>Each approach is better under different circumstances</p></li><li><p>Uniprocessor</p><ul><li>Waiting process is scheduled à Process holding lock isn’t</li><li>Waiting process should always relinquish processor</li><li>Associate queue of waiters with each lock (as in previous implementation)</li></ul></li><li><p>Multiprocessor</p><ul><li>Waiting process is scheduled -&gt; Process holding lock might be</li><li>Spin or block depends on how long, t, before lock is released<ul><li>Lock released quickly -&gt; Spin-wait</li><li>Lock released slowly -&gt; Block</li><li>Quick and slow are relative to context-switch cost, C</li></ul></li></ul></li></ul><h2 id="condition-variables"><a class="markdownIt-Anchor" href="#condition-variables"></a> Condition Variables</h2><h3 id="ordering"><a class="markdownIt-Anchor" href="#ordering"></a> Ordering</h3><ul><li><p>Idea: Thread A runs after Thread B does something</p></li><li><p>Example: Join</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> p1, p2; </span><br><span class="line">Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>); </span><br><span class="line">Pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>); </span><br><span class="line"><span class="comment">// join waits for the threads to finish </span></span><br><span class="line">Pthread_join(p1, <span class="literal">NULL</span>); </span><br><span class="line">Pthread_join(p2, <span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="condition-variables-2"><a class="markdownIt-Anchor" href="#condition-variables-2"></a> Condition Variables</h3><ul><li><p>Condition Variable: queue of waiting threads</p></li><li><p>B waits for a signal on CV before running: <code>wait(CV, …)</code></p></li><li><p>A sends signal to CV when time for B to run: <code>signal(CV, …)</code></p></li><li><p><code>wait(cond_t *cv, mutex_t *lock)</code></p><ul><li>assumes the lock is held when wait() is called</li><li>puts caller to sleep + releases the lock (atomically)</li><li>when awoken, reacquires lock before returning</li></ul></li><li><p><code>signal(cond_t *cv)</code></p><ul><li>wake a single waiting thread (if &gt;= 1 thread is waiting)</li><li>if there is no waiting thread, just return, doing nothing</li></ul></li></ul><h3 id="join-attempt-1-no-state"><a class="markdownIt-Anchor" href="#join-attempt-1-no-state"></a> Join Attempt 1: No State</h3><ul><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);     <span class="comment">// x </span></span><br><span class="line">   Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);   <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a </span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// b </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// c </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Intended schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>Parent</td><td>x</td><td>y</td><td></td><td></td><td></td><td>z</td></tr><tr><td>Child</td><td></td><td></td><td>a</td><td>b</td><td>c</td><td></td></tr></tbody></table></li><li><p>Broken schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Parent</td><td></td><td></td><td></td><td>x</td><td>y</td></tr><tr><td>Child</td><td>a</td><td>b</td><td>c</td><td></td><td></td></tr></tbody></table><ul><li>Parent is stuck because nobody will call signal</li></ul></li><li><p>Rule of Thumb 1</p><ul><li>Keep state in addition to CV’s</li><li>CV’s are used to signal threads when state changes</li><li>If state is already as needed, thread doesn’t wait for a signal!</li></ul></li></ul><h3 id="join-attempt-2-no-mutex-lock"><a class="markdownIt-Anchor" href="#join-attempt-2-no-mutex-lock"></a> Join Attempt 2: No Mutex Lock</h3><ul><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="comment">// If the child process already finished executing</span></span><br><span class="line">   <span class="comment">// the parent process doesn't need to wait</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// a</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// b </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Intended schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>Parent</td><td></td><td></td><td>w</td><td>x</td><td>y</td><td>z</td></tr><tr><td>Child</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>Broken schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Parent</td><td>w</td><td>x</td><td></td><td></td><td>y</td></tr><tr><td>Child</td><td></td><td></td><td>a</td><td>b</td><td></td></tr></tbody></table><ul><li>Parent is stuck again</li></ul></li></ul><h3 id="join-attempt-3-state-mutex-lock"><a class="markdownIt-Anchor" href="#join-attempt-3-state-mutex-lock"></a> Join Attempt 3: State + Mutex Lock</h3><ul><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a</span></span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// b</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// c </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>Parent</td><td>w</td><td>x</td><td>y</td><td></td><td></td><td></td><td>z</td></tr><tr><td>Child</td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td></td></tr></tbody></table></li><li><p>Rule of Thumb 2</p><ul><li>Hold mutex lock while calling wait/signal</li><li>Ensures no race between interacting with state and wait/signal</li></ul></li></ul><h3 id="producerconsumer-problem"><a class="markdownIt-Anchor" href="#producerconsumer-problem"></a> Producer/Consumer Problem</h3><ul><li>Example: UNIX pipes<ul><li><p>A pipe may have many writers and readers</p></li><li><p>Internally, there is a finite-sized buffer</p></li><li><p>Writers add data to the buffer</p><ul><li>Writers have to wait if buffer is full</li></ul></li><li><p>Readers remove data from the buffer</p><ul><li>Readers have to wait if buffer is empty</li></ul></li><li><p>Implementation:</p><ul><li>reads/writes to buffer require locking</li><li>when buffers are full, writers must wait</li><li>when buffers are empty, readers must wait</li></ul></li></ul></li></ul><pre>               Start (consumer)               |     +---------v---------------------------+------+Buf: |         |          data             |      |     +---------+---------------------------^------+                                           |                                           End (producer)</pre><ul><li>Producer/Consumer Problem<ul><li><p>Producers generate data (like pipe writers)</p></li><li><p>Consumers grab data and process it (like pipe readers)</p></li><li><p>Producer/consumer problems are frequent in systems (e.g. web servers)</p></li><li><p>General strategy use condition variables to:</p><ul><li>make producers wait when buffers are full</li><li>make consumers wait when there is nothing to consume</li></ul></li></ul></li></ul><h3 id="pc-attempt-1-one-cv"><a class="markdownIt-Anchor" href="#pc-attempt-1-one-cv"></a> P/C Attempt 1: One CV</h3><ul><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Producer grabs the lock</span></span><br><span class="line"><span class="comment">// 2. Check whether the buffer is full. If so, wait.</span></span><br><span class="line"><span class="comment">// 3. Put something to the buffer</span></span><br><span class="line"><span class="comment">// 4. Signal consumers to read</span></span><br><span class="line"><span class="comment">// 5. Release the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == max)      <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;cond, &amp;m);  <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;cond);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Consumer grabs the lock</span></span><br><span class="line"><span class="comment">// 2. Check whether the buffer is empty. If so, wait.</span></span><br><span class="line"><span class="comment">// 3. Get the content from buffer and remove it.</span></span><br><span class="line"><span class="comment">// 4. Signal consumers to write</span></span><br><span class="line"><span class="comment">// 5. Release the lock</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == <span class="number">0</span>)       <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;cond, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;cond);     <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Broken schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>P</td><td></td><td></td><td></td><td></td><td></td><td></td><td>p1</td><td>p2</td><td>p4</td><td>p5</td><td>p6</td><td>p1</td><td>p2</td><td>p3</td><td></td><td></td></tr><tr><td>C1</td><td>c1</td><td>c2</td><td>c3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>C2</td><td></td><td></td><td></td><td>c1</td><td>c2</td><td>c3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>c4</td><td>c5</td></tr></tbody></table><ul><li>At time 16, Consumer 1 could signal Consumer 2 to wake up</li></ul></li></ul><h3 id="pc-attempt-2-two-cvs"><a class="markdownIt-Anchor" href="#pc-attempt-2-two-cvs"></a> P/C Attempt 2: Two CVs</h3><ul><li><p>How to wake the right thread? Use two condition variables</p></li><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == max)      <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;empty, &amp;m); <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;fill);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">if</span> (numfull == <span class="number">0</span>)       <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;fill, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;empty);    <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Broken schedule</p><table><thead><tr><th>Time</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>P</td><td></td><td></td><td></td><td>p1</td><td>p4</td><td>p5</td><td>p6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>C1</td><td>c1</td><td>c2</td><td>c3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>c4</td></tr><tr><td>C2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>c1</td><td>c4</td><td>c5</td><td>c6</td><td></td></tr></tbody></table><ul><li>At time 12, Consumer 1 wakes up but has nothing to read</li><li>Note: When <code>signal()</code> is called, the thread may not resume immediately</li></ul></li></ul><h3 id="pc-attempt-3-two-cvs-with-while"><a class="markdownIt-Anchor" href="#pc-attempt-3-two-cvs-with-while"></a> P/C Attempt 3: Two CVs with While</h3><ul><li><p>Idea: Recheck the shared variable is still in the state you want after waking up</p></li><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">while</span> (numfull == max)   <span class="comment">// p2</span></span><br><span class="line">      Cond_wait(&amp;empty, &amp;m); <span class="comment">// p3</span></span><br><span class="line">    do_fill(i);              <span class="comment">// p4</span></span><br><span class="line">    Cond_signal(&amp;fill);      <span class="comment">// p5</span></span><br><span class="line">    Mutex_unlock(&amp;m);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Mutex_lock(&amp;m);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">while</span> (numfull == <span class="number">0</span>)    <span class="comment">// c2</span></span><br><span class="line">      Cond_wait(&amp;fill, &amp;m); <span class="comment">// c3</span></span><br><span class="line">    <span class="keyword">int</span> tmp = do_get();     <span class="comment">// c4</span></span><br><span class="line">    Cond_signal(&amp;empty);    <span class="comment">// c5</span></span><br><span class="line">    Mutex_unlock(&amp;m);       <span class="comment">// c6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Rule of Thumb 3</p><ul><li>Whenever a lock is acquired, recheck assumptions about state!</li><li>Another thread could grab lock in between signal and wakeup from wait</li><li>Note that some libraries also have “spurious wakeups”</li><li>(may wake multiple waiting threads at signal or at any time)</li></ul></li></ul><h3 id="summary-5"><a class="markdownIt-Anchor" href="#summary-5"></a> Summary</h3><ul><li><p>Rules of Thumb for CVs</p><ol><li>Keep state in addition to CV’s</li><li>Always do wait/signal with lock held</li><li>Whenever thread wakes from waiting, recheck state</li></ol></li><li><p><code>wait(cond_t *cv, mutex_t *lock)</code></p><ul><li>assumes the lock is held when wait() is called</li><li>puts caller to sleep + releases the lock (atomically)</li><li>when awoken, reacquires lock before returning</li></ul></li><li><p><code>signal(cond_t *cv)</code></p><ul><li>wake a single waiting thread (if &gt;= 1 thread is waiting)</li><li>if there is no waiting thread, just return, doing nothing</li></ul></li></ul><h2 id="semaphores"><a class="markdownIt-Anchor" href="#semaphores"></a> Semaphores</h2><h3 id="introduction-4"><a class="markdownIt-Anchor" href="#introduction-4"></a> Introduction</h3><ul><li><p>Condition variables have no state (other than waiting queue)</p><ul><li>Programmer must track additional state</li></ul></li><li><p>Semaphores have state: track integer value</p><ul><li>State cannot be directly accessed by user program</li><li>But state determines behavior of semaphore operations</li></ul></li></ul><h3 id="semaphore-operations"><a class="markdownIt-Anchor" href="#semaphore-operations"></a> Semaphore Operations</h3><ul><li><p>Allocate and Initialize</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_init(<span class="keyword">sem_t</span> *s, <span class="keyword">int</span> initval) &#123;</span><br><span class="line">    s-&gt;value = initval; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>User cannot read or write value directly after initialization</li></ul></li><li><p>Wait or Test (sometime P() for Dutch) <code>sem_wait(sem_t*)</code></p><ul><li>Decrements sem value, Waits until value of sem is &gt;= 0</li></ul></li><li><p>Signal or Post (sometime V() for Dutch) <code>sem_post(sem_t*)</code></p><ul><li>Increment sem value, then wake a single waiter</li></ul></li></ul><h3 id="build-lock-from-semaphore"><a class="markdownIt-Anchor" href="#build-lock-from-semaphore"></a> Build Lock from Semaphore</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">sem_t</span> sem; </span><br><span class="line">&#125; <span class="keyword">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    sem_init(&amp;lock-&gt;sem, <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;lock-&gt;sem);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line">    sem_post(&amp;lock-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="join-with-cv-vs-semaphores"><a class="markdownIt-Anchor" href="#join-with-cv-vs-semaphores"></a> Join with CV vs Semaphores</h3><ul><li><p>Join with Condition Variable</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);         <span class="comment">// w</span></span><br><span class="line">   <span class="keyword">if</span> (done == <span class="number">0</span>)          <span class="comment">// x</span></span><br><span class="line">       Cond_wait(&amp;c, &amp;m);  <span class="comment">// y </span></span><br><span class="line">   Mutex_unlock(&amp;m);       <span class="comment">// z </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   Mutex_lock(&amp;m);    <span class="comment">// a</span></span><br><span class="line">   done = <span class="number">1</span>;          <span class="comment">// b</span></span><br><span class="line">   Cond_signal(&amp;c);   <span class="comment">// c </span></span><br><span class="line">   Mutex_unlock(&amp;m);  <span class="comment">// d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Join with Semaphores</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Join with Semaphores Example 1</p>  <pre>    s                       s                      s  +---+   parent wait()   +---+   child post()   +---+  | 0 |+----------------->| -1|+---------------->| 0 |  +---+                   +---+                  +---+                            ^                      ^                            |                      |                            Parent blocked         Parent resumes  </pre></li><li><p>Join with Semaphores Example 2</p>  <pre>    s                       s                      s  +---+   child post()    +---+  parent wait()   +---+  | 0 |+----------------->| 1 |+---------------->| 0 |  +---+                   +---+                  +---+  </pre></li></ul><h3 id="pc-1-producer-1-consumer-with-buffer-of-size-1"><a class="markdownIt-Anchor" href="#pc-1-producer-1-consumer-with-buffer-of-size-1"></a> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size 1</h3><ul><li><p>Use 2 semaphores</p><ul><li>emptyBuffer: Initialize to 1</li><li>fullBuffer: Initialize to 0</li></ul></li><li><p>Producer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer);</span><br><span class="line">    Fill(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer);</span><br><span class="line">    Use(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Example 1: Producer comes first</p><table><thead><tr><th>Time</th><th>Current Thread</th><th>emptyBuffer</th><th>fullBuffer</th></tr></thead><tbody><tr><td>Initial</td><td></td><td>1</td><td>0</td></tr><tr><td>1</td><td>Producer</td><td>0</td><td>1</td></tr><tr><td>2</td><td>Consumer</td><td>1</td><td>0</td></tr><tr><td>3</td><td>Producer</td><td>0</td><td>1</td></tr></tbody></table></li><li><p>Example 2: Consumer comes first</p><table><thead><tr><th>Time</th><th>Current Thread</th><th>emptyBuffer</th><th>fullBuffer</th></tr></thead><tbody><tr><td>Initial</td><td></td><td>1</td><td>0</td></tr><tr><td>1</td><td>Consumer</td><td>1</td><td>-1</td></tr><tr><td>2</td><td>Producer</td><td>0</td><td>0</td></tr><tr><td>3</td><td>Consumer</td><td>1</td><td>0</td></tr></tbody></table></li></ul><h3 id="pc-1-producer-1-consumer-with-buffer-of-size-n"><a class="markdownIt-Anchor" href="#pc-1-producer-1-consumer-with-buffer-of-size-n"></a> P/C: 1 Producer &amp; 1 Consumer with Buffer of Size N</h3><ul><li><p>Use 2 semaphores</p><ul><li>emptyBuffer: Initialize to N</li><li>fullBuffer: Initialize to 0</li></ul></li><li><p>Producer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer);</span><br><span class="line">    Fill(&amp;buffer[i]); </span><br><span class="line">    i = (i + <span class="number">1</span>) % N;</span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer);</span><br><span class="line">    Use(&amp;buffer[j]);</span><br><span class="line">    j = (j + <span class="number">1</span>) % N;</span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Example 1: Producer comes first (N = 3)</p><table><thead><tr><th>Time</th><th>Curr</th><th>empty<br>Buffer</th><th>full<br>Buffer</th><th>Note</th></tr></thead><tbody><tr><td>Initial</td><td></td><td>3</td><td>0</td><td></td></tr><tr><td>1</td><td>P1</td><td>2</td><td>1</td><td>wait(emptyBuffer) + fill + signal(fullBuffer)</td></tr><tr><td>2</td><td>P2</td><td>1</td><td>2</td><td>wait(emptyBuffer) + fill + signal(fullBuffer)</td></tr><tr><td>3</td><td>P3</td><td>0</td><td>3</td><td>wait(emptyBuffer) + fill + signal(fullBuffer)</td></tr><tr><td>4</td><td>P4</td><td>-1</td><td>3</td><td>wait(emptyBuffer)</td></tr><tr><td>5</td><td>C1</td><td>0</td><td>2</td><td>wait(fullBuffer) + use + signal(emptyBuffer)</td></tr><tr><td>6</td><td>C2</td><td>1</td><td>1</td><td>wait(fullBuffer) + use + signal(emptyBuffer)</td></tr><tr><td>7</td><td>P4</td><td>0</td><td>2</td><td>fill + signal(fullBuffer)</td></tr></tbody></table></li><li><p>Example 2: Two consumers come first (N = 3)</p><table><thead><tr><th>Time</th><th>Curr</th><th>empty<br>Buffer</th><th>full<br>Buffer</th><th>Note</th></tr></thead><tbody><tr><td>Initial</td><td></td><td>3</td><td>0</td><td></td></tr><tr><td>1</td><td>C1</td><td>3</td><td>-1</td><td>wait(fullBuffer)</td></tr><tr><td>2</td><td>C2</td><td>3</td><td>-2</td><td>wait(fullBuffe)</td></tr><tr><td>3</td><td>P</td><td>2</td><td>-1</td><td>wait(emptyBuffer) + fill + signal(fullBuffer)</td></tr><tr><td>4</td><td>C1</td><td>3</td><td>-1</td><td>use + signal(emptyBuffer)</td></tr></tbody></table></li></ul><h3 id="pc-multiple-producers-consumers"><a class="markdownIt-Anchor" href="#pc-multiple-producers-consumers"></a> P/C: Multiple Producers &amp; Consumers</h3><ul><li><p>Requirements</p><ul><li>Each consumer must grab unique filled element</li><li>Each producer must grab unique empty element</li></ul></li><li><p>Attempt 1</p><ul><li><p>Producer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Problem: <code>findfull</code> and <code>findempty</code> are not thread-safe</p></li></ul></li><li><p>Attempt 2</p><ul><li><p>Producer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Problem</p><ul><li>Deadlock: Consumer grabs <code>mutex</code> and wait for <code>fullBuffer</code> for ever</li></ul></li></ul></li><li><p>Attempt 3</p><ul><li><p>Producer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Problem</p><ul><li>Cannot operate on multiple buffer locations at the same time</li><li>Only 1 thread at at time can be using of filling different buffers</li></ul></li></ul></li><li><p>Attempt 4</p><ul><li><p>Producer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sem_wait(&amp;emptyBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_i = findempty(&amp;buffer);</span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    Fill(&amp;buffer[my_i]); </span><br><span class="line">    sem_signal(&amp;fullBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    sem_wait(&amp;fullBuffer); </span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    my_j = findfull(&amp;buffer); </span><br><span class="line">    sem_signal(&amp;mutex);</span><br><span class="line">    Use(&amp;buffer[my_j]); </span><br><span class="line">    sem_signal(&amp;emptyBuffer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Advantage</p><ul><li>Works and increases concurrency; only finding a buffer is protected by mutex;</li><li>Filling or Using different buffers can proceed concurrently</li></ul></li></ul></li></ul><h3 id="readerwriter-locks"><a class="markdownIt-Anchor" href="#readerwriter-locks"></a> Reader/Writer Locks</h3><ul><li><p>Idea</p><ul><li>Let multiple reader threads grab lock (shared)</li><li>Only one writer thread can grab lock (exclusive)<ul><li>No reader threads</li><li>No other writer threads</li></ul></li></ul></li><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct_rwlock_t</span> &#123;</span><br><span class="line">    <span class="keyword">sem_t</span> lock; <span class="comment">// reader lock</span></span><br><span class="line">    <span class="keyword">sem_t</span> writelock;</span><br><span class="line">    <span class="keyword">int</span> readers; <span class="comment">// number of readers</span></span><br><span class="line">&#125; <span class="keyword">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_init</span><span class="params">(<span class="keyword">rwlock_t</span>*rw)</span> </span>&#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// initialize locks to 1, similar to mutex initialization</span></span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">1</span>);  </span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123; </span><br><span class="line">    sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">    rw-&gt;readers++; </span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>) </span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">    sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123; </span><br><span class="line">    sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">    rw-&gt;readers--; </span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>) </span><br><span class="line">        sem_post(&amp;rw-&gt;writelock); <span class="comment">// let other writes</span></span><br><span class="line">    sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Example</p><table><thead><tr><th>Time</th><th>Current Action</th><th>lock</th><th>writelock</th><th>readers</th></tr></thead><tbody><tr><td>Initial</td><td></td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>T1 <code>acquire_readlock</code></td><td><del>0</del> 1</td><td>0</td><td>1</td></tr><tr><td>2</td><td>T2 <code>acquire_readlock</code></td><td><del>0</del> 1</td><td>0</td><td>2</td></tr><tr><td>3</td><td>T3 <code>acquire_writelock</code></td><td>1</td><td>-1</td><td>2</td></tr><tr><td>4</td><td>T1 <code>release_readlock</code></td><td><del>0</del> 1</td><td>-1</td><td>1</td></tr><tr><td>5</td><td>T2 <code>release_readlock</code></td><td><del>0</del> 1</td><td>0</td><td>0</td></tr></tbody></table></li><li><p>Quiz 1</p><ul><li>T1: <code>acquire_readlock()</code> =&gt; T1 running</li><li>T2: <code>acquire_readlock()</code> =&gt; T2 running</li><li>T3: <code>acquire_writelock()</code> =&gt; T3 blocked, waiting for write lock</li></ul></li><li><p>Quiz 2</p><ul><li>T6: <code>acquire_writelock()</code> =&gt; T6 running</li><li>T4: <code>acquire_readlock()</code> =&gt; T4 blocked, waiting for read lock</li><li>T5: <code>acquire_readlock()</code> =&gt; T5 blocked, waiting for read lock</li></ul></li></ul><h3 id="build-zemaphore-from-lock-and-cv"><a class="markdownIt-Anchor" href="#build-zemaphore-from-lock-and-cv"></a> Build Zemaphore from Lock and CV</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">cond_t</span> cond; </span><br><span class="line">    <span class="keyword">lock_t</span> lock; </span><br><span class="line">&#125; <span class="keyword">zem_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_init</span><span class="params">(<span class="keyword">zem_t</span> *z, <span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">    z-&gt;value = value; </span><br><span class="line">    cond_init(&amp;z-&gt;cond); </span><br><span class="line">    lock_init(&amp;z-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// waits until value &gt; 0. and decrement</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_wait</span><span class="params">(<span class="keyword">zem_t</span> *z)</span> </span>&#123; </span><br><span class="line">    lock_acquire(&amp;z-&gt;lock); </span><br><span class="line">    z-&gt;value--; </span><br><span class="line">    <span class="keyword">while</span> (z-&gt;value &lt; <span class="number">0</span>) </span><br><span class="line">       cond_wait(&amp;z-&gt;cond); </span><br><span class="line">    lock_release(&amp;z-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// increment value, then wake a single waiter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zem_post</span><span class="params">(<span class="keyword">zem_t</span> *z)</span> </span>&#123; </span><br><span class="line">    lock_acquire(&amp;z-&gt;lock); </span><br><span class="line">    z-&gt;value++; </span><br><span class="line">    cond_signal(&amp;z-&gt;cond); </span><br><span class="line">    lock_release(&amp;z-&gt;lock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="summary-6"><a class="markdownIt-Anchor" href="#summary-6"></a> Summary</h3><ul><li><p>Semaphores are equivalent to locks + condition variables</p><ul><li>Can be used for both mutual exclusion and ordering</li></ul></li><li><p>Semaphores contain state</p><ul><li>How they are initialized depends on how they will be used</li><li>Init to 0: Join (1 thread must arrive first, then other)</li><li>Init to N: Number of available resources</li></ul></li><li><p>sem_wait(): Decrement and waits until value &gt;= 0</p></li><li><p>sem_post(): Increment value, then wake a single waiter (atomic)</p></li><li><p>Can use semaphores in producer/consumer and for reader/writer locks</p></li></ul><h2 id="concurrency-bugs"><a class="markdownIt-Anchor" href="#concurrency-bugs"></a> Concurrency Bugs</h2><h3 id="concurrency-in-medicine-therac-25-1980s"><a class="markdownIt-Anchor" href="#concurrency-in-medicine-therac-25-1980s"></a> Concurrency in Medicine: Therac-25 (1980’s)</h3><blockquote><p>“The accidents occurred when the high-power electron beam was activated<br>instead of the intended low power beam, and without the beam spreader plate<br>rotated into place. Previous models had hardware interlocks in place to prevent<br>this, but Therac-25 had removed them, depending instead on software interlocks<br>for safety. The software interlock could fail due to a race condition.”</p></blockquote><blockquote><p>“…in three cases, the injured patients later died.”</p></blockquote><ul><li>Source: <a href="http://en.wikipedia.org/wiki/Therac-25" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Therac-25</a></li></ul><h3 id="concurrency-study"><a class="markdownIt-Anchor" href="#concurrency-study"></a> Concurrency Study</h3><p><img src="https://i.imgur.com/77XWz8c.png" alt=""></p><h3 id="atomicity-mysql"><a class="markdownIt-Anchor" href="#atomicity-mysql"></a> Atomicity: MySQL</h3><ul><li><p>Bug</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="built_in">fputs</span>(thd-&gt;proc_info, <span class="comment">/*...*/</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>Fix</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="built_in">fputs</span>(thd-&gt;proc_info, <span class="comment">/*...*/</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure></li></ul><h3 id="ordering-mozilla"><a class="markdownIt-Anchor" href="#ordering-mozilla"></a> Ordering: Mozilla</h3><ul><li><p>Bug</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, <span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">(<span class="comment">/*...*/</span>)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fix</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, <span class="comment">/*...*/</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    mtInit = <span class="number">1</span>; </span><br><span class="line">    pthread_cond_signal(&amp;mtCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">(<span class="comment">/*...*/</span>)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    <span class="keyword">while</span> (mtInit == <span class="number">0</span>) </span><br><span class="line">        pthread_cond_wait(&amp;mtCond, &amp;mtLock);  </span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);  </span><br><span class="line">    </span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="deadlock"><a class="markdownIt-Anchor" href="#deadlock"></a> Deadlock</h2><h3 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h3><ul><li>No progress can be made because two or more threads are waiting for the other to take some action and thus neither ever does</li></ul><h3 id="example-1-circular-dependency"><a class="markdownIt-Anchor" href="#example-1-circular-dependency"></a> Example 1: Circular Dependency</h3><ul><li><p>Code</p><table><thead><tr><th>Thread 1</th><th>Thread 2</th></tr></thead><tbody><tr><td><code>lock(&amp;A);</code> <br><br><br> <code>lock(&amp;B);</code>(blocked)</td><td><br><code>lock(&amp;B);</code>  <br> <code>lock(&amp;A);</code>(blocked)<br><br></td></tr></tbody></table></li><li><p>Circular Dependency<br><img src="https://i.imgur.com/dG4Krbd.png" alt=""></p><ul><li>Cycle in dependency graph -&gt; possible to have deadlock</li></ul></li><li><p>Fix Deadlock Code</p><table><thead><tr><th>Thread 1</th><th>Thread 2</th></tr></thead><tbody><tr><td><code>lock(&amp;A);</code> <br><code>lock(&amp;B);</code></td><td><code>lock(&amp;A);</code>  <br> <code>lock(&amp;A);</code></td></tr></tbody></table></li><li><p>Non-Circular Dependency<br><img src="https://i.imgur.com/yJibQZG.png" alt=""></p></li></ul><h3 id="example-2-encapsulation"><a class="markdownIt-Anchor" href="#example-2-encapsulation"></a> Example 2: Encapsulation</h3><ul><li>Code</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_t</span> *set_intersection(<span class="keyword">set_t</span> *s1, <span class="keyword">set_t</span> *s2) &#123;</span><br><span class="line">   <span class="keyword">set_t</span> *rv = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*rv));</span><br><span class="line">   mutex_lock(&amp;s1-&gt;lock);</span><br><span class="line">   mutex_lock(&amp;s2-&gt;lock);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1-&gt;len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set_contains(s2, s1-&gt;items[i])) &#123;</span><br><span class="line">         set_add(rv, s1-&gt;items[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   mutex_unlock(&amp;s2-&gt;lock);</span><br><span class="line">   mutex_unlock(&amp;s1-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Deadlock scenario</p><ul><li>Thread 1: <code>rv = set_intersection(setA, setB);</code></li><li>Thread 2: <code>rv = set_intersection(setB, setA);</code></li></ul></li><li><p>Encapsulation</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m1 &gt; m2) &#123;</span><br><span class="line">  <span class="comment">// grab locks in high-to-low address order</span></span><br><span class="line">  pthread_mutex_lock(m1);</span><br><span class="line">  pthread_mutex_lock(m2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pthread_mutex_lock(m2);</span><br><span class="line">  pthread_mutex_lock(m1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Problem: Deadlock happens when <code>m1 == m2</code></li></ul></li></ul><h3 id="deadlock-theory"><a class="markdownIt-Anchor" href="#deadlock-theory"></a> Deadlock Theory</h3><ul><li><p>Deadlocks can only happen with these four conditions:</p><ol><li>mutual exclusion</li><li>hold-and-wait</li><li>no preemption</li><li>circular wait</li></ol></li><li><p>Can eliminate deadlock by eliminating any one condition</p></li></ul><h3 id="1-mutual-exclusion"><a class="markdownIt-Anchor" href="#1-mutual-exclusion"></a> 1. Mutual Exclusion</h3><ul><li><p>Problem: Threads claim exclusive control of resources that they require</p></li><li><p>Strategy: Eliminate locks! Replace locks with atomic primitive</p></li><li><p>Lock-free <code>add</code></p><ul><li><p>Implement <code>add</code> using lock</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *val, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  Mutex_lock(&amp;m);</span><br><span class="line">  *val += amt;</span><br><span class="line">  Mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Atomic primitive <code>CompareAndSwap</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *address, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*address == expected) &#123;</span><br><span class="line">    *address = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// success</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implement <code>add</code> without lock</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *val, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> old = *value;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!CompareAndSwap(val, old, old + amt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Wait-free Linked List Insert</p><ul><li><p>Implement <code>insert</code> using lock</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*n));</span><br><span class="line">  n-&gt;val = val;</span><br><span class="line">  lock(&amp;m);</span><br><span class="line">  n-&gt;next = head;</span><br><span class="line">  head = n;</span><br><span class="line">  unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implement <code>insert</code> using while loop</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *n = Malloc(<span class="keyword">sizeof</span>(*n));</span><br><span class="line">  n-&gt;val = val;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!CompareAndSwap(&amp;head, n-&gt;next, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-hold-and-wait"><a class="markdownIt-Anchor" href="#2-hold-and-wait"></a> 2. Hold and Wait</h3><ul><li><p>Problem: Threads hold resources allocated to them while waiting for additional resources</p></li><li><p>Strategy: Acquire all locks atomically once. Can release locks over time, but cannot acquire again until all have been released</p></li><li><p>How to do this? Use a meta lock:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock(&amp;meta);</span><br><span class="line">lock(&amp;L1); <span class="comment">/*...*/</span> lock(&amp;L10);</span><br><span class="line">unlock(&amp;L10); <span class="comment">/*...*/</span> unlock(&amp;L1);</span><br><span class="line">unlock(&amp;meta);</span><br></pre></td></tr></table></figure></li><li><p>Disadvantages</p><ul><li>Locks are not fine-grained</li></ul></li></ul><h3 id="3-no-preemption"><a class="markdownIt-Anchor" href="#3-no-preemption"></a> 3. No Preemption</h3><ul><li><p>Problem: Resources (e.g., locks) cannot be forcibly removed from threads that are</p></li><li><p>Strategy: if thread can’t get what it wants, release what it holds</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top: </span><br><span class="line">lock(A);</span><br><span class="line"><span class="keyword">if</span> (trylock(B) == <span class="number">-1</span>) &#123; <span class="comment">// try to lock B</span></span><br><span class="line">  unlock(A); <span class="comment">// if failed, also unlock A</span></span><br><span class="line">  <span class="keyword">goto</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Disadvantages</p><ul><li>Live lock: A situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work</li></ul></li></ul><h3 id="circular-wait"><a class="markdownIt-Anchor" href="#circular-wait"></a> Circular Wait</h3><ul><li><p>Circular chain of threads such that each thread holds a resource (e.g., lock)<br>being requested by next thread in the chain.</p></li><li><p>Strategy:</p><ul><li>decide which locks should be acquired before others</li><li>if A before B, never acquire A if B is already held!</li><li>document this, and write code accordingly</li></ul></li><li><p>Works well if system has distinct layers</p></li></ul><h2 id="concurrent-data-structures"><a class="markdownIt-Anchor" href="#concurrent-data-structures"></a> Concurrent Data Structures</h2><h3 id="scalability"><a class="markdownIt-Anchor" href="#scalability"></a> Scalability</h3><ul><li><p>N times as much work on N cores as done on 1 core.</p></li><li><p>Strong scaling</p><ul><li><p>Fix input size, increase number of cores</p></li><li><p>e.g. Matrix multiplication: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>B</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{m\times n}\times B_{n\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mbin mtight">×</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">×</span><span class="mord mathit mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span></span></span></span> requires <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mnd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mclose">)</span></span></span></span> FLOPS (floating point operations per second)</p></li></ul>  <pre> Time    ^   |   |     **   |     **   |     **   |     **   |     **     **   |     **     **   |     **     **     **   |     **     **     **     **   +-----++-----++-----++-----++----> Number of Cores   0     1      2      3      4</pre></li></ul><ul><li><p>Weak scaling</p><ul><li><p>Increase input size with number of cores</p></li><li><p>e.g. Matrix multiplication</p></li></ul><table><thead><tr><th></th><th>A</th><th>B</th><th>FLOPS</th></tr></thead><tbody><tr><td>1 core</td><td>100 × 100</td><td>100 × 100</td><td>10<sup>6</sup></td></tr><tr><td>2 core</td><td>100 × 200</td><td>200 × 100</td><td>2×10<sup>6</sup></td></tr><tr><td>3 core</td><td>100 × 300</td><td>300 × 100</td><td>2×10<sup>6</sup></td></tr><tr><td>4 core</td><td>100 × 400</td><td>400 × 100</td><td>4×10<sup>6</sup></td></tr></tbody></table>  <pre> Time    ^   |   |     **     **     **     **   |     **     **     **     **   |     **     **     **     **   |     **     **     **     **   |     **     **     **     **   |     **     **     **     **   |     **     **     **     **   |     **     **     **     **   +-----++-----++-----++-----++----> Number of Cores   0     1      2      3      4  </pre></li></ul><h3 id="counter"><a class="markdownIt-Anchor" href="#counter"></a> Counter</h3><ul><li><p>Non-thread-safe Counter</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Problem: Two threads calls <code>increment</code> at the same time</li></ul></li><li><p>Thread-safe counter</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> * c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Linearizability</p><ul><li><p>Even if two threads execute in parallel on multiple cores, the effect that you see should be as if all of them are executed in some linear order.</p></li><li><p>Example: T1 and T2 call <code>increment</code> first, then T3 calls <code>get</code>.</p></li><li><p>Since T3 arrived after T1 and T2, we would want T3 to see the values after T1 and T2 have finished executing as if these were three instructions executed by a single processor</p></li></ul></li><li><p>The Underlying Problem</p><ul><li>Ticket lock</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> current_ticket; <span class="comment">// turn</span></span><br><span class="line">    <span class="keyword">int</span> next_ticket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    t = atomic_inc(lock-&gt;next_ticket)</span><br><span class="line">    <span class="keyword">while</span> (t != lock-&gt;current_ticket); <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;current_ticket++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>If one of the thread holds the lock,  all of the other threads need to check the lock</li><li>So each lock acquisition becomes more and more expensive as you go from like two to four to eight…</li></ul></li></ul><h3 id="approximate-counter-sloppy-counter"><a class="markdownIt-Anchor" href="#approximate-counter-sloppy-counter"></a> Approximate Counter (Sloppy Counter)</h3><ul><li><p>Idea</p><ul><li>Maintain a counter per-core and a global counter</li><li>Global counter lock</li><li>Per-core locks if more than 1 thread per-core</li></ul></li><li><p>Increment:</p><ul><li>update local counters at threshold update global</li></ul></li><li><p>Read:</p><ul><li>global counter (maybe inaccurate?)</li></ul></li><li><p>Code</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> global;                      <span class="comment">// global count</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> glock;           <span class="comment">// global lock</span></span><br><span class="line">  <span class="keyword">int</span> local[NUMCPUS];              <span class="comment">// local count (per cpu)</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> llock[NUMCPUS];  <span class="comment">// ... and locks</span></span><br><span class="line">  <span class="keyword">int</span> threshold;                   <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init: record threshold, init locks, init values of all local counts and</span></span><br><span class="line"><span class="comment">// global count</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span>* c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">  c-&gt;threshold = threshold;</span><br><span class="line">  c-&gt;global = <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">    c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usually, just grab local lock and update local amount once local</span></span><br><span class="line"><span class="comment">// count has risen by ’threshold’, grab global lock and transfer local values to it</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span>* c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">  c-&gt;local[threadID] += amt;                 <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123;  <span class="comment">// transfer to global</span></span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get: just return global amount (which may not be perfect)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span>* c)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">  <span class="keyword">int</span> val = c-&gt;global;</span><br><span class="line">  pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">  <span class="keyword">return</span> val;  <span class="comment">// only approximate!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="concurrent-linked-list"><a class="markdownIt-Anchor" href="#concurrent-linked-list"></a> Concurrent Linked List</h3><ul><li><p>First Attempt</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//  fail</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">  <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">  L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">//  success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Better Implementation (Shorter Critical Section)</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"malloc"</span>);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//  fail</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">  <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">  L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">//  success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="hash-table-from-list"><a class="markdownIt-Anchor" href="#hash-table-from-list"></a> Hash Table from List</h3><ul><li><p>Idea</p><ul><li>Avoid contention by using different locks</li></ul></li><li><p>Code</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">  <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="concurrent-queue"><a class="markdownIt-Anchor" href="#concurrent-queue"></a> Concurrent Queue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Enqueue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">  tmp-&gt;value = value;</span><br><span class="line">  tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;q-&gt;tailLock);</span><br><span class="line">  q-&gt;tail-&gt;next = tmp;</span><br><span class="line">  q-&gt;tail = tmp;</span><br><span class="line">  pthread_mutex_unlock(&amp;q-&gt;tailLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Dequeue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;q-&gt;headLock);</span><br><span class="line">  <span class="keyword">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">  <span class="keyword">node_t</span> *newHead = tmp-&gt;next;</span><br><span class="line">  <span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// queue was empty</span></span><br><span class="line">  &#125;</span><br><span class="line">  *value = newHead-&gt;value;</span><br><span class="line">  q-&gt;head = newHead;</span><br><span class="line">  pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="summary-7"><a class="markdownIt-Anchor" href="#summary-7"></a> Summary</h3><ul><li><p>Simple approach: Add a lock to each method?!</p></li><li><p>Check for scalability – weak scaling, strong scaling</p></li><li><p>Avoid cross-thread, cross-core traffic</p><ul><li>Per-core counter</li><li>Buckets in hashtable</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cs537-operating-system-summary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs537-operating-system-summary&quot;&gt;&lt;/a&gt; &lt;strong&gt;CS537 - Operating S
      
    
    </summary>
    
    
      <category term="OS" scheme="http://th2zz.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Boyer–Moore majority vote algorithm</title>
    <link href="http://th2zz.github.io/2019/03/24/Boyer%E2%80%93Moore%20majority%20vote%20algorithm/"/>
    <id>http://th2zz.github.io/2019/03/24/Boyer–Moore majority vote algorithm/</id>
    <published>2019-03-25T03:38:32.000Z</published>
    <updated>2019-03-25T05:16:09.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="boyermoore-majority-vote-algorithm"><a class="markdownIt-Anchor" href="#boyermoore-majority-vote-algorithm"></a> Boyer–Moore majority vote algorithm</h1><p>Boyer–Moore majority vote algorithm is an algorithm that finds the majority element and its count from a given sequence in O(N)TIME O(1)SPACE.</p><h2 id="pseudocode"><a class="markdownIt-Anchor" href="#pseudocode"></a> Pseudocode</h2><ul><li>Initialize an element m and a counter i with i = 0</li><li>For each element x of the input sequence:<ul><li>If i = 0, then assign m = x and i = 1</li><li>else if m = x, then assign i = i + 1</li><li>else assign i = i − 1</li></ul></li><li>Return m<br>初始化major元素 major = arr[0]，counter = 1<br>遍历序列中每个元素 1:end<br>if counter == 0 reset: major to be current pointer and counter to be 1<br>else if major == current element increment counter<br>else (current element is not major and counter need not to be reset) decrement counter</li></ul><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><p>Leetcode 169<br>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.<br>You may assume that the array is non-empty and the majority element always exist in the array.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] num) &#123;</span><br><span class="line">        int major=num[0], count = 1;</span><br><span class="line">        for(int i=1; i&lt;num.length;i++)&#123;</span><br><span class="line">            if(count==0)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                major=num[i];</span><br><span class="line">            &#125;else if(major==num[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else count--;</span><br><span class="line">        &#125;</span><br><span class="line">        return major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Boyer–Moore_majority_vote_algorithm</a><br><a href="https://www.zhihu.com/question/49973163/answer/235921864" target="_blank" rel="noopener">https://www.zhihu.com/question/49973163/answer/235921864</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;boyermoore-majority-vote-algorithm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#boyermoore-majority-vote-algorithm&quot;&gt;&lt;/a&gt; Boyer–Moore majorit
      
    
    </summary>
    
    
      <category term="Algorithm and Data Structures" scheme="http://th2zz.github.io/tags/Algorithm-and-Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Threaded Binary Tree and Morris Traversal</title>
    <link href="http://th2zz.github.io/2019/03/22/Threaded%20Binary%20Tree%20and%20Morris%20Traversal/"/>
    <id>http://th2zz.github.io/2019/03/22/Threaded Binary Tree and Morris Traversal/</id>
    <published>2019-03-22T20:58:08.000Z</published>
    <updated>2019-03-22T20:58:39.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="threaded-binary-tree-and-morris-traversal"><a class="markdownIt-Anchor" href="#threaded-binary-tree-and-morris-traversal"></a> Threaded Binary Tree and Morris Traversal</h1><h2 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h2><p>对于有着空的左孩子右孩子指针的节点 内存被浪费了，所以在TBT里我们利用这些内存来储存一些地址</p><h2 id="transform-a-normal-binary-tree-to-tbt"><a class="markdownIt-Anchor" href="#transform-a-normal-binary-tree-to-tbt"></a> Transform a normal binary tree to TBT</h2><ol><li>最左边最右边的空指针不改动</li><li>将其他的空指针改为：<ul><li><pre><code>Left ptr = inorder predecessor 因为该节点没有inorder predecessor 中序遍历第一个节点</code></pre></li><li><pre><code>Right ptr = inorder successor 因为该节点没有inorder successor 中序遍历最后一个节点</code></pre></li></ul></li></ol><p><img src="https://i.imgur.com/sr6MQQ7.jpg" alt=""><br>我们可以在节点里加入两个flag来代表左指针右指针指向的是ancestor还是child<br>最后对于中序遍历的起点和终点的左右指针 连向dummy node flag设为ancestor<br><img src="https://i.imgur.com/OE9qckF.png" alt=""></p><p>莫里斯遍历利用线段树的概念可以实现iterative inorder traversal of tree without using stack TIME O(N) SPACE O(1)<br>Pseudocode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Initialize current as root </span><br><span class="line">While current is not NULL</span><br><span class="line">   If current does not has a left child</span><br><span class="line">      a) access current&apos;s data</span><br><span class="line">      b) Go to the right, i.e., current = current-&gt;right</span><br><span class="line">   Else</span><br><span class="line">      a) Make current as right child of the rightmost </span><br><span class="line">         node in current&apos;s left subtree</span><br><span class="line">      b) Go to that left child, i.e., current = current-&gt;left  (set current&apos;s left to be null)</span><br></pre></td></tr></table></figure><p>LeetCode94: use above method to achieve inorder traversal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode node) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList();</span><br><span class="line"></span><br><span class="line">        while(node != null) &#123;</span><br><span class="line">            if(node.left == null) &#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode nextNode = node.left;</span><br><span class="line">                TreeNode p = node.left;</span><br><span class="line">                while(p.right != null) p = p.right;</span><br><span class="line">                p.right = node;//p:rightmost node in the leftsubtree</span><br><span class="line">                node.left = null;</span><br><span class="line">                node = nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;threaded-binary-tree-and-morris-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#threaded-binary-tree-and-morris-traversal&quot;&gt;&lt;/a&gt; Threa
      
    
    </summary>
    
    
      <category term="Algorithm and Data Structures" scheme="http://th2zz.github.io/tags/Algorithm-and-Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Database Management System</title>
    <link href="http://th2zz.github.io/2019/03/18/Database/"/>
    <id>http://th2zz.github.io/2019/03/18/Database/</id>
    <published>2019-03-18T18:00:41.000Z</published>
    <updated>2019-03-20T19:29:02.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs564-database-management-system"><a class="markdownIt-Anchor" href="#cs564-database-management-system"></a> <strong>CS564 - Database Management System</strong></h1><h2 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h2><h3 id="relational-algebra-and-calculus"><a class="markdownIt-Anchor" href="#relational-algebra-and-calculus"></a> Relational algebra and Calculus</h3><p><img src="https://i.imgur.com/kksvzjk.png" alt=""></p><h3 id="keys"><a class="markdownIt-Anchor" href="#keys"></a> Keys</h3><ul><li>A<strong>superkey</strong> is a set of one or more attributes that, taken collectively, allow us to identify uniquely a tuple in the relation</li><li>Such minimal superkeys are called <strong>candidate keys</strong>.</li><li>We shall use the term <strong>primary key</strong> to denote a candidate key that is chosen by the database designer as the principal means of identifying tuples within a relation.</li><li><strong>Foreign Key</strong> is a set of attributes in a referencing relation, such that for each tuple in the referencing relation, the values of the foreign key attributes are guaranteed to occur as the primary key value of a tuple in the referenced relation.</li></ul><h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> Join</h3><ul><li>natural join combines two tables based on identical columns</li><li>Cartesian product operation combines tuples from two relations, but unlike the join operation, its result contains all pairs of tuples from the two relations</li></ul><h3 id="sql-language"><a class="markdownIt-Anchor" href="#sql-language"></a> SQL Language</h3><ul><li>SQL allows us to use the keyword all to specify explicitly that duplicates are not removed</li><li><strong>varchar(n)</strong>: A variable-length character string with user-specified maximum length n. The full form, character varying, is equivalent.</li><li><strong>numeric(p, d)</strong>:Afixed-point numberwith user-specified precision. The number consists of p digits (plus a sign), and d of the p digits are to the right of the decimal point.</li><li><strong>Percent (%)</strong>: The % character matches any substring.</li><li><strong>Underscore (_)</strong>: The character _ matches any character.</li><li>The set operation automatically eliminates duplicates</li></ul><p><img src="https://i.imgur.com/G2hgY3K.png" alt=""></p><h2 id="database-design-er-model"><a class="markdownIt-Anchor" href="#database-design-er-model"></a> Database Design (ER Model)</h2><h3 id="terms"><a class="markdownIt-Anchor" href="#terms"></a> Terms</h3><ul><li>Entity</li><li>Attribute<ul><li>Domain</li><li>Key</li><li>Primary Key can not be null</li></ul></li><li>Relationship<ul><li>Descriptive attribute, the attribute of the entity in between two entities</li><li>A relationship should be uniquely identified</li><li>Instance of relationship set is a set of relationships</li><li>Sometimes a relationship can involve two identities in the same enetity set</li></ul></li><li>Constraints<ul><li>Participation constraint, total, partial</li><li>weak enetity set</li><li>ISA inheritance relationship set<ul><li>specialzation, generalization</li><li>overlap, covering constraint</li></ul></li></ul></li></ul><h3 id="the-relational-model"><a class="markdownIt-Anchor" href="#the-relational-model"></a> The Relational Model</h3><ul><li>Integrity Constriant<ul><li>Foreign key constraint</li></ul></li></ul><h2 id="relational-design-theory"><a class="markdownIt-Anchor" href="#relational-design-theory"></a> Relational Design Theory</h2><h3 id="函数依赖-functional-dependency"><a class="markdownIt-Anchor" href="#函数依赖-functional-dependency"></a> 函数依赖 Functional Dependency</h3><ul><li><p>考虑如下的university database schema<br><img src="https://i.imgur.com/rjGtPin.png" width="500" height="200"><br>将表instructor和department替换为其自然连接的结果不是一个好的选择<br><img src="https://i.imgur.com/JltoS4y.png" width="400"><br>因为对于每个instructor都有部门budget信息大量重复 我们需要保证任何更新操作都要同步budget。 另一个缺点是natural inner join会去除左右两边为null的情况，所以没有instructor的部门就无法在表中被表示。<br><strong>但如果我们先有inst_dept表，我们该如何知道这个设计不好并且应该被分解成instructor和department呢？</strong><br>我们需要发现每个department必须只有1个building,每个department必须只有一个budget。<br>Not every ER design can be precise enough to avoid such problems，so we need to allow designers to specify rules such as “<strong>each specific value of dept_name corresponds to at most one budget</strong>” even in cases where dept_name is not the primary key for the schema.<br>In this case, we need to write a rule “<strong>if there were a schema(dept_name,budget),then dept_name is able to serve as the primary key</strong>.” This rule is specified as a functional dependency:<br><img src="https://i.imgur.com/aaCGsjY.png" width="250"><br>This gives sufficient information to recognize the problem of inst_dept schema. Therefore functional dependency says what relational instances are allowed under certain constraints.<br>Functional depedency generalizes notions of key in a relation. It depicts relationship between attributes.</p></li><li><p><strong>Definition</strong>: A relational instance satisfies functional dependency from attribute A-&gt;B if (any) two tuples having same value of attribute A also have same value of attribute B. i.e. A uniquely determines B</p></li><li><p><strong>A trivial functional dependency</strong> is the one which will always hold in a relation. <strong>A-&gt;B and B is a subset of A.</strong></p></li><li><p><strong>Non-Trivial functional dependency</strong> may or may not hold in a relation. <strong>A-&gt;B and B is NOT a subset of A.</strong></p></li><li><p><strong>Properties of functional dependency</strong><br>“Armstrong’s Axioms”<br><img src="https://i.imgur.com/zkhjneI.png" alt=""><br>Other<br><img src="https://i.imgur.com/nNsRewf.png" alt=""><br><img src="https://i.imgur.com/D9pWMoO.png" alt=""></p></li><li><p><strong>&quot;A set of functional dependencies&quot; F</strong> is a set of FD constraints on legal relational instances in a relation.</p></li><li><p><strong>&quot;The closure of FDs set F&quot; F+</strong> is a set of all FDs that can be inferred from given the set F (<strong>Note that this includes all FDs in F itself</strong>).</p></li><li><p><strong>Attribute Closure</strong>: Attribute closure of an attribute set A is a set of all attributes that can be functionally determined from elements of set A (<strong>Note that this includes attributes in A itself</strong>).<br>Examples:<br><img src="https://i.imgur.com/hf0hLCc.png" alt=""></p></li><li><p><strong>Determining equivalence of functional dependencies</strong><br>Check whether 2 FD sets are subset of each other’s closure.</p></li><li><p><strong>Computing minimal cover</strong><br>A minimal cover of a FD set A is the smallest set of FDs that covers A.<br><img src="https://i.imgur.com/ItMURpT.png" alt=""><br><img src="https://i.imgur.com/HOT0QpT.png" alt=""></p></li><li><p><strong>Other notes</strong><br>所有非主属性都完全函数依赖于每个候选键<br>所有主属性都完全函数依赖于每个不包含它的候选键<br>没有任何属性完全函数依赖于非候选键的任何一组属性</p></li></ul><h3 id="数据异常-data-anomalies"><a class="markdownIt-Anchor" href="#数据异常-data-anomalies"></a> 数据异常 Data Anomalies</h3><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h3 id="范式-normal-form"><a class="markdownIt-Anchor" href="#范式-normal-form"></a> 范式 Normal Form</h3><p>范式理论是为了解决以上提到四种异常。<br>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。<br><img src="https://i.imgur.com/v1zy4Cw.png" width="250" height="200"></p><h4 id="分解"><a class="markdownIt-Anchor" href="#分解"></a> 分解</h4><p><strong>Universal Relation:</strong> A relation that captures all the information in schema and is decomposable into smaller relations.</p><ul><li><p>Decomposition of a relation is done when a relation in relational model is not in appropriate normal form. A good/detailed ER model should end up directly as a 3NF or BCNF. The functional dependencies guide us to determine entities and their relationships</p></li><li><p>Ideal decomposition should be <strong>lossless</strong> and <strong>dependency preserving</strong>.<br>For relation R decomposed into R1 and R2:<br><img src="https://i.imgur.com/LIH6YcZ.png" width="300"></p></li><li><p>Example:<br><img src="https://i.imgur.com/HRk77Rk.png" width="300"><br><img src="https://i.imgur.com/BKpXIIy.png" width="300"><br>employee表被分解为employee1表和employee2表：因为employee可以重名，所以我们将分解结果natural join会无法还原employee表。</p></li><li><p><strong>Lossless decomposition(lossless join decomposition) Requirements</strong><br><img src="https://i.imgur.com/7it87CU.png" alt=""></p></li><li><p><strong>Dependency preserving decomposition</strong><br>If we decompose a relation R into relations R1 and R2, All dependencies of R either must be a part of R1 or R2 or must be derivable from combination of FD’s of R1 and R2.</p><ul><li>Example:</li></ul><ol><li>R (A, B, C, D) with FD set{A-&gt;BC} is decomposed into R1(ABC) and R2(AD) which is dependency preserving because FD A-&gt;BC is a part of R1(ABC).</li><li>R(A,B,C,D) and functional dependencies A-&gt;B and C-&gt;D. Then the decomposition of R into R1(AB) and R2(CD) is dependency preserving but not lossless join because it violates the second condition of lossless join and A-&gt;B can be ensured in R1(AB) and C-&gt;D can be ensured in R2(CD). Hence it is dependency preserving decomposition.</li></ol></li></ul><h4 id="1-第一范式-1nf-atomicity原子性"><a class="markdownIt-Anchor" href="#1-第一范式-1nf-atomicity原子性"></a> 1. 第一范式 (1NF) Atomicity(原子性)</h4><p>表的属性不可分（表的属性不可为复合属性）。然而注意复合属性有时也是有用的并被大量实际使用于面向对象数据库。</p><h4 id="2-boycecodd-normal-formbcnf-每个表中只有一个候选键"><a class="markdownIt-Anchor" href="#2-boycecodd-normal-formbcnf-每个表中只有一个候选键"></a> 2. Boyce–Codd normal form(BCNF) 每个表中只有一个候选键</h4><p>BCNF is a slightly stronger version of 3NF.<br>Every BCNF satisfies 3NF. It eliminates all redundancy that can be discovered based on functional dependencies.<br><strong>A database design is in BCNF</strong> if each member of the set of relation schemas that constitutes the design is in BCNF.</p><p><strong>Definition：</strong><br>A relational schema R is in BCNF with respect to a set of functional dependencies F if for all functional dependencies in F+ of form A-&gt;B where A,B are subsets of R, at least one of the following holds:</p><ul><li>A-&gt;B is a trivial functional dependency (B is a subset of A)</li><li>A is a super key of schema R</li></ul><p><strong>Another equivalent definition (important):</strong><br>For all nontrivial FD A-&gt;B, A must be a super key of schema R.<br><strong>The negated definition</strong><br>A relational schema R is not in BCNF w.r.t FDs set F if there exists a FD in F+ of form A-&gt;B where A,B are subsets of R s.t.<br>A-&gt;B is a nontrivial FD (B is not a subset of A) <strong>AND</strong> A is not a super key of schema R.<br><strong>Example</strong>:<br>inst_dept (ID, name, salary, dept_name, building, budget) is not in BCNF because dept_name-&gt;budget is a nontrivial FD and dept_name is not a super key of inst_dept.<br>The schema instructor and department are not in BCNF because for all nontrivial FDs, either left side is not super key, or is super key. (in that case: ID, dept_name can be super key for each schema).<br><strong>Decomposing relational schema to BCNF</strong><br>For a relational schema R not in BCNF, we must have at least 1 nontrivial FD A-&gt;B s.t. A is not a super key for R.<br>We decompose R into 2 schemas:<br><img src="https://i.imgur.com/NbVERSD.png" width="180"><br>For inst_dept, A=dept_name, B={building,budget}, it can be decomposed to (dept_name, building, budget) AND (ID,name,salary,dept_name)<br><strong>Problem of BCNF:</strong></p><ul><li>BCNF is not dependency preserving.</li></ul><h4 id="3-第三范式-3nf-2nf消除传递函数依赖"><a class="markdownIt-Anchor" href="#3-第三范式-3nf-2nf消除传递函数依赖"></a> 3. 第三范式 (3NF) 2NF&amp;消除传递函数依赖</h4><p>BCNF requires A to be a superkey for nontrival FD A-&gt;B. 3NF relaxes the constraints by allowing A to not be a super key.<br><strong>Definition：</strong><br>A relational schema R is in 3NF with respect to a set of functional dependencies F if for all functional dependencies in F+ of form A-&gt;B where A,B are subsets of R, at least one of the following holds:</p><ul><li>A-&gt;B is a trivial functional dependency (B is a subset of A)</li><li>A is a super key of schema R</li><li>Each attribute X in B-A is contained in a candidate key in R</li></ul><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><p>存在以下transitive functional dependency：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td></tr></tbody></table><table><thead><tr><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><p><img src="https://i.imgur.com/iLeQOu8.png" alt=""></p><h3 id="multi-dimensional-database"><a class="markdownIt-Anchor" href="#multi-dimensional-database"></a> Multi-dimensional database</h3><p><img src="https://i.imgur.com/1RU9DJz.jpg" alt=""></p><p>Think spreadsheets and reporting but generalized.</p><ul><li>A star schema is the simplest form of a dimensional model, in which data is organized into facts and dimensions.  A fact is an event that is counted or measured, such as a sale or login.  A dimension contains reference information about the fact, such as date, product, or customer. A star schema is diagramed by surrounding each fact with its associated dimensions. The resulting diagram resembles a star.<br><img src="https://i.imgur.com/7xGywCG.png" alt=""></li><li>Example:<br><img src="https://i.imgur.com/n4OrKwb.jpg" alt=""></li></ul><h3 id="levels-of-abstraction-in-dbms"><a class="markdownIt-Anchor" href="#levels-of-abstraction-in-dbms"></a> Levels of abstraction in DBMS</h3><ul><li>Physical Schema is the way the relations are actually stored in SSD/HDD. It also defines indexes, statistics etc. defined on the table. (Indexes are defined using DDL.)</li><li>Logical (Conceptual) Schema is the DDL for creating the table. (It can sometimes specify the physical schema.)</li><li>External Schema is the DDL that define’s the external user’s view of the database. Though some “base” tables are directly visible, most of it is protected through views.</li></ul><h2 id="storage-and-file-structure"><a class="markdownIt-Anchor" href="#storage-and-file-structure"></a> Storage and File Structure</h2><h3 id="storage-overview"><a class="markdownIt-Anchor" href="#storage-overview"></a> Storage Overview</h3><ul><li>Persistent storage nonvolatile memory<ul><li>Data in a DBMS has to be persistent</li><li>SSD: flash memory based, faster and more expensive</li><li>HDD: magnetic storage, slower and cheaper</li><li>Tapes: disks are the new tapes, still great for archiving</li><li>Cloud server</li></ul></li><li>Volatile storage<ul><li>DRAM</li></ul></li></ul><h3 id="memory-hierarchy"><a class="markdownIt-Anchor" href="#memory-hierarchy"></a> Memory hierarchy</h3><p><img src="https://i.imgur.com/1EP43L3.jpg" alt=""></p><h3 id="disk"><a class="markdownIt-Anchor" href="#disk"></a> Disk</h3><p><img src="https://i.imgur.com/RJ2GrlY.png" alt=""></p><ul><li><p>The disk surface is logically divided into tracks, which are subdivided into sectors.</p><ul><li>A <strong>sector</strong> is the smallest unit of information that can be read from or written to the disk.</li><li>The <strong>read–write head</strong> stores information on a sector magnetically as reversals of the direction of magnetization of the magnetic material.</li><li>The <strong>platters</strong> that are <strong>fixed on a spindle rod</strong> spin, say 90 rps</li><li>Arm assembly moves in or out to position a head on desired track.</li><li>The tracks make an imaginary 空心<strong>cylinder</strong>: tracks with the same radius on all surfaces of disks platters     <strong>#cylinder = #tracks/surface</strong></li><li>#surface = #tracks/#cylinder = 2#platters</li><li>Only one head used at a time</li><li><strong>Block size</strong> is a multiple of sector size (fixed, usually 512 bytes)</li><li><strong>capacity</strong> = heads(#surfaces) x cylinder x sectors x 512 (typical size of one sector in bytes) =  #surfaces * #tracks * #sectors per track * bytes per sector</li></ul></li><li><p>Seek time: the time for repositioning the arm to change track.</p></li><li><p>Rotational delay: the time for getting to the right sector = 0.5(60s/磁盘转速rpm)   0.5为average</p></li><li><p>transfer time: actual overhead for transfering data = moving head across block</p></li></ul><p>Seek time + rotational delay is the major contributor to delay.<br><strong>Formatting</strong>: defining polar coordinate system on disk surface.<br><strong>wear leveling</strong>: storing hot data on less weared sectors and storing cold data on more weared sector to extend service time of the disk.</p><ul><li><p>RAID 0 Data stripping<br>RAID 0 consists of striping, but no mirroring or parity. Compared to a spanned volume, the capacity of a RAID 0 volume is the same; it is the sum of the capacities of the disks in the set. But because striping distributes the contents of each file among all disks in the set, the failure of any disk causes all files, the entire RAID 0 volume, to be lost. A broken spanned volume at least preserves the files on the unfailing disks. The benefit of RAID 0 is that the throughput of read and write operations to any file is multiplied by the number of disks because, unlike spanned volumes, reads and writes are done concurrently,[11] and the cost is complete vulnerability to drive failures.</p></li><li><p>RAID 1 Mirroring<br>RAID 1 consists of data mirroring, without parity or striping. Data is written identically to two drives, thereby producing a “mirrored set” of drives. Thus, any read request can be serviced by any drive in the set. If a request is broadcast to every drive in the set, it can be serviced by the drive that accesses the data first (depending on its seek time and rotational latency), improving performance. Sustained read throughput, if the controller or software is optimized for it, approaches the sum of throughputs of every drive in the set, just as for RAID 0. Actual read throughput of most RAID 1 implementations is slower than the fastest drive. Write throughput is always slower because every drive must be updated, and the slowest drive limits the write performance. The array continues to operate as long as at least one drive is functioning.</p></li><li><p>RAID 5 Stripping with Distributed Parity<br>Upon failure of a single drive, subsequent reads can be calculated from the distributed parity such that no data is lost. RAID 5 requires at least three disks.</p></li><li><p>RAID 6 two parity disks<br>RAID 6 consists of block-level striping with double distributed parity. Double parity provides fault tolerance up to two failed drives. This makes larger RAID groups more practical, especially for high-availability systems, as large-capacity drives take longer to restore. RAID 6 requires a minimum of four disks. As with RAID 5, a single drive failure results in reduced performance of the entire array until the failed drive has been replaced.[11] With a RAID 6 array, using drives from multiple sources and manufacturers, it is possible to mitigate most of the problems associated with RAID 5. The larger the drive capacities and the larger the array size, the more important it becomes to choose RAID 6 instead of RAID 5.</p></li></ul><h3 id="database-buffer"><a class="markdownIt-Anchor" href="#database-buffer"></a> Database Buffer</h3><ul><li>A major goal of the database system is to minimize the number of block transfers between the disk and memory.</li><li>The subsystem responsible for the allocation of buffer space is called the buffer manager.</li></ul><h3 id="file-organization"><a class="markdownIt-Anchor" href="#file-organization"></a> File Organization</h3><p><img src="https://i.imgur.com/V8RvRQk.jpg" alt=""></p><p><strong>A fixed length record</strong> is one where the length of the fields in each record has been set to be a certain maximum number of characters long. Suppose a field that was going to contain a name was set to be 25 characters long. This means that the field could only ever contain up to 25 characters. If all the fields in the record have a fixed length like this then the record is said to be a fixed length record. The problem with fixed length records is that each field very rarely contains the maximum number of characters allowed. This means that a lot of space is needlessly set aside and wasted. Also, values sometimes cannot be entered because they are too large to fit inside the allowed space in a field. The advantage of fixed length records is that they make file processing much easier because the start and end of each record is always a fixed number of characters apart. This makes it much easier to locate both indicidual records and fields.<br><img src="https://i.imgur.com/FdzIIl7.png" alt=""></p><p><img src="https://i.imgur.com/O6PKrwj.jpg" alt=""><br>A <strong>variable length record</strong> is one where the length of a field can change to allow data of any size to fit. The advantage of variable length records is that space is not wasted, only the space needed is ever used. The main problem with variable length records is that it is much more difficult to locate the start and end of individual records and fields. This is because they are not separated by a fixed amount of characters. To separate variable length recordseach field has a special character to mark where it ends- called an end- of- field marker. When records need to be located the computer must count through the end- of- field markers to locate individual records and fields.</p><p><img src="https://i.imgur.com/VBlJR9B.png" alt=""></p><p><img src="https://i.imgur.com/6NoscfG.png" alt=""><br><img src="https://i.imgur.com/TXo6UxW.png" alt=""><br><img src="https://i.imgur.com/t6f8Eqi.png" alt=""><br><img src="https://i.imgur.com/cdRtHS5.png" alt=""></p><ul><li>Columnar storage<br>A column-oriented DBMS (or columnar database management system) is a database management system (DBMS) that stores data tables by column rather than by row. Practical use of a column store versus a row store differs little in the relational DBMS world. Both columnar and row databases can use traditional database query languages like SQL to load data and perform queries. Both row and columnar databases can become the backbone in a system to serve data for common extract, transform, load (ETL) and data visualization tools. However, by storing data in columns rather than rows, the database can more precisely access the data it needs to answer a query rather than scanning and discarding unwanted data in rows. Query performance is increased for certain workloads.</li></ul><h3 id="storage-summary"><a class="markdownIt-Anchor" href="#storage-summary"></a> Storage summary</h3><ul><li>Databases must have persistent storage: SSD, HDD Their performance characteristics affect database design</li><li>Buffer manager tries to keep the optimal set of data blocks (pages) in memory to minimize I/O</li><li>must be able to “lock” (pin) a page in memory</li><li>must be able to write / flush page to disk on demand</li><li>Rows comprise both fixed and variable length fields</li><li>Slotted page format is flexible to keep records organized and accessible on a page</li><li>Single column values could be stored in fixed length records, but are usually compressed via encodings</li><li>Compression is used at both column and block level Heap files are ok but most databases use B+ trees</li><li>Columnar storage is another tool in the database tool-kit, soon all DBMS vendors will have it</li></ul><h2 id="indexing-and-hashing"><a class="markdownIt-Anchor" href="#indexing-and-hashing"></a> Indexing and Hashing</h2><h3 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> B+ tree</h3><ul><li><strong>Properties</strong><ul><li><p>It can be shown that the number of I/O operations needed in the worst case for an insertion is proportional to logn/2(N), where n is the maximum number of pointers in a node, and N is the number of records in the file being indexed.</p></li><li><p>It contains up to n − 1 search-key values K1 , K2 , . . . , Kn − 1 , and n pointers  P1 , P2 , . . . , Pn . The search-key values within a node are kept in sorted order; thus, if i &lt; j, then Ki &lt; Kj<br><img src="https://i.imgur.com/ApVXPRo.png" alt=""></p></li><li><p>Each <strong>non-leaf</strong> node in the tree has between n/2 and n children, where n is fixed for a particular tree.</p></li><li><p>A <strong>non-leaf</strong> node may hold up to n pointers, and must hold at least n/2 pointers. The number of pointers in a node is called the fanout of the node.</p></li><li><p>Each <strong>leaf</strong> can hold up to n − 1 values. We allow leaf nodes to contain as few as (n − 1)/2 values. With n = 4 in our example B±tree, each leaf must contain at least 2 values, and at most 3 values.</p></li><li><p>Since, n = 4 and 1 &lt; (n − 1)/2, we must either merge the node with a sibling node, or redistribute the entries between the nodes, to ensure that each node is at least half-full.</p></li></ul></li><li>Insertion<ul><li>Split</li><li>Coalesce</li></ul></li><li>Deletion<ul><li>if the occupancy of a node falls below 2n/3, the system attempts to borrow an entry from one of the sibling nodes</li><li>Borrow left, pick max one</li><li>Borrow right, pick min one</li><li>Merge left, shift left, change parent</li><li>Merge right, shift right, change parent</li></ul></li><li><strong>Non-unique search key</strong>: If a relation can have more than one record containing the same search key value (that is, two or more records can have the same values for the indexed attributes), the search key is said to be a non-unique search key.</li><li><strong>Bulk-loading in B+ tree</strong><ul><li>Insertion of a large number of entries at a time into an index is referred to as bulk loading of the index.</li><li>sort the file on the search key of the index being constructed</li><li>There is a significant benefit to sorting the entries before inserting them into the B+tree.</li><li>nodes will never have to be read from disk during bulk load, if the B+ tree was empty to start with. Each leaf node will thus incur only one I/O operation even though many entries may be inserted into the node.</li></ul></li><li><strong>bottom-up B+ tree construction</strong><ul><li>it can be constructed faster by building it bottom-up, from the leaf level, instead of using the usual insert procedure.</li><li>we break up the sorted entries into blocks, keeping as many entries in a block as can fit in the block; the resulting blocks form the leaf level of the B±tree. The minimum value in each block, alongwith the pointer to the block, is used to create entries in the next level of the B±tree, pointing to the leaf blocks</li></ul></li></ul><h3 id="hashing"><a class="markdownIt-Anchor" href="#hashing"></a> HASHING</h3><h4 id="static-hashing"><a class="markdownIt-Anchor" href="#static-hashing"></a> Static Hashing</h4><ul><li>We use the term <strong>bucket</strong> to denote a unit of storage that can store one or more records.</li><li>let <strong>K</strong> denote the set of all search-key values, and let <strong>B</strong> denote the set of all bucket addresses. A <strong>hash function h</strong> is a function from K to B. Let h denote a hash function.</li><li>Hash function should be random and uniform</li><li>Algorithm is similiar to Data Structure Hash Table</li></ul><h4 id="dynamic-hashing"><a class="markdownIt-Anchor" href="#dynamic-hashing"></a> Dynamic Hashing</h4><p><img src="https://i.imgur.com/jAg67QV.png" alt=""></p><h3 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> BITMAP</h3><ul><li>A <strong>bitmap</strong> is simply an array of bits. In its simplest form, a bitmap index on the attribute A of relation r consists of one bitmap for each value that A can take. Each bitmap has as many bits as the number of records in the relation. The ith bit of the bitmap for value vj is set to 1 if the record numbered i has the value vj for attribute A. All other bits of the bitmap are set to 0.</li></ul><p><img src="https://i.imgur.com/bjJkZQR.png" alt=""></p><ul><li>To recognize deleted records,we can store an <strong>existence bitmap</strong>, in which bit i is 0 if record i does not exist and 1 otherwise.<ul><li>If some records have been deleted, however, just computing the complement of a bitmap is not sufficient. Bits corresponding to such records would be 0 in the original bitmap, but would become 1 in the complement, although the records don’t exist.</li></ul></li><li><strong>Limitation</strong><ul><li>If there are further conditions, the fraction of records satisfying all the conditions is likely to be quite small.</li><li>If the fraction is large, scanning the entire relation would remain the cheaper alternative.</li></ul></li><li><strong>Counting the number of bits that are 1 in a bitmap</strong> can be done quickly by a clever technique. We can maintain an array with 256 entries, where the ith entry stores the number of bits that are 1 in the binary representation of i.</li></ul><h3 id="储存与索引总结"><a class="markdownIt-Anchor" href="#储存与索引总结"></a> 储存与索引总结</h3><p>atomicity problem:  transaction is executed totally or not at all<br>integrated storage structure: index file 和record file一起<br>seperate file: 相反</p><p>clustered index 与原数据同顺序<br>clustered indexes do not guarantee sequential storage on the disk. Managing exactly where data is placed on the disk is the job of the OS, not the DBMS. But it suggests that items are ordered generally according to the clustering key.</p><p>With a non clustered index there is a second list that has pointers to the physical rows. You can have many non clustered indexes, although each new index will increase the time it takes to write new records.</p><p>It is generally faster to read from a clustered index if you want to get back all the columns. You do not have to go first to the index and then to the table.</p><p>Writing to a table with a clustered index can be slower, if there is a need to rearrange the data</p><p>primary index: using primary key for indexing</p><p>secondary index: otherwise</p><p>index以block为单位进行index  within block用offset</p><p>hash index  通过哈希函数生成hash address to a bucket with possible overflow chain for managing collision<br>cheaper than B+tree if no overflow occurs Access: O(1+#overflow buckets)<br>所以hash索引的最大的特点就是等值查询快，不能进行范围索引。<br>位图索引适合静态low-cardinality重复数据<br>b树索引同时支持范围及等值查询</p><p>b tree m-way(order m, m fanout, m-1info fields) search tree with additional constraints:  叶子层高度相同 root 2 key  其他节点至少半满ceiling(order/2)来尽量减少高度    若想要插入的位置已满  recursively按中序遍历顺序将中点上移 同时将前驱后继节点分开 始终保持节点半满的要求<br>b+ tree 更贴近多级索引，是在b树基础上, nonleaf node sparse index 减少disk page access  支持equality search 在叶子层将nonleaf节点key按中序遍历顺序拷贝下来 叶子层包含record ptrs 保持中序遍历顺序建立链表 形成dense &amp; clustered index 从而支持range search<br>删除： 左合并 右合并 来满足半满的限制  split if necessary can propagate to root.<br>order=#ptr fields = p    /node<br>#k,v fields = p-1          /node</p><p>(p-1)(key_ptr_size + record_ptr_size) + p(block_ptr_size) &lt;= blocksize=512</p><p>static hashing: linear congruential hash function with fixed #hash buckets  use overflow chain to manage contention</p><p>extendible hashing: nonlinear hashing congruential function such as h_k(v)=h(v) mod 2^k  use directory of size 2^k to store ptrs to hash buckets<br>when collisions happen increment k value and maps it elsewhere</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cs564-database-management-system&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs564-database-management-system&quot;&gt;&lt;/a&gt; &lt;strong&gt;CS564 - Databas
      
    
    </summary>
    
    
      <category term="Computer Science" scheme="http://th2zz.github.io/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>Computer Networking</title>
    <link href="http://th2zz.github.io/2019/03/17/Computer%20Networking/"/>
    <id>http://th2zz.github.io/2019/03/17/Computer Networking/</id>
    <published>2019-03-17T23:00:41.000Z</published>
    <updated>2019-03-22T21:02:48.681Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/network/1.png" alt=""><br><img src="/network/2.png" alt=""><br><img src="/network/3.png" alt=""><br><img src="/network/4.png" alt=""><br><img src="/network/5.png" alt=""><br><img src="/network/6.png" alt=""><br><img src="/network/7.png" alt=""><br><img src="/network/8.png" alt=""><br><img src="/network/9.png" alt=""><br><img src="/network/10.png" alt=""><br><img src="/network/11.png" alt=""><br><img src="/network/12.png" alt=""><br><img src="/network/13.png" alt=""><br><img src="/network/14.png" alt=""><br><img src="/network/15.png" alt=""><br><img src="/network/16.png" alt=""><br><img src="/network/17.png" alt=""><br><img src="/network/18.png" alt=""><br><img src="/network/19.png" alt=""><br><img src="/network/20.png" alt=""><br><img src="/network/21.png" alt=""><br><img src="/network/22.png" alt=""><br><img src="/network/23.png" alt=""><br><img src="/network/24.png" alt=""><br><img src="/network/25.png" alt=""><br><img src="/network/26.png" alt=""><br><img src="/network/27.png" alt=""><br><img src="/network/28.png" alt=""><br><img src="/network/29.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/network/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/network/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/network/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/network/4.pn
      
    
    </summary>
    
    
      <category term="Computer Network" scheme="http://th2zz.github.io/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>Process Control</title>
    <link href="http://th2zz.github.io/2019/02/10/process%20control/"/>
    <id>http://th2zz.github.io/2019/02/10/process control/</id>
    <published>2019-02-10T20:15:32.000Z</published>
    <updated>2019-03-20T22:41:52.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h1><ul><li>pid</li><li>fork</li><li>wait</li><li>exec</li></ul><h2 id="pid"><a class="markdownIt-Anchor" href="#pid"></a> pid</h2><p>每一个进程都有一个独特的非负整型pid</p><p>pid可以用来生成独特的文件名</p><p>进程终止时 pid会被回收重用</p><p>大部分unix系统会有代码来延迟重用从而保证新创建的进程和刚刚终止的进程pid相同</p><p>pid 1 通常为init process， 会在启动结束时被kernel invoke其program file在/etc/init （老版本的UNIX系统）或者/sbin/init   （较新版本。 这个进程负责bring up unix system after kernel has been bootstrapped by reading system-dependent initialization files: the /etc/rc* files or /etc/inittab and the files in /etc/init.d. 来带系统进入一定的状态：比如多用户状态。</p><p>init process is a user process (with superuser privileges) that never dies.</p><p>例子： mac os X 10.4里的launchd process</p><p>通常每个unix系统有自己的内核进程， 有的系统pid2时pagedaemon 负责支持系统虚拟内存paging</p><p>以下所有函数都没有error return</p><p><img src="/img_rand/a1.png" alt=""></p><h2 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h2><p>现存进程可以用fork来创建新进程</p><p><img src="/img_rand/a2.png" alt=""></p><p>这个函数被call一次会返回两次</p><p>在子进程中返回值为0 原因：子进程只能有一个父进程 可以getppid来获得</p><p>parent process返回值为子进程pid 原因：避免子进程pid被其他进程获</p><p>子进程父进程在fork之后会继续执行接下来的命令</p><p>The child is a copy of the parent. For example, the child gets a copy of the parent’s data space, heap, and stack. 但是会share text segment</p><p>Modern implementations don’t perform a complete copy of the parent’s data, stack, and heap, since a fork is often followed by an exec. Instead, a technique called copy-on-write (COW) is used. These regions are shared by the parent and the child and have their protection changed by the kernel to read-only. If either process tries to modify these regions, the kernel then makes a copy of that piece of memory only, typically a ‘‘page’’ in a virtual memory system. </p><p><img src="/img_rand/a3.png" alt=""></p><p>通常父子进程执行顺序是nondeterministic的 这取决与kernel的调度算法</p><p>若需要sychronize action 可以使用如上代码中的sleep来使父进程等待子进程的执行， 但我们没有保证2秒的时间是合适的</p><p>其他同步方式 race conditions section 8.9  signal section 10.16</p><p>sizeof 和 strlen的 区别：</p><p>When we write to standard output, we subtract 1 from the size of buf to avoid writing the terminating null byte. Although strlen will calculate the length of a string not including the terminating null byte, sizeof calculates the size of the buffer, which does include the terminating null byte. </p><p>Another difference is that using strlen requires a function call, whereas sizeof calculates the buffer length at compile time,(更快) as the buffer is initialized with a known string and its size is fixed.</p><p>为什么打印了两遍？write是没有缓冲的。 stdio库是有缓冲的：stdout如果连接着terminal device 会被line buffered 否则会被fully buffered</p><p>所以刚开始的printf缓存区被清空了 但当我们重定向输出到文件的时候 printf打印了两行。 在第二个情况下 printf在fork前被呼叫了1次，但在呼叫fork后buffer里缓存还在，buffer里的内容被拷贝到子进程 此时父子进程都有这个相同的 内容没被清空的buffer。 最后一个printf appends its data to the existing buffer.进程终止时 缓存区清空.</p>### file shareing<p>当我们重定向父进程的stdout输出的时候 子进程stdout也被重定向</p><p>这是fork的一个特性： all file descriptors that are open in the parent are duplicated in the child. The parent and the child share a file table entry for every open descriptor </p><p>也就是说 父子进程同时进行输出到stdout时 一定要共享file offset. 若父进程输出被重定向，我们需要子进程在输出到stdout时更新父进程file offset。 这样不仅子进程可以在父进程wait时候输出到stdout，在子进程结束输出时父进程可以在同位置继续之前的输出。 如果没有共享file offset 这种互动会很难实现</p><p><img src="/img_rand/a4.png" alt=""></p><p>通常有两种情况来处理 fork之后的descriptors的使用</p><ol><li>父进程等待子进程结束：parent need to do nothing. 任何共享的descriptors会被子进程更新</li><li>父进程子进程都有自己的事情要干：fork之后父子进程各自关闭其不需要的descriptors，open descriptors互不干涉 这种情况常见于网络服务器</li></ol><p>其他被子进程继承的属性：</p><ul><li>Real user ID, real group ID, effective user ID, and effective group ID</li><li>Supplementary group IDs</li><li>Process group ID</li><li>Session ID</li><li>Controlling terminal</li><li>The set-user-ID and set-group-ID flags</li><li>Current working directory</li><li>Root directory</li><li>File mode creation mask</li><li>Signal mask and dispositions</li><li>The close-on-exec flag for any open file descriptors</li><li>Environment</li><li>Attached shared memory segments</li><li>Memory mappings</li><li>Resource limits</li></ul><p>父子进程的区别：</p><ul><li>fork返回值</li><li>pid</li><li>ppid</li><li>子进程的tms_utime, tms_stime, tms_cutime, and tms_cstime值为0</li><li>父进程的文件锁不会被子进程继承</li><li>Pending alarms are cleared for the child.</li><li>The set of pending signals for the child is set to the empty set.</li></ul><p>fork通常失败的原因有 太多进程存在于系统或者 对于当前用户进程数量超过系统限制： CHILD_MAX specifies the maximum number of simultaneous processes per real user ID.</p><p>fork 的两种使用</p><ul><li>当一个进程想要自我复制从而 父子进程同时执行一片相同的代码时：常见于网络服务器 the parent waits for a service request from a client. When the request arrives, the parent calls fork and lets the child handle the request. The parent goes back to waiting for the next service request to arrive. </li><li>当一个进程想要执行一个不同的程序 这种情况下通常子进程使用exec right after it returns from the fork.（spawn by some other OS）</li></ul>## wait<p>When a process terminates, either normally or abnormally, the kernel notifies the parent by sending the SIGCHLD signal to the parent.</p><p>Because the termination of a child is an asynchronous event—it can happen at any time while the parent is running—this signal is the asynchronous notification from the kernel to the parent.</p><p>The parent can choose to ignore this signal, or it can provide a function that is called when the signal occurs: a signal handler. </p><p>The default action for this signal is to be ignored.</p><p>For now, we need to be aware that a process that calls wait or waitpid can:</p><ul><li>Block, if all of its children are still running</li><li>Return immediately with the termination status of a child, if a child has terminated and is waiting for its termination status to be fetched</li><li>Return immediately with an error, if it doesn’t have any child processes</li></ul><p>If the process is calling wait because it received the SIGCHLD signal, we expect wait to return immediately. But if we call it at any random point in time, it can block.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程控制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程控制&quot;&gt;&lt;/a&gt; 进程控制&lt;/h1&gt;
&lt;ul&gt;
	&lt;li&gt;pid&lt;/li&gt;
	&lt;li&gt;fork&lt;/li&gt;
	&lt;li&gt;wait&lt;/li&gt;
	&lt;li&gt;exec&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
    
      <category term="OS" scheme="http://th2zz.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Automata, language, and computational complexity</title>
    <link href="http://th2zz.github.io/2018/12/24/TCS/"/>
    <id>http://th2zz.github.io/2018/12/24/TCS/</id>
    <published>2018-12-25T01:22:41.000Z</published>
    <updated>2019-03-20T21:15:44.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考课程内容-httpscoursesengrillinoiseducs373sp2013lectures"><a class="markdownIt-Anchor" href="#参考课程内容-httpscoursesengrillinoiseducs373sp2013lectures"></a> <strong>参考课程内容</strong> <a href="https://courses.engr.illinois.edu/cs373/sp2013/Lectures/" target="_blank" rel="noopener">https://courses.engr.illinois.edu/cs373/sp2013/Lectures/</a></h2><h4 id="nfa-to-dfa-subset-construction"><a class="markdownIt-Anchor" href="#nfa-to-dfa-subset-construction"></a> <strong>NFA to DFA subset construction</strong></h4><p><a href="https://www.youtube.com/watch?v=Y92dtMnarAU&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;index=19" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Y92dtMnarAU&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;index=19</a></p><h4 id="ε-nfa-to-nfa-algorithm"><a class="markdownIt-Anchor" href="#ε-nfa-to-nfa-algorithm"></a> <strong>ε-NFA to NFA Algorithm</strong></h4><p><a href="https://www.youtube.com/watch?v=Jz4YQ09nOxA&amp;index=44&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Jz4YQ09nOxA&amp;index=44&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev</a></p><h4 id="dfa-to-regular-expression-state-elimination"><a class="markdownIt-Anchor" href="#dfa-to-regular-expression-state-elimination"></a> <strong>DFA to regular expression State Elimination</strong></h4><p><a href="https://www.youtube.com/watch?v=fyJumUElTGY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=fyJumUElTGY</a></p><h4 id="dfa-to-regex-dynamic-programmingtransitive-closure-method"><a class="markdownIt-Anchor" href="#dfa-to-regex-dynamic-programmingtransitive-closure-method"></a> <strong>DFA to regex Dynamic programming/transitive closure method</strong></h4><p><a href="https://www.classes.cs.uchicago.edu/archive/2015/winter/28000-1/Lec2.pdf" target="_blank" rel="noopener">https://www.classes.cs.uchicago.edu/archive/2015/winter/28000-1/Lec2.pdf</a><br><a href="https://www.cs.dartmouth.edu/~ac/Teach/CS39-Winter09/SlidesAndNotes/lec09dfa2regexp.pdf" target="_blank" rel="noopener">https://www.cs.dartmouth.edu/~ac/Teach/CS39-Winter09/SlidesAndNotes/lec09dfa2regexp.pdf</a><br><a href="https://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions</a></p><h4 id="closure-properties-of-regular-language-regular-expression"><a class="markdownIt-Anchor" href="#closure-properties-of-regular-language-regular-expression"></a> <strong>Closure properties of regular language &amp; regular expression</strong></h4><p><img src="/img_520/1.png" alt=""><br><img src="/img_520/2.png" alt=""><br><img src="/img_520/3.png" alt=""></p><h4 id="regex-to-nfa-translation"><a class="markdownIt-Anchor" href="#regex-to-nfa-translation"></a> <strong>Regex to nfa translation</strong></h4><p><img src="/img_520/4.png" alt=""></p><h4 id="dfa-minimization-algorithm"><a class="markdownIt-Anchor" href="#dfa-minimization-algorithm"></a> <strong>Dfa minimization algorithm</strong></h4><p>Minimization of DFA - Table Filling Method (Myhill-Nerode Theorem)<br><img src="/img_520/5.png" alt=""></p><h4 id="myhill-nerode-theorem"><a class="markdownIt-Anchor" href="#myhill-nerode-theorem"></a> <strong>Myhill-nerode theorem</strong></h4><p><img src="/img_520/6.png" alt=""><br>Further more there is a minimized dfa having precisely one state for each equivalence class!!!<br><strong>equivalence classes classification</strong>: how to tell what equivalence classes are there?<br><a href="https://courses.cs.washington.edu/courses/cse322/05wi/handouts/MyhillNerode.pdf" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse322/05wi/handouts/MyhillNerode.pdf</a><br>Regular: we can use above algorithm on DFA minimization to find out each equivalence classes<br>Nonregular:<br><img src="/img_520/7.png" alt=""></p><h4 id="pumping-lemma-prove-nonregular-language"><a class="markdownIt-Anchor" href="#pumping-lemma-prove-nonregular-language"></a> <strong>Pumping lemma prove nonregular language</strong></h4><p><img src="/img_520/8.png" alt=""></p><p>Testing regularity finite language is regular  infinite language can be tested by pumping lemma</p><h4 id="testing-whether-a-language-is-regular-or-not"><a class="markdownIt-Anchor" href="#testing-whether-a-language-is-regular-or-not"></a> <strong>Testing whether a language is regular or not</strong></h4><p><a href="https://www.youtube.com/watch?v=KSczX111n3U" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KSczX111n3U</a></p><h4 id="cfg-design-regular-language-to-cfg"><a class="markdownIt-Anchor" href="#cfg-design-regular-language-to-cfg"></a> <strong>CFG DESIGN  Regular language to CFG,</strong></h4><p><img src="/img_520/9.png" alt=""><br>对每一个dfa的state设计一个nonterminal variable；<br>对于每个transition  add 相应的rule   （根据不同的input）<br>对于accepting state的nonterminal variable 让他生成空的string<br>This cfg generates the same language that dfa recognizes.</p><h4 id="ambiguity"><a class="markdownIt-Anchor" href="#ambiguity"></a> <strong>AMBIGUITY</strong></h4><p>A string is derived ambiguously if it has one or more left/right most derivation tree.<br>A Grammar G is ambiguous if it generates some string ambiguously.</p><h4 id="chompsky-normal-form"><a class="markdownIt-Anchor" href="#chompsky-normal-form"></a> <strong>Chompsky Normal Form</strong></h4><p>(CFG simplification: removal of null ε production + unit production elimination + adding auxiliary variable &amp; rewrite)<br><a href="https://www.youtube.com/watch?v=EF09zxzpVbk&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;t=5s&amp;index=76" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EF09zxzpVbk&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;t=5s&amp;index=76</a><br><img src="/img_520/10.png" alt=""></p><p><img src="/img_520/11.png" alt=""><br><img src="/img_520/12.png" alt=""><br>For each direct null production A-&gt; null , look for all productions whose right hand side contains A. Replace each occurrences of A in these production with null.  By each occurences, it means all possible location of A that can be nullified. Finsh the resulting productions without A-&gt;null, looking for the next one for ex B-&gt;null until no null productions exist.</p><p><strong>Or a graph-algorithm:</strong><br>Create a directed cyclic graph where each vertex represent a nonterminal for all nonterminals.<br>Add an edge if there is a unit production.<br>Collapse all strongly connected components into a single vertex (meaning these nonterminal are equivalent, merge their production rules in the grammar)<br>Start from sink S, augment production rules of the sink to all nonterminals that go to sink, then remove the edges from all nonterminals that go to sink.  Repeat this until no edges exist</p><p><strong>CYK algorithm O(n^3)<br>(Dynamic Programming parsing/recognizing if a string is in the language of cfg)<br>Assume in put is in CNF form.</strong><br><img src="/img_520/13.png" alt=""><br>For example, to parse <strong>“id ( id , id )” 6 character sequence,</strong> we construct 6 by 6 grid with diagonals filled in all possible nonterminal that can derive the i-th symbol for i=1 to i=6.<br><img src="/img_520/14.png" alt=""><br>Then we fill in each successive diagonals bottom up:<br>For each square, consider ALL possible ordered pair of the nonterminals one from left one from below, for each pair, if it can be derived from a rule(notice we have cnf), we put the lhs nonterminal of that rule to that squares<br><img src="/img_520/15.png" alt=""><br>If the starting nonterminal appear in the upper right corner of the grid we accept the string</p><p><strong>Non determinstic Push down automata<br>Equivalence of cfg and nondeterminstic pda :</strong><br>A language is generated by a cfg = it is recognized by a npda<br><a href="https://people.eecs.berkeley.edu/~sseshia/172/lectures/Slides8.pdf" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sseshia/172/lectures/Slides8.pdf</a><br><img src="/img_520/16.png" alt=""></p><p>For example.<br><img src="/img_520/17.png" alt=""><br><img src="/img_520/18.png" alt=""><br><img src="/img_520/19.png" alt=""><br><img src="/img_520/20.png" alt=""></p><p><strong>Non context-free language</strong>:<br><img src="/img_520/21.png" alt=""></p><blockquote><p>For any context free language L, there is a pumping length p such that for any string<br>z ∈  L of sufficient length p≥1 or more, there is a decomposition of string z into 5−PART uvwxy s.t.:</p><ol><li>|vwx|≤p    middle three≤p (not too far apart)</li><li>|vx|&gt;0 pumping part of length nonegative</li><li>for any i≥0  uv^i wx^i y  stays in L<br><img src="/img_520/22.png" alt=""><br><strong>Both CFG-PL AND REG-PL are necessary but not sufficient conditions for context-freeness/regularity.</strong></li></ol></blockquote><p><strong>pumping lemma proof idea:</strong> for a sufficiently long string and its parse tree, the longest path in the tree by pigenhole principle must have nonterminals that repeat. Therefore Pumping up or down vx, it will remains a valid parse tree</p><p><strong>Language hierarchy &amp; Decidable and recognizable language</strong><br><img src="/img_520/23.png" alt=""><br>A <strong>decision problem</strong> can be expressed as a language, which is a set<br>A language is called a Recursively enumerable set (language) [also recognizable, partially decidable, semidecidable, Turing-acceptable or Turing-recognizable] if it is a recursively enumerable subset in the set of all possible words over the alphabet of the language, i.e., if there exists a Turing machine which will enumerate all valid strings of the language.</p><p>Recursive set, decidable set, computable set refers to the set of decision problem that are decidable in polynomial time</p><p>A complete set is a set of problems that are “hard”:<br>Np hard: every problem in np can reduce to it<br>Ex. To prove np-complete  first show it is np, then prove it is np hard, namely choose a np complete problem and reduce to it<br><img src="/img_520/24.png" alt=""><br><a href="https://en.wikipedia.org/wiki/Complete_(complexity)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Complete_(complexity)</a></p><p><img src="/img_520/25.png" alt=""><br><img src="/img_520/26.png" alt=""><br><img src="/img_520/27.png" alt=""></p><p><strong>Proving problems undecidable<br>Turing machine and halting problem</strong><br>Refers to handouts<br><img src="/img_520/28.png" alt=""><br><img src="/img_520/29.png" alt=""><br><strong>多带图灵机与单带图灵机等价</strong><br>A turing machine accepts input if there is a sequence of configuration from starting config to accepting config<br>A turing machine is decidable if there is some decider for it(always halt and acc or rej).<br>Every NDTM has a equivalent DTM<br>ATM, HaltTM, Etm, Eqtm, PCP is undecidable but Turing-recognizable/recursively enumerable<br><img src="/img_520/30.png" alt=""><br><img src="/img_520/31.png" alt=""></p><p><strong>Undecidability and Rice’s theorem<br>Rice’s theorem:</strong><br><img src="/img_520/32.png" alt=""><br>A property is a set of Turing machine. A TM satisfies P means TM is in the set.<br>A property P is nontrivial means there is a TM that satisfies it and there is a TM that does not satisfies it.<br>A property P is trivial means either it is satisfied by all TMs or it is satisfied by no TMs.</p><p>Any nontrivial property about the r.e. language recognized by a Turing machine is undecidable.</p><p><strong>Reduction</strong> <a href="https://en.wikipedia.org/wiki/Reduction_(complexity)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reduction_(complexity)</a><br>A reduces to B means we can use an efficient solution of B as a subroutine to solve A     hardness of B 大于等于 A<br><strong>Computational complexity</strong><br><a href="https://blog.csdn.net/golden1314521/article/details/51470999" target="_blank" rel="noopener">https://blog.csdn.net/golden1314521/article/details/51470999</a></p><p>NP completeness theory is designed to be applied only to decision problem.<br>解决一个decision problem 等价于recognizing a corresponding language<br>A language is a set that contains all strings accepted by the turing machine.<br><strong>Class P</strong>： 以单带图灵机定义的【 所有多项式时间内deterministically recognizable language】<br><strong>Class NP</strong>: NTM Augmented Model of one tape turing machine with guessing ability<br>NTM 定义了 class NP: All languages recognizable nondeterministically in Polynomial time / there is a polynomial time NDTM program that accepts the language<br>NP is the class of languages that have polynomial time verifiers for the membership of an arbitrary instance given.<br><img src="/img_520/33.png" alt=""></p><p>A p-time mapping reduce to B means:  there is a transformation function that given an instance a of A 包装成 instance of B f(a)=b in polynomial time such that membership of  a and b in A and B. resp 同进同出</p><p>多项式时间于伪多项式时间<br>动态规划解决subsetsum</p><h4 id="textbook-reference"><a class="markdownIt-Anchor" href="#textbook-reference"></a> <strong>Textbook Reference</strong></h4><p>Computers and Intractability A Guide to the Theory of NP Completeness -  Michael R. Garey and David S. Johnson<br>Introduction to the theory of computation third edition - Michael Sipser<br>Introduction To Automata Theory, Languages, And Computation 3rd - John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考课程内容-httpscoursesengrillinoiseducs373sp2013lectures&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考课程内容-httpscoursesengrillinoiseducs373sp
      
    
    </summary>
    
    
      <category term="Theory of computation" scheme="http://th2zz.github.io/tags/Theory-of-computation/"/>
    
  </entry>
  
  <entry>
    <title>real analysis</title>
    <link href="http://th2zz.github.io/2018/12/09/real-analysis/"/>
    <id>http://th2zz.github.io/2018/12/09/real-analysis/</id>
    <published>2018-12-09T18:00:41.000Z</published>
    <updated>2019-02-04T21:04:45.743Z</updated>
    
    <content type="html"><![CDATA[<p>summary and notes upon compeletion of the course and self study notes.<br><a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/real_analysis.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/real_analysis.pdf</a><br>Textbook reference<br>Principles of Mathematical Analysis - Rudin<br>Analysis I - Terrence Tao</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;summary and notes upon compeletion of the course and self study notes.&lt;br&gt;
&lt;a href=&quot;https://github.com/th2zz/th2zz.github.io/blob/master/
      
    
    </summary>
    
    
      <category term="Math" scheme="http://th2zz.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Programming language and Compiler</title>
    <link href="http://th2zz.github.io/2018/12/08/Compiler/"/>
    <id>http://th2zz.github.io/2018/12/08/Compiler/</id>
    <published>2018-12-09T03:40:41.000Z</published>
    <updated>2019-03-22T21:02:39.161Z</updated>
    
    <content type="html"><![CDATA[<p>summary &amp; notes upon compeletion of course on programming language and compiler<br><a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/CS536.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/CS536.pdf</a><br>Textbook reference<br>Engineering a compiler. [Keith_D._Cooper_Linda_Torczon]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;summary &amp;amp; notes upon compeletion of course on programming language and compiler&lt;br&gt;
&lt;a href=&quot;https://github.com/th2zz/th2zz.github.io
      
    
    </summary>
    
    
      <category term="Compiler" scheme="http://th2zz.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Math431-probability theory</title>
    <link href="http://th2zz.github.io/2018/12/01/probability/"/>
    <id>http://th2zz.github.io/2018/12/01/probability/</id>
    <published>2018-12-02T04:30:02.000Z</published>
    <updated>2019-02-04T20:44:28.643Z</updated>
    
    <content type="html"><![CDATA[<p>notes collection<br><a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/probability.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/probability.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;notes collection&lt;br&gt;
&lt;a href=&quot;https://github.com/th2zz/th2zz.github.io/blob/master/notes/probability.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
      <category term="Math" scheme="http://th2zz.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Digital system fundamental</title>
    <link href="http://th2zz.github.io/2018/05/21/Digital-system-fundamental/"/>
    <id>http://th2zz.github.io/2018/05/21/Digital-system-fundamental/</id>
    <published>2018-05-22T00:43:32.000Z</published>
    <updated>2019-02-04T20:26:06.050Z</updated>
    
    <content type="html"><![CDATA[<p>summary and notes upon compeletion of the course.<br><a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/digital_circuit.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/digital_circuit.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;summary and notes upon compeletion of the course.&lt;br&gt;
&lt;a href=&quot;https://github.com/th2zz/th2zz.github.io/blob/master/notes/digital_circuit
      
    
    </summary>
    
    
      <category term="Computer Science" scheme="http://th2zz.github.io/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>CS540 Intro to AI Notesheet</title>
    <link href="http://th2zz.github.io/2018/05/19/ai/"/>
    <id>http://th2zz.github.io/2018/05/19/ai/</id>
    <published>2018-05-19T18:00:41.000Z</published>
    <updated>2019-03-20T22:42:14.864Z</updated>
    
    <content type="html"><![CDATA[<img width="1000" src="/img_540/1.png"><img width="1000" src="/img_540/2.png"><img width="1000" src="/img_540/3.png"><img width="1000" src="/img_540/4.png"><img width="1000" src="/img_540/5.png"><img width="1000" src="/img_540/6.png"><img width="1000" src="/img_540/7.png"><img width="1000" src="/img_540/8.png"><img width="1000" src="/img_540/9.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img width=&quot;1000&quot; src=&quot;/img_540/1.png&quot;&gt;
&lt;img width=&quot;1000&quot; src=&quot;/img_540/2.png&quot;&gt;
&lt;img width=&quot;1000&quot; src=&quot;/img_540/3.png&quot;&gt;
&lt;img width=&quot;1000&quot; sr
      
    
    </summary>
    
    
      <category term="Computer Science" scheme="http://th2zz.github.io/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>CS577 Algorithm Notesheet</title>
    <link href="http://th2zz.github.io/2018/05/05/algorithm/"/>
    <id>http://th2zz.github.io/2018/05/05/algorithm/</id>
    <published>2018-05-06T00:00:01.000Z</published>
    <updated>2019-03-20T20:46:17.321Z</updated>
    
    <content type="html"><![CDATA[<img width="1000" src="/img_algo/1.png"><img width="1000" src="/img_algo/2.png"><img width="1000" src="/img_algo/3.png"><img width="1000" src="/img_algo/4.png"><img width="1000" src="/img_algo/5.png"><img width="1000" src="/img_algo/6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img width=&quot;1000&quot; src=&quot;/img_algo/1.png&quot;&gt;
&lt;img width=&quot;1000&quot; src=&quot;/img_algo/2.png&quot;&gt;
&lt;img width=&quot;1000&quot; src=&quot;/img_algo/3.png&quot;&gt;
&lt;img width=&quot;1000&quot;
      
    
    </summary>
    
    
      <category term="Math" scheme="http://th2zz.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Linear algebra</title>
    <link href="http://th2zz.github.io/2017/12/11/Linear-algebra/"/>
    <id>http://th2zz.github.io/2017/12/11/Linear-algebra/</id>
    <published>2017-12-11T19:45:24.000Z</published>
    <updated>2019-02-04T21:02:43.787Z</updated>
    
    <content type="html"><![CDATA[<p>summary and notes upon compeletion of the course &amp; self study notes.<br><a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/linear_algebra.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/linear_algebra.pdf</a></p><p>Textbook Reference<br>Introduction to Linear Algebra 4th Edition by Gilbert Strang<br>Applied Linear Algebra (Undergraduate Texts in Mathematics) 2nd ed. 2018 Edition by Peter J. Olver, Chehrzad Shakiban</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;summary and notes upon compeletion of the course &amp;amp; self study notes.&lt;br&gt;
&lt;a href=&quot;https://github.com/th2zz/th2zz.github.io/blob/maste
      
    
    </summary>
    
    
      <category term="Math" scheme="http://th2zz.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>chmod</title>
    <link href="http://th2zz.github.io/2017/09/29/chmod/"/>
    <id>http://th2zz.github.io/2017/09/29/chmod/</id>
    <published>2017-09-30T03:42:32.000Z</published>
    <updated>2019-03-20T22:42:02.951Z</updated>
    
    <content type="html"><![CDATA[<p>修改文件或目录的访问权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">chmod --help</span><br><span class="line"></span><br><span class="line">Usage: chmod [OPTION]... MODE[,MODE]... FILE...</span><br><span class="line">  or:  chmod [OPTION]... OCTAL-MODE FILE...</span><br><span class="line">  or:  chmod [OPTION]... --reference=RFILE FILE...</span><br><span class="line">Change the mode of each FILE to MODE.</span><br><span class="line">With --reference, change the mode of each FILE to that of RFILE.</span><br><span class="line"></span><br><span class="line">  -c, --changes          like verbose but report only when a change is made</span><br><span class="line">  -f, --silent, --quiet  suppress most error messages</span><br><span class="line">  -v, --verbose          output a diagnostic for every file processed</span><br><span class="line">      --no-preserve-root  do not treat '/' specially (the default)</span><br><span class="line">      --preserve-root    fail to operate recursively on '/'</span><br><span class="line">      --reference=RFILE  use RFILE's mode instead of MODE values</span><br><span class="line">  -R, --recursive        change files and directories recursively</span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br><span class="line"></span><br><span class="line">Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.</span><br></pre></td></tr></table></figure><p><a href="https://en.wikipedia.org/wiki/File_system_permissions" title="File_system_permissions" target="_blank" rel="noopener">文件系统权限</a> 是 <a href="https://en.wikipedia.org/wiki/File_system" title="File_system" target="_blank" rel="noopener">文件系统</a> 用来管理用户和用户组对文件或目录的访问权限的规则。</p><p>###用户</p><p>文件和目录归属于用户(owner)，<br>分配给用户组(group)，owner 是 group 的成员；<br>非 owner 和非 group 成员的用户属于其他用户(others)；<br>还有所有用户(all)。</p><p>###访问权限</p><ul><li>read 读取文件（当作用与目录时，仅能获取目录下所有文件的文件名）；</li><li>write 修改文件（当作用与目录时，可以对文件执行创建、删除和重命名操作）；</li><li>execute 执行文件（shell 脚本或可执行文件。当作用与目录时，可以获得文件内容和元信息，但不能获得文件列表）</li></ul><p>###符号模式</p><p>r read;<br>w write;<br>x execute.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 hu hu  0  3月 31 15:19 test.txt</span><br></pre></td></tr></table></figure><p><code>-rw-r--r--</code> 代表了文件类型和文件权限：</p><p>第一位 <code>-</code> 代表了文件为普通文件（参考 <a href="https://en.wikipedia.org/wiki/Unix_file_types" title="Unix_file_types" target="_blank" rel="noopener">文件类型</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Regular file</span><br><span class="line">d Directory</span><br><span class="line">l Symbolic link</span><br><span class="line">p Named pipe</span><br><span class="line">s Socket</span><br><span class="line">c Device file(character device)</span><br><span class="line">b Device file(block device)</span><br><span class="line">D Door</span><br></pre></td></tr></table></figure><p>后面九位分成三段，分别代表了 owner/group/others 三类用户的访问权限，<code>-</code> 代表没有对应权限：<br>owner 拥有 read/write 权限；group 和 others 只拥有 read 权限。</p><p>###数字模式</p><p>| 符号 | 代码 | 权限 |<br>|  |  |  |<br>| r | 4/100 | read |<br>| w | 2/10 | write |<br>| x | 1/1 | execute |<br>| - | 0/0 | - |</p><p><code>-rw-r--r--</code> 可以用数字表示为 <code>0644</code>。</p><p>###MODE 规则</p><p><code>[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+</code> 被用来校验 <code>chmod</code> 命令中的 MODE 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u user 所有者</span><br><span class="line">g group 所有者所在分组</span><br><span class="line">o others 所有其他用户</span><br><span class="line">a all 所有用户（等同于 ugo）</span><br><span class="line"></span><br><span class="line">+ 添加权限</span><br><span class="line">- 删除权限</span><br><span class="line">= 设置权限</span><br></pre></td></tr></table></figure><p><img src="/img_rand/chmod-regexp.png" alt=""></p><p>可能的 MODE 参数：</p><ul><li><code>chmod a+w test.txt</code> 给所有用户添加 test.txt 的写权限；</li><li><code>chmod u=rwx app.js app.js</code> 的所有者拥有对该文件的读写和执行权限；</li><li><code>chmod 624 app.js</code> 分别给三组用户不同的权限（u: rw, g: w, o: r）；</li><li><code>chmod 755 ~/works</code> 分别给三组用户不同的权限（u: rwx, g: rx, o: rx）。</li></ul><p>###参考</p><p><a href="https://zh.wikipedia.org/wiki/Chmod" target="_blank" rel="noopener">wiki: Chmod</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;修改文件或目录的访问权限。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://th2zz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>link</title>
    <link href="http://th2zz.github.io/2017/09/21/link/"/>
    <id>http://th2zz.github.io/2017/09/21/link/</id>
    <published>2017-09-22T03:00:41.000Z</published>
    <updated>2019-02-04T20:26:41.418Z</updated>
    
    <content type="html"><![CDATA[<p>用于创建 <a href="https://en.wikipedia.org/wiki/Symbolic_link" title="Symbolic_link" target="_blank" rel="noopener">符号链接</a> 或 <a href="https://en.wikipedia.org/wiki/Hard_link" title="Hard_link" target="_blank" rel="noopener">硬链接</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ln --help</span><br><span class="line"></span><br><span class="line">用法：ln [选项]... [-T] 目标 链接名(第一种格式)</span><br><span class="line">　或：ln [选项]... 目标(第二种格式)</span><br><span class="line">　或：ln [选项]... 目标... 目录(第三种格式)</span><br><span class="line">　或：ln [选项]... -t 目录 目标...(第四种格式)</span><br><span class="line">In the 1st form, create a link to TARGET with the name LINK_NAME.</span><br><span class="line">In the 2nd form, create a link to TARGET in the current directory.</span><br><span class="line">In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.</span><br><span class="line">Create hard links by default, symbolic links with --symbolic.</span><br><span class="line">By default, each destination (name of new link) should not already exist.</span><br><span class="line">When creating hard links, each TARGET must exist.  Symbolic links</span><br><span class="line">can hold arbitrary text; if later resolved, a relative link is</span><br><span class="line">interpreted in relation to its parent directory.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line">      --backup[=CONTROL]为每个已存在的目标文件创建备份文件</span><br><span class="line">  -b类似--backup，但不接受任何参数</span><br><span class="line">  -d, -F, --directory创建指向目录的硬链接(只适用于超级用户)</span><br><span class="line">  -f, --force强行删除任何已存在的目标文件</span><br><span class="line">  -i, --interactive           prompt whether to remove destinations</span><br><span class="line">  -L, --logical               dereference TARGETs that are symbolic links</span><br><span class="line">  -n, --no-dereference        treat LINK_NAME as a normal file if</span><br><span class="line">                                it is a symbolic link to a directory</span><br><span class="line">  -P, --physical              make hard links directly to symbolic links</span><br><span class="line">  -r, --relative              create symbolic links relative to link location</span><br><span class="line">  -s, --symbolic              make symbolic links instead of hard links</span><br><span class="line">  -S, --suffix=SUFFIX         override the usual backup suffix</span><br><span class="line">  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to create</span><br><span class="line">                                the links</span><br><span class="line">  -T, --no-target-directory   treat LINK_NAME as a normal file always</span><br><span class="line">  -v, --verbose               print name of each linked file</span><br><span class="line">      --help显示此帮助信息并退出</span><br><span class="line">      --version显示版本信息并退出</span><br><span class="line"></span><br><span class="line">The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.</span><br><span class="line">The version control method may be selected via the --backup option or through</span><br><span class="line">the VERSION_CONTROL environment variable.  Here are the values:</span><br><span class="line"></span><br><span class="line">  none, off       不进行备份(即使使用了--backup 选项)</span><br><span class="line">  numbered, t     备份文件加上数字进行排序</span><br><span class="line">  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份</span><br><span class="line">  simple, never   永远使用普通方式备份</span><br><span class="line"></span><br><span class="line">Using -s ignores -L and -P.  Otherwise, the last option specified controls</span><br><span class="line">behavior when a TARGET is a symbolic link, defaulting to -P.</span><br></pre></td></tr></table></figure><p>###查看</p><p><code>ls -l</code> 可以查看文件是否为链接文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin</span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 root root      24  3月 18 14:25 netcat -&gt; /etc/alternatives/netcat</span><br></pre></td></tr></table></figure><p>l 代表文件是链接文件；<br>netcat 是指向 /etc/alternatives/netcat 的一个文件链接。</p><p>###创建</p><ul><li><code>ln -s target link</code> 创建一个名为 link 的文件，链接到 target 文件；</li><li><code>ln -s target</code> 在当前目录创建一个链接到 target 的文件，与 target 同名；</li><li><code>ln -s targets link_dir</code> 在 link_dir 目录创建所有 targets 的链接。</li></ul><p>###参考</p><p><a href="https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">wiki: 符号链接</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用于创建 &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbolic_link&quot; title=&quot;Symbolic_link&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;符号链接&lt;/a&gt; 或 &lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://th2zz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>chown</title>
    <link href="http://th2zz.github.io/2017/08/29/chown/"/>
    <id>http://th2zz.github.io/2017/08/29/chown/</id>
    <published>2017-08-30T01:31:52.000Z</published>
    <updated>2019-03-20T22:36:16.839Z</updated>
    
    <content type="html"><![CDATA[<p>修改文件或目录的所有者或（和）用户组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">chown --help</span><br><span class="line"></span><br><span class="line">Usage: chown [OPTION]... [OWNER][:[GROUP]] FILE...</span><br><span class="line">  or:  chown [OPTION]... --reference=RFILE FILE...</span><br><span class="line">Change the owner and/or group of each FILE to OWNER and/or GROUP.</span><br><span class="line">With --reference, change the owner and group of each FILE to those of RFILE.</span><br><span class="line"></span><br><span class="line">  -c, --changes          like verbose but report only when a change is made</span><br><span class="line">  -f, --silent, --quiet  suppress most error messages</span><br><span class="line">  -v, --verbose          output a diagnostic for every file processed</span><br><span class="line">      --dereference      affect the referent of each symbolic link (this is</span><br><span class="line">                         the default), rather than the symbolic link itself</span><br><span class="line">  -h, --no-dereference   affect symbolic links instead of any referenced file</span><br><span class="line">                         (useful only on systems that can change the</span><br><span class="line">                         ownership of a symlink)</span><br><span class="line">      --from=CURRENT_OWNER:CURRENT_GROUP</span><br><span class="line">                         change the owner and/or group of each file only if</span><br><span class="line">                         its current owner and/or group match those specified</span><br><span class="line">                         here.  Either may be omitted, in which case a match</span><br><span class="line">                         is not required for the omitted attribute</span><br><span class="line">      --no-preserve-root  do not treat '/' specially (the default)</span><br><span class="line">      --preserve-root    fail to operate recursively on '/'</span><br><span class="line">      --reference=RFILE  use RFILE's owner and group rather than</span><br><span class="line">                         specifying OWNER:GROUP values</span><br><span class="line">  -R, --recursive        operate on files and directories recursively</span><br><span class="line"></span><br><span class="line">The following options modify how a hierarchy is traversed when the -R</span><br><span class="line">option is also specified.  If more than one is specified, only the final</span><br><span class="line">one takes effect.</span><br><span class="line"></span><br><span class="line">  -H                     if a command line argument is a symbolic link</span><br><span class="line">                         to a directory, traverse it</span><br><span class="line">  -L                     traverse every symbolic link to a directory</span><br><span class="line">                         encountered</span><br><span class="line">  -P                     do not traverse any symbolic links (default)</span><br><span class="line"></span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br><span class="line"></span><br><span class="line">Owner is unchanged if missing.  Group is unchanged if missing, but changed</span><br><span class="line">to login group if implied by a ':' following a symbolic OWNER.</span><br><span class="line">OWNER and GROUP may be numeric as well as symbolic.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  chown root /u        Change the owner of /u to "root".</span><br><span class="line">  chown root:staff /u  Likewise, but also change its group to "staff".</span><br><span class="line">  chown -hR root /u    Change the owner of /u and subfiles to "root".</span><br></pre></td></tr></table></figure><p>###查看归属信息</p><p><code>ls -l</code> 命令可以看到文件的拥有者和用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 root hu 27  3月 18 16:50 hello.js</span><br></pre></td></tr></table></figure><p>root owner;<br>hu group.</p><p>###修改归属</p><ul><li><code>sudo chown hu hello.js</code> 将 hello.js 的 owner 改为 hu；</li><li><code>sudo chown root:root hello.js</code> 将 hello.js 的 owner 改为 root，group 改为 root。</li></ul><p>注意：<code>chown</code> 命令只能被 root 用户执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;修改文件或目录的所有者或（和）用户组。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://th2zz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello world</title>
    <link href="http://th2zz.github.io/2017/08/12/hello-world/"/>
    <id>http://th2zz.github.io/2017/08/12/hello-world/</id>
    <published>2017-08-13T01:31:52.000Z</published>
    <updated>2019-02-04T20:25:38.218Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
