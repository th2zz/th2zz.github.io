<!DOCTYPE html>
<html lang="en">

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     th2zz
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/assets/torr3.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

</head>

</html>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    <main class="content">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">th2zz</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Operating System - Virtualization" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/03/16/Operating System - Virtualization/"
    >Operating System - Virtualization</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/03/16/Operating System - Virtualization/" class="article-date">
  <time datetime="2019-03-15T20:06:41.000Z" itemprop="datePublished">2019-03-15</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="cs537-operating-system-summary-part-1-virtualization"><a class="markdownIt-Anchor" href="#cs537-operating-system-summary-part-1-virtualization"></a> <strong>CS537 - Operating System Summary Part 1 Virtualization</strong></h1>
<h1 id="virtualization"><a class="markdownIt-Anchor" href="#virtualization"></a> Virtualization</h1>
<h2 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process</h2>
<h3 id="what-is-a-process"><a class="markdownIt-Anchor" href="#what-is-a-process"></a> What is a process</h3>
<ul>
<li>A running program is a process</li>
<li>Stream of executing instructions and their “context”</li>
</ul>
<h3 id="thread"><a class="markdownIt-Anchor" href="#thread"></a> Thread</h3>
<ul>
<li>Can have multiple threads within a single process</li>
<li>Lightweight process</li>
<li>Share an address space</li>
</ul>
<h3 id="why-do-we-need-processes"><a class="markdownIt-Anchor" href="#why-do-we-need-processes"></a> Why do we need processes?</h3>
<ul>
<li>Share CPU: Time sharing</li>
</ul>
<h3 id="os-scheduler"><a class="markdownIt-Anchor" href="#os-scheduler"></a> OS Scheduler</h3>
<ul>
<li>Scheduler save context when process is pause</li>
<li>Restore context on resumption</li>
</ul>
<h3 id="goals-for-cpu-virtualization"><a class="markdownIt-Anchor" href="#goals-for-cpu-virtualization"></a> Goals for CPU Virtualization</h3>
<ul>
<li>
<p>Policy goals</p>
<ul>
<li>Virtualize CPU resource using processes</li>
<li>Reschedule process for fairness? efficiency?</li>
</ul>
</li>
<li>
<p>Mechanism goals</p>
<ul>
<li>Efficiency: Time sharing should not add overhead</li>
<li>Control: OS should be able to intervene when required</li>
</ul>
</li>
</ul>
<h2 id="mechanism"><a class="markdownIt-Anchor" href="#mechanism"></a> Mechanism</h2>
<h3 id="system-call"><a class="markdownIt-Anchor" href="#system-call"></a> System call</h3>
<ul>
<li>
<p>User mode and kernel mode</p>
<ul>
<li>User processes run in user mode (restricted mode)</li>
<li>OS runs in kernel mode (not restricted)</li>
</ul>
</li>
<li>
<p>System call</p>
<ul>
<li>Separate user mode from kernel mode for security</li>
<li>Use system call to invoke kernel mode functions</li>
</ul>
</li>
<li>
<p>Procedure for calling read()</p>
<ol>
<li>Set system call table index to 6 <code>movl $6, %eax</code></li>
<li>Call trap with id 64 <code>int $64</code></li>
</ol>
</li>
</ul>
<p><img src="https://i.imgur.com/7hmjTrj.png" alt=""></p>
<h3 id="dispatch-mechanism"><a class="markdownIt-Anchor" href="#dispatch-mechanism"></a> Dispatch mechanism</h3>
<ul>
<li>
<p>Dispatch loop</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;	</span><br><span class="line">    run	process	A for some time-slice	</span><br><span class="line">    stop process A and save its context	</span><br><span class="line">    load context of another process B	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Cooperative Multi-tasking</p>
<ul>
<li>Trust process to relinquish CPU through traps</li>
<li>Provide special yield() system call</li>
<li>Processes can <strong>misbehave</strong></li>
</ul>
</li>
<li>
<p>Timer-based Multi-tasking</p>
<ul>
<li>Hardware generates timer interrupt (CPU or separate chip)</li>
<li>User must not be able to mask timer interrupt</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/eE325zz.png" alt=""></p>
<h2 id="policy"><a class="markdownIt-Anchor" href="#policy"></a> Policy</h2>
<h3 id="vocabulary"><a class="markdownIt-Anchor" href="#vocabulary"></a> Vocabulary</h3>
<ul>
<li>Workload: set of jobs (arrival time, run_time)</li>
<li>Job ~ Current execution of a process</li>
<li>Scheduler: Decides which ready job to run</li>
<li>Metric: measurement of scheduling quality</li>
<li>Turnaround time = completion time - arrival time</li>
<li>Response time = first run time - arrival time</li>
</ul>
<h3 id="fifo-first-in-first-out"><a class="markdownIt-Anchor" href="#fifo-first-in-first-out"></a> FIFO (First In, First Out)</h3>
<ul>
<li>Disadvantage: Turnaround time suffers when short jobs must wait for long jobs (Convoy Effect)</li>
</ul>
<img src="https://i.imgur.com/p6B5iuB.png" width="75%" style="margin:auto; display: block;">
<h3 id="sjf-shortest-job-first"><a class="markdownIt-Anchor" href="#sjf-shortest-job-first"></a> SJF (Shortest job first)</h3>
<ul>
<li>Disadvantage: Only schedule new job when previous job voluntarily relinquishes CPU</li>
</ul>
<img src="https://i.imgur.com/4L0JHF6.png" width="75%" style="margin:auto; display: block;">
<h3 id="stcf-shortest-time-to-completion-first"><a class="markdownIt-Anchor" href="#stcf-shortest-time-to-completion-first"></a> STCF (Shortest Time-to-Completion First)</h3>
<ul>
<li>Preemptive: Schedule different job by taking CPU away from running job</li>
<li>Always run job that will complete the quickest</li>
</ul>
<img src="https://i.imgur.com/F97B6qw.png" width="75%" style="margin:auto; display: block;">
<h3 id="round-robin"><a class="markdownIt-Anchor" href="#round-robin"></a> Round Robin</h3>
<ul>
<li>Goal: reduce response time</li>
<li>Trade-off: increase turnaround time</li>
</ul>
<img src="https://i.imgur.com/aNCUwiF.png" width="75%" style="margin:auto; display: block;">
<h3 id="io-aware-scheduling"><a class="markdownIt-Anchor" href="#io-aware-scheduling"></a> I/O Aware Scheduling</h3>
<ul>
<li>Goal: process won’t hold CPU when doing IO</li>
</ul>
<img src="https://i.imgur.com/S8TUga8.png" width="75%" style="margin:auto; display: block;">
<h3 id="multilevel-feedback-queue"><a class="markdownIt-Anchor" href="#multilevel-feedback-queue"></a> Multilevel Feedback Queue</h3>
<ul>
<li>
<p>Motivation: Run-time of each job is not known</p>
</li>
<li>
<p>Approach</p>
<ul>
<li>Multiple levels of round-robin</li>
<li>Each level has higher priority than lower level</li>
<li>Can preempt them</li>
</ul>
</li>
<li>
<p>Rules</p>
<ol>
<li>If priority(A) &gt; Priority(B), A runs</li>
<li>If priority(A) == Priority(B), A &amp; B run in RR</li>
<li>Processes start at top priority</li>
<li>If job uses whole slice, demote process (longer time slices at lower priorities)</li>
</ol>
</li>
<li>
<p>Avoid starvation</p>
<ul>
<li>Problem: Low priority job may never get scheduled</li>
<li>Solution: Periodically boost priority of all jobs (or all jobs thathaven’t been scheduled)</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/RL4PuJC.png" width="50%" style="margin:auto; display: block;">
<h1 id="memory-virtualization"><a class="markdownIt-Anchor" href="#memory-virtualization"></a> Memory Virtualization</h1>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<h3 id="goals"><a class="markdownIt-Anchor" href="#goals"></a> Goals</h3>
<ul>
<li><strong>Transparency</strong>: Process is unaware of sharing</li>
<li><strong>Protection</strong>: Cannot corrupt OS or other process memory</li>
<li><strong>Efficiency</strong>: Do not waste memory or slow down processes</li>
<li><strong>Sharing</strong>: Enable sharing between cooperating processes</li>
</ul>
<h3 id="address-space"><a class="markdownIt-Anchor" href="#address-space"></a> Address space</h3>
<ul>
<li>Stack: No fragmentation</li>
<li>Heap: Consists of allocated and free areas (holes)<br>
<img src="https://i.imgur.com/we79L5F.png" alt=""></li>
</ul>
<h3 id="memory-access-example"><a class="markdownIt-Anchor" href="#memory-access-example"></a> Memory Access Example</h3>
<table>
<thead>
<tr>
<th>Assembly</th>
<th>Access for Instruction</th>
<th>Access for Execution</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x10: movl 0x8(%rbp), %edi</code></td>
<td>Fetch instruction at 0x10</td>
<td>Load from 0x208</td>
</tr>
<tr>
<td><code>0x13: addl $0x3, %edi</code></td>
<td>Fetch instruction at 0x13</td>
<td>No memory access</td>
</tr>
<tr>
<td><code>0x19: movl %edi, 0x8(%rbp)</code></td>
<td>Fetch instruction at 0x19</td>
<td>Store to 0x208</td>
</tr>
</tbody>
</table>
<h2 id="basic-mechanisms"><a class="markdownIt-Anchor" href="#basic-mechanisms"></a> Basic Mechanisms</h2>
<h3 id="time-sharing"><a class="markdownIt-Anchor" href="#time-sharing"></a> Time Sharing</h3>
<ul>
<li>On process switch, save current process’s memory to disk and load another process’s memory from disk.</li>
<li>Ridiculously poor performance</li>
</ul>
<h3 id="static-relocation"><a class="markdownIt-Anchor" href="#static-relocation"></a> Static Relocation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>OS rewrites each program before loading it as a process in memory</li>
<li>Each rewrite for different process uses different addresses and pointers</li>
<li>Change jumps, loads of static data</li>
</ul>
</li>
<li>
<p>Disadvantage</p>
<ul>
<li>Process can destroy OS or other processes</li>
<li>No privacy</li>
<li>Cannot move address space after it has been placed</li>
<li>May not be able to allocate new process</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/840IDak.png" alt=""></p>
<h3 id="dynamic-relocation-introduction"><a class="markdownIt-Anchor" href="#dynamic-relocation-introduction"></a> Dynamic Relocation: Introduction</h3>
<ul>
<li>
<p>Goal: Protect processes from one another</p>
</li>
<li>
<p>Memory Management Unit (MMU)</p>
<ul>
<li>MMU dynamically changes process address at every memory reference</li>
<li>Process generates <strong>logical</strong> or <strong>virtual</strong> addresses (in their address space)</li>
<li>Memory hardware uses <strong>physical</strong> or <strong>real</strong> addresses</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/1rZVwO8.png" alt=""></p>
<ul>
<li>Two operating modes
<ul>
<li>
<p>Kernel mode</p>
<ul>
<li>Can manipulate contents of MMU</li>
<li>Allows OS to access all of physical memory</li>
</ul>
</li>
<li>
<p>User mode</p>
<ul>
<li>Perform translation of logical address to physical address</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="dynamic-relocation-base-register"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-register"></a> Dynamic Relocation: Base Register</h3>
<ul>
<li>Translation on every memory access of user process</li>
<li>MMU adds base register to logical address to form physical address</li>
<li>Store offset in base register</li>
<li>Each process has different value in base register</li>
<li>Dynamic relocation by changing value of base register.</li>
</ul>
<p><img src="https://i.imgur.com/Eika7Rs.png" alt=""></p>
<ul>
<li>
<p>Quiz</p>
<ul>
<li>What entity should do translation of addresses with base register? <strong>Hardware</strong></li>
<li>What entity should modify the base register? <strong>OS</strong></li>
</ul>
</li>
<li>
<p>Problem: No protection</p>
</li>
</ul>
<h3 id="dynamic-relocation-base-bounds"><a class="markdownIt-Anchor" href="#dynamic-relocation-base-bounds"></a> Dynamic Relocation: Base + Bounds</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>limit the address space with a bounds register</li>
<li>Base register: smallest physical addr (or starting location)</li>
<li>Bounds register: size of this process’s virtual address space</li>
<li>OS kills process if process loads/stores beyond bounds</li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li>MMU compares logical address to bounds register</li>
<li>if logical address is greater, then generate error</li>
<li>MMU adds base register to logical address to form physical address</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/Qoqdgtb.png" alt=""></p>
<ul>
<li>
<p>Context switch</p>
<ol>
<li>Change to privileged mode</li>
<li>Save base and bounds registers of old process</li>
<li>Load base and bounds registers of new process</li>
<li>Change to user mode and jump to new process</li>
</ol>
</li>
<li>
<p>Advantages</p>
<ul>
<li>Provides protection (both read and write) across address spaces</li>
<li>Supports dynamic relocation</li>
<li>Simple, inexpensive implementation: Few registers, little logic in MMU</li>
<li>Fast: Add and compare in parallel</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Each process must be allocated contiguously in physical memory</li>
<li>Must allocate memory that may not be used by process</li>
<li>No partial sharing: Cannot share limited parts of address space</li>
</ul>
</li>
</ul>
<h3 id="segmentation"><a class="markdownIt-Anchor" href="#segmentation"></a> Segmentation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>MMU contains Segment Table (per process)</li>
<li>Each segment has own base and bounds, protection bits</li>
<li>Example: 14 bit logical address, 4 segments;</li>
</ul>
</li>
<li>
<p>Example</p>
<ul>
<li>
<p>Segment Table</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>Bounds</th>
<th>R W</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x2000</td>
<td>0x6ff</td>
<td>1 0</td>
</tr>
<tr>
<td>1</td>
<td>0x0000</td>
<td>0x4ff</td>
<td>1 1</td>
</tr>
<tr>
<td>2</td>
<td>0x3000</td>
<td>0xfff</td>
<td>1 1</td>
</tr>
<tr>
<td>3</td>
<td>0x0000</td>
<td>0x000</td>
<td>0 0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Translation</p>
<table>
<thead>
<tr>
<th>Logical address</th>
<th>Segment</th>
<th>Base</th>
<th>Physical address</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0240</td>
<td>0</td>
<td>0x2000</td>
<td>0x2240</td>
</tr>
<tr>
<td>0x1108</td>
<td>1</td>
<td>0x0000</td>
<td>0x1108</td>
</tr>
<tr>
<td>0x256c</td>
<td>2</td>
<td>0x3000</td>
<td>0x356c</td>
</tr>
<tr>
<td>0x3002</td>
<td>3</td>
<td>0x0000</td>
<td>Fail</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>No extra memory access</li>
<li>Enables sparse allocation of address space</li>
<li>Stack and heap can grow independently</li>
<li>Enables sharing of selected segments</li>
<li>Read-only status for code</li>
<li>Supports dynamic relocation of each segment</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Each segment must be allocated contiguously</li>
<li>May not have sufficient physical memory for large segments?</li>
<li>External Fragmentation</li>
</ul>
</li>
</ul>
<h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3>
<table>
<thead>
<tr>
<th>Description</th>
<th>Name of approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>One process uses RAM at a time</td>
<td>Time Sharing</td>
</tr>
<tr>
<td>Rewrite code and addresses before running</td>
<td>Static Relocation</td>
</tr>
<tr>
<td>Add per-process starting location to virt addr to obtain phys addr</td>
<td>Base</td>
</tr>
<tr>
<td>dynamic approach that verifies address is in valid range</td>
<td>Base + Bounds</td>
</tr>
<tr>
<td>Several base+bound pairs per process</td>
<td>Segmentation</td>
</tr>
</tbody>
</table>
<h2 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h2>
<h3 id="fragmentation"><a class="markdownIt-Anchor" href="#fragmentation"></a> Fragmentation</h3>
<ul>
<li>
<p>Definition</p>
<ul>
<li>Free memory that can’t be usefully allocated</li>
</ul>
</li>
<li>
<p>Types of fragmentation</p>
<ul>
<li>External: Visible to allocator (e.g., OS)</li>
<li>Internal: Visible to requester</li>
</ul>
</li>
</ul>
<h3 id="introduction-for-paging"><a class="markdownIt-Anchor" href="#introduction-for-paging"></a> Introduction for Paging</h3>
<ul>
<li>
<p>Goal</p>
<ul>
<li>Eliminate requirement that address space is contiguous</li>
<li>Eliminate external fragmentation</li>
<li>Grow segments as needed</li>
</ul>
</li>
<li>
<p>Idea</p>
<ul>
<li>Divide address spaces and physical memory into fixed-sized pages (usually 4KB)</li>
</ul>
</li>
</ul>
<h3 id="translation-of-page-addresses"><a class="markdownIt-Anchor" href="#translation-of-page-addresses"></a> Translation of Page Addresses</h3>
<ul>
<li>Logical address
<ul>
<li>High-order bits of address designate page number</li>
<li>Low-order bits of address designate offset within page</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/EuMGAwS.png" alt=""></p>
<ul>
<li>
<p>Address Format</p>
<table>
<thead>
<tr>
<th>Page Size</th>
<th>Low Bits</th>
<th>Virt Addr Bits</th>
<th>High Bits</th>
<th>Virt Pages</th>
</tr>
</thead>
<tbody>
<tr>
<td>16 bytes</td>
<td>log(16) = 4</td>
<td>10</td>
<td>10 - 4 = 6</td>
<td>2 ^ 6 = 64</td>
</tr>
<tr>
<td>1 KB</td>
<td>log(1K) = 10</td>
<td>20</td>
<td>20 - 10 = 10</td>
<td>2 ^ 10 = 1024</td>
</tr>
<tr>
<td>1 MB</td>
<td>log(1M) = 20</td>
<td>32</td>
<td>32 - 20 = 12</td>
<td>2 ^ 12 = 4K</td>
</tr>
<tr>
<td>512 bytes</td>
<td>log(512) = 9</td>
<td>16</td>
<td>16 - 9 = 7</td>
<td>2 ^ 7 = 128</td>
</tr>
<tr>
<td>4 KB</td>
<td>log(4K) = 12</td>
<td>32</td>
<td>32 -12 = 20</td>
<td>2 ^ 20 = 1M</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Address Translation</p>
<ul>
<li>Number of bits in virtual address <strong>need not equal</strong> number of bits in physical address</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/HZcAtTC.png" alt=""></p>
<h3 id="pagetables"><a class="markdownIt-Anchor" href="#pagetables"></a> Pagetables</h3>
<ul>
<li>
<p>How should OS translate VPN to PPN?</p>
<ul>
<li>Simple solution: Linear page table aka array</li>
</ul>
</li>
<li>
<p>Example<br>
<img src="https://i.imgur.com/uWlRJnw.png" alt=""></p>
<ul>
<li>Page table for P1: 3, 1, 7, 10</li>
<li>Page table for P2: 0, 4, 2, 6</li>
<li>Page table for P3: 8, 5, 9, 11</li>
</ul>
</li>
<li>
<p>How big is a pagetable</p>
<ul>
<li>Given 32-bit address space, 4KB pages, 4 byte entries</li>
<li>4KB pages =&gt; 12 bit for offset</li>
<li>32-bit address space =&gt; 20 bit for VPN =&gt; 2 ^ 20 = 1MB entries</li>
<li>1MB entries * 4 byte per entry = 4MB</li>
</ul>
</li>
<li>
<p>Where are pagetables stored</p>
<ul>
<li>Store each page table in memory</li>
<li>Hardware finds page table base with register (e.g., CR3 on x86)</li>
</ul>
</li>
<li>
<p>What happens on a context-switch?</p>
<ul>
<li>Change contents of page table base register to newly scheduled process</li>
<li>Save old page table base register in PCB of descheduled process</li>
</ul>
</li>
<li>
<p>What other info is in pagetable entries besides translation?</p>
<ul>
<li>valid bit</li>
<li>protection bits</li>
<li>present bit (needed later)</li>
<li>reference bit (needed later)</li>
<li>dirty bit (needed later)</li>
</ul>
</li>
</ul>
<h3 id="memory-access-with-paging"><a class="markdownIt-Anchor" href="#memory-access-with-paging"></a> Memory Access with Paging</h3>
<ul>
<li>
<p>Given</p>
<ul>
<li>Current instruction: <code>0x0010: movl 0x1100, %edi</code></li>
<li>Assume PT is at phys addr 0x5000</li>
<li>Assume PTE’s are 4 bytes</li>
<li>Assume 4KB pages =&gt; 12 bits for offset</li>
<li>Page table for current process: 2, 0, 80, 99</li>
</ul>
</li>
<li>
<p>Fetch instruction at logical addr 0x0010</p>
<ul>
<li>Access page table to get ppn for vpn 0</li>
<li>Mem ref 1: 0x5000</li>
<li>Learn vpn 0 is at ppn 2</li>
<li>Fetch instruction at 0x2010 (Mem ref 2)</li>
</ul>
</li>
<li>
<p>Exec, load from logical addr 0x1100</p>
<ul>
<li>Access page table to get ppn for vpn 1</li>
<li>Mem ref 3: 0x5000</li>
<li>Learn vpn 1 is at ppn 0</li>
<li>movl from 0x0100 into reg (Mem ref 4)</li>
</ul>
</li>
</ul>
<h3 id="advantages-of-paging"><a class="markdownIt-Anchor" href="#advantages-of-paging"></a> Advantages of Paging</h3>
<ul>
<li>
<p>No external fragmentation</p>
<ul>
<li>Any page can be placed in any frame in physical memory</li>
</ul>
</li>
<li>
<p>Fast to allocate and free</p>
<ul>
<li>Alloc: No searching for suitable free space</li>
<li>Free: Doesn’t have to coalesce with adjacent free space</li>
</ul>
</li>
<li>
<p>Simple to swap-out portions of memory to disk (later lecture)</p>
<ul>
<li>Page size matches disk block size</li>
<li>Can run process when some pages are on disk</li>
<li>Add “present” bit to PTE</li>
</ul>
</li>
</ul>
<h3 id="disadvantages-of-paging"><a class="markdownIt-Anchor" href="#disadvantages-of-paging"></a> Disadvantages of Paging</h3>
<ul>
<li>
<p>Internal fragmentation: Page size may not match size needed by process</p>
<ul>
<li>Wasted memory grows with larger pages</li>
<li>Tension?</li>
</ul>
</li>
<li>
<p>Additional memory reference to page table -&gt; Very inefficient</p>
<ul>
<li>Page table must be stored in memory</li>
<li>MMU stores only base address of page table</li>
</ul>
</li>
<li>
<p>Storage for page tables may be substantial</p>
<ul>
<li>Simple page table: Requires PTE for all pages in address space</li>
<li>Entry needed even if page not allocated?</li>
</ul>
</li>
</ul>
<h3 id="paging-translation-steps"><a class="markdownIt-Anchor" href="#paging-translation-steps"></a> Paging Translation Steps</h3>
<ol>
<li>extract VPN (virt page num) from VA (virt addr)</li>
<li>calculate addr of PTE (page table entry)</li>
<li>read PTE from memory</li>
<li>extract PFN (page frame num)</li>
<li>build PA (phys addr)</li>
<li>read contents of PA from memory into register</li>
</ol>
<h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2>
<h3 id="motivative-example-iterating-array"><a class="markdownIt-Anchor" href="#motivative-example-iterating-array"></a> Motivative Example: Iterating Array</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Memory Access</p>
<table>
<thead>
<tr>
<th>What virtual addresses?</th>
<th>What physical addresses?</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x3000</td>
<td>load 0x100C <br>load 0x7000</td>
</tr>
<tr>
<td>load 0x3004</td>
<td>load 0x100C <br>load 0x7004</td>
</tr>
<tr>
<td>load 0x3008</td>
<td>load 0x100C <br>load 0x7008</td>
</tr>
<tr>
<td>load 0x300C</td>
<td>load 0x100C <br>load 0x7008</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="introduction-2"><a class="markdownIt-Anchor" href="#introduction-2"></a> Introduction</h3>
<ul>
<li>Strategy: Cache Page Translations</li>
<li>TLB stands for Translation Lookaside Buffer<br>
<img src="https://i.imgur.com/mEwtslZ.png" alt=""></li>
</ul>
<h3 id="tlb-organization"><a class="markdownIt-Anchor" href="#tlb-organization"></a> TLB Organization</h3>
<ul>
<li>
<p>TLB Entry</p>
<table>
<thead>
<tr>
<th>Tag (virtual page number)</th>
<th>Physical page number (page table entry)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>Fully associative</p>
<ul>
<li>Any given translation can be anywhere in the TLB</li>
<li>Hardware will search the entire TLB in parallel</li>
</ul>
</li>
</ul>
<h3 id="example-iterating-array-with-tlb"><a class="markdownIt-Anchor" href="#example-iterating-array-with-tlb"></a> Example: Iterating Array with TLB</h3>
<ul>
<li>
<p>Code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++)&#123; </span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Page table for current process (starting at 0x0000)</p>
  <table>
      <tbody>
          <tr>
              <td>PPN</td>
              <td>1</td>
              <td>5</td>
              <td>4</td>
              <td>…</td>
          </tr>
          <tr>
              <td>VPN</td>
              <td>0</td>
              <td>1</td>
              <td>2</td>
              <td>3</td>
          </tr>
      </tbody>
  </table>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>Valid</th>
<th>VPN</th>
<th>PPN</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Memory Access</p>
<table>
<thead>
<tr>
<th>What virtual addresses?</th>
<th>What physical addresses?</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x1000</td>
<td>load 0x0004 <br>load 0x5000</td>
</tr>
<tr>
<td>load 0x1004</td>
<td>(TLB hit) <br>load 0x5004</td>
</tr>
<tr>
<td>load 0x1008</td>
<td>(TLB hit) <br>load 0x5008</td>
</tr>
<tr>
<td>load 0x100C</td>
<td>(TLB hit) <br>load 0x500C</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>load 0x2000</td>
<td>load 0x0008 <br>load 0x4000</td>
</tr>
<tr>
<td>load 0x2004</td>
<td>(TLB hit) <br>load 0x4004</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Performance</p>
<ul>
<li># TLB lookups = number of accesses to a = 2048</li>
<li># TLB misses = 2</li>
<li>Miss rate = 2/2048 = 0.1%</li>
<li>Hit rate = 1 – miss rate = 99.9%</li>
</ul>
</li>
</ul>
<h3 id="tlb-replacement-policies"><a class="markdownIt-Anchor" href="#tlb-replacement-policies"></a> TLB Replacement Policies</h3>
<ul>
<li>
<p>Access Patterns</p>
<ul>
<li>Sequential array accesses almost always hit in TLB: Very fast!</li>
<li>Highly random, with no repeat accesses: Slow</li>
</ul>
</li>
<li>
<p>Code Example</p>
<table>
<thead>
<tr>
<th>Workload A</th>
<th>Workload B</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://i.imgur.com/fg4fYXO.png" alt=""></td>
<td><img src="https://i.imgur.com/b3eYUnz.png" alt=""></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/HWMGImG.png" alt=""></td>
<td><img src="https://i.imgur.com/iMYOS03.png" alt=""></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Workload Locality</p>
<ul>
<li>Spatial Locality: future access will be to nearby addresses</li>
<li>Temporal Locality: future access will be repeats to the same data</li>
</ul>
</li>
<li>
<p>What TLB characteristics are best for each type?</p>
<ul>
<li>
<p>Spatial:</p>
<ul>
<li>Access same page repeatedly; need same vpn à ppn translation</li>
<li>Same TLB entry re-used</li>
</ul>
</li>
<li>
<p>Temporal:</p>
<ul>
<li>Access same address near in future</li>
<li>Same TLB entry re-used in near future</li>
<li>How near in future? How many TLB entries are there?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Replacement policies</p>
<ul>
<li>LRU: evict Least-Recently Used TLB slot when needed</li>
<li>Random: Evict randomly choosen entry</li>
</ul>
</li>
</ul>
<h3 id="context-switches"><a class="markdownIt-Anchor" href="#context-switches"></a> Context Switches</h3>
<ul>
<li>
<p>What happens if a process uses cached TLB entries from another process?</p>
<ol>
<li>
<p>Flush TLB on each switch</p>
<ul>
<li>Costly</li>
<li>lose all recently cached translations</li>
</ul>
</li>
<li>
<p>Track which entries are for which process</p>
<ul>
<li>Address Space Identifier</li>
<li>Tag each TLB entry with an 8-bit ASID</li>
</ul>
</li>
</ol>
</li>
<li>
<p>TLB Example with ASID</p>
<ul>
<li>
<p>Pagetable</p>
<ul>
<li>P1 (ASID 11): 1, 5, 4, …</li>
<li>P2 (ASID 12): 6, 2, 3, …</li>
</ul>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>Valid</th>
<th>Virt</th>
<th>Phys</th>
<th>ASID</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>9</td>
<td>11</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>11</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>11</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Memory access</p>
<table>
<thead>
<tr>
<th>Virtual</th>
<th>Physical</th>
</tr>
</thead>
<tbody>
<tr>
<td>load 0x1444 with ASID 12</td>
<td>0x2444</td>
</tr>
<tr>
<td>load 0x1444 with ASID 11</td>
<td>0x5444</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>TLB Performance</p>
<ul>
<li>
<p>Context switches are expensive</p>
</li>
<li>
<p>Even with ASID, other processes “pollute” TLB</p>
<ul>
<li>Discard process A’s TLB entries for process B’s entries</li>
</ul>
</li>
<li>
<p>Architectures can have multiple TLBs</p>
<ul>
<li>1 TLB for data, 1 TLB for instructions</li>
<li>1 TLB for regular pages, 1 TLB for “super pages”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tlb-misses"><a class="markdownIt-Anchor" href="#tlb-misses"></a> TLB Misses</h3>
<ul>
<li>
<p>Who Handles TLB MISS? Hardware or OS?</p>
</li>
<li>
<p>Hardware: CPU must know where pagetables are</p>
<ul>
<li>CR3 register on x86</li>
<li>Pagetable structure fixed and agreed upon between HW and OS</li>
<li>HW “walks” the pagetable and fills TLB</li>
</ul>
</li>
<li>
<p>OS: “Software-managed TLB”</p>
<ul>
<li>CPU traps into OS upon TLB miss</li>
<li>OS interprets pagetables as it chooses</li>
<li>Modifying TLB entries is privileged</li>
<li>Need same protection bits in TLB as pagetable - rwx</li>
</ul>
</li>
</ul>
<h3 id="summary-2"><a class="markdownIt-Anchor" href="#summary-2"></a> Summary</h3>
<ul>
<li>
<p>Pages are great, but accessing page tables for every memory access is slow</p>
</li>
<li>
<p>Cache recent page translations -&gt; TLB</p>
<ul>
<li>Hardware performs TLB lookup on every memory access</li>
</ul>
</li>
<li>
<p>TLB performance depends strongly on workload</p>
<ul>
<li>Sequential workloads perform well</li>
<li>Workloads with temporal locality can perform well</li>
</ul>
</li>
<li>
<p>In different systems, hardware or OS handles TLB misses</p>
</li>
<li>
<p>TLBs increase cost of context switches</p>
<ul>
<li>Flush TLB on every context switch</li>
<li>Add ASID to every TLB entry</li>
</ul>
</li>
</ul>
<h2 id="smaller-page-tables"><a class="markdownIt-Anchor" href="#smaller-page-tables"></a> Smaller Page Tables</h2>
<h3 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h3>
<ul>
<li>
<p>How big are page tables</p>
<ol>
<li>
<p>PTE’s are 2 bytes, and 32 possible virtual page numbers</p>
<ul>
<li>2 bytes * 32 = 64 bytes</li>
</ul>
</li>
<li>
<p>PTE’s are 2 bytes, virtual addrs are 24 bits, pages are 16 bytes</p>
<ul>
<li>16 bytes page =&gt; 4 bit offset =&gt; 20 bit VPN</li>
<li>=&gt; 2^20 Pages =&gt;  2^20 * 2 = 2MB for page tables</li>
</ul>
</li>
<li>
<p>PTE’s are 4 bytes, virtual addrs are 32 bits, and pages are 4 KB</p>
<ul>
<li>4KB page =&gt; 12 bit offset =&gt; 20 bit VPN</li>
<li>=&gt; 2^20 Pages =&gt;  2^20 * 4 = 4MB for page tables</li>
</ul>
</li>
<li>
<p>PTE’s are 4 bytes, virtual addrs are 64 bits, and pages are 4 KB</p>
<ul>
<li>4KB page =&gt; 12 bit offset =&gt; 52 bit VPN</li>
<li>=&gt; 2^52 Pages =&gt;  2^52 * 4 = 18.0143985 PB for page tables</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Why are Page Tables so Large?</p>
<ul>
<li>Many invalid PT entries</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/hw6UrkL.png" alt=""></p>
<ul>
<li>Summary
<ul>
<li>
<p>Storage for page tables may be substantial</p>
</li>
<li>
<p>Simple page table: Requires PTE for all pages in address space</p>
</li>
<li>
<p>Entry needed even if page not allocated.</p>
</li>
</ul>
</li>
</ul>
<h3 id="smaller-page-tables-2"><a class="markdownIt-Anchor" href="#smaller-page-tables-2"></a> Smaller Page Tables</h3>
<ul>
<li>
<p>Use more complex page tables, instead of just big array</p>
</li>
<li>
<p>Any data structure is possible with software-managed TLB</p>
<ul>
<li>
<p>Hardware looks for vpn in TLB on every memory access</p>
</li>
<li>
<p>If TLB does not contain vpn, TLB miss</p>
<ul>
<li>Trap into OS and let OS find vpn-&gt;ppn translation</li>
<li>OS notifies TLB of vpn-&gt;ppn for future accesses</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Other approaches</p>
<ol>
<li>
<p>Segmented Pagetables</p>
</li>
<li>
<p>Multi-level Pagetables</p>
<ul>
<li>Page the page tables</li>
<li>Page the pagetables of page tables…</li>
</ul>
</li>
<li>
<p>Inverted Pagetables</p>
</li>
</ol>
</li>
</ul>
<h3 id="paging-with-segmentation"><a class="markdownIt-Anchor" href="#paging-with-segmentation"></a> Paging with Segmentation</h3>
<ul>
<li>
<p>Idea</p>
<ul>
<li>
<p>Divide address space into segments (code, heap, stack)</p>
</li>
<li>
<p>Divide each segment into fixed-sized pages</p>
</li>
<li>
<p>Logical address divided into three portions</p>
<table>
<thead>
<tr>
<th>seg # (4 bits)</th>
<th>page number (8 bits)</th>
<th>page offset (12 bits)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li>Each segment has a page table</li>
<li>Each segment track base (physical address) and bounds of the page table</li>
</ul>
</li>
<li>
<p>Quiz</p>
<ul>
<li>
<p>Logical address layout</p>
<table>
<thead>
<tr>
<th>seg # (4 bits)</th>
<th>page number (8 bits)</th>
<th>page offset (12 bits)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
<li>
<p>Segment Table</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>Bounds</th>
<th>R W</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x002000</td>
<td>0xff</td>
<td>1 0</td>
</tr>
<tr>
<td>1</td>
<td>0x000000</td>
<td>0x00</td>
<td>0 0</td>
</tr>
<tr>
<td>2</td>
<td>0x001000</td>
<td>0x0f</td>
<td>1 1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Translation</p>
<table>
<thead>
<tr>
<th>Virtual</th>
<th>Seg</th>
<th>Base</th>
<th>Offset</th>
<th>PPN</th>
<th>Physical</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x002070 R</td>
<td>0</td>
<td>0x002000</td>
<td>2</td>
<td>0x004</td>
<td>0x004070</td>
<td></td>
</tr>
<tr>
<td>0x202016 R</td>
<td>2</td>
<td>0x001000</td>
<td>2</td>
<td>0x003</td>
<td>0x003016</td>
<td></td>
</tr>
<tr>
<td>0x104c84 R</td>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>R = 0</td>
</tr>
<tr>
<td>0x010424 W</td>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>W = 0</td>
</tr>
<tr>
<td>0x210014 W</td>
<td>2</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>bounds</td>
</tr>
<tr>
<td>0x203568 W</td>
<td>2</td>
<td>0x001000</td>
<td>3</td>
<td>0x02a</td>
<td>0x02a568</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Advantages</p>
<ul>
<li>
<p>Advantages of Segments</p>
<ul>
<li>Supports sparse address spaces.</li>
<li>Decreases size of page tables. If segment not used, not need for page table</li>
</ul>
</li>
<li>
<p>Advantages of Pages</p>
<ul>
<li>No external fragmentation</li>
<li>Segments can grow without any reshuffling</li>
<li>Can run process when some pages are swapped to disk (next lecture)</li>
</ul>
</li>
<li>
<p>Advantages of Both</p>
<ul>
<li>Increases flexibility of sharing: Share either single page or entire segment</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Disadvantages</p>
<ul>
<li>Potentially large page tables (for each segment)</li>
<li>Must allocate each page table contiguously</li>
<li>More problematic with more address bits</li>
</ul>
</li>
</ul>
<h3 id="multilevel-page-tables"><a class="markdownIt-Anchor" href="#multilevel-page-tables"></a> Multilevel Page Tables</h3>
<ul>
<li>
<p>Goal: Allow each page tables to be allocated non-contiguously</p>
</li>
<li>
<p>Idea: Page the page tables</p>
<ul>
<li>Creates multiple levels of page tables; outer level “page directory”</li>
<li>Only allocate page tables for pages in use</li>
<li>Used in x86 architectures (hardware can walk known structure)</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/9bSULQI.png" alt=""></p>
<ul>
<li>
<p>Multilevel Pagetable Translation</p>
<ul>
<li>
<p>Page directory and page tables</p>
<table>
<thead>
<tr>
<th></th>
<th>0x0</th>
<th>0x1</th>
<th>…</th>
<th>0xE</th>
<th>0xF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page directory</td>
<td>0x3</td>
<td>-</td>
<td>…</td>
<td>-</td>
<td>0x92</td>
</tr>
<tr>
<td>PT @PPN 0x3</td>
<td>0x10</td>
<td>0x23</td>
<td>…</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>PT @PPN 0x92</td>
<td>-</td>
<td>-</td>
<td>…</td>
<td>0x55</td>
<td>0x45</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Address layout</p>
<table>
<thead>
<tr>
<th>outer page (4)</th>
<th>inner page (4)</th>
<th>page offset (12)</th>
</tr>
</thead>
<tbody></tbody>
</table>
</li>
</ul>
<ol>
<li>
<p>Translate 0x01ABC</p>
<ul>
<li>Outer page = 0x0 =&gt; Use page table at 0x3</li>
<li>Inner page = 0x1 =&gt; PPN = 0x23</li>
<li>Physical address = 0x23ABC</li>
</ul>
</li>
<li>
<p>Translate 0xFEED0</p>
<ul>
<li>Outer page = 0xF =&gt; Use page table at 0x92</li>
<li>Inner page = 0xE =&gt; PPN = 0x55</li>
<li>Physical address = 0x55ED0</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Address Format for Multilevel Paging</p>
<ul>
<li>Given 30-bit address with 4KB page size</li>
<li>#bits for page offset = log(4K) = 12</li>
<li>4 bytes per PTE =&gt; 1K entries per page =&gt; #bits for inner page = log(1K) = 10</li>
<li>#bits for outer page = 30 - 10 - 12 = 8</li>
</ul>
</li>
<li>
<p>Pagetable with 3 levels</p>
<ul>
<li>
<p>Problem</p>
<ul>
<li>Page directories (outer level) may not fit in a page</li>
</ul>
</li>
<li>
<p>Solution</p>
<ul>
<li>Split page directories into pieces</li>
<li>Use another page dir to refer to the page dir pieces.</li>
</ul>
</li>
<li>
<p>Memory Addressability Comparison</p>
<ul>
<li>1 level = 2<sup>10</sup> * 2<sup>12</sup> = 4MB</li>
<li>2 level = (2<sup>10</sup>)<sup>2</sup> * 2<sup>12</sup> = 4GB</li>
<li>3 level = (2<sup>10</sup>)<sup>3</sup> * 2<sup>12</sup> = 4TB</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Quiz: Count Memory Access</p>
<ul>
<li>
<p>Assumption</p>
<ul>
<li>3-level page table</li>
<li>256-byte pages</li>
<li>16-bit addresses</li>
<li>ASIC of current process is 211</li>
</ul>
</li>
<li>
<p>TLB</p>
<table>
<thead>
<tr>
<th>ASID</th>
<th>VPN</th>
<th>PFN</th>
<th>Valid</th>
</tr>
</thead>
<tbody>
<tr>
<td>211</td>
<td>0xbb</td>
<td>0x91</td>
<td>1</td>
</tr>
<tr>
<td>211</td>
<td>0xff</td>
<td>0x23</td>
<td>1</td>
</tr>
<tr>
<td>122</td>
<td>0x05</td>
<td>0x91</td>
<td>1</td>
</tr>
<tr>
<td>211</td>
<td>0x05</td>
<td>0x12</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<ol>
<li>
<p>0xAA10: movl 0x1111, %edi</p>
<ul>
<li>
<p>TLB miss for 0xAA10 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p>
</li>
<li>
<p>TLB miss for 0x1111 =&gt; 3 memory accesses for page table + 1 more to get the instruction</p>
</li>
<li>
<p>Total: 4 memory accesses</p>
</li>
</ul>
</li>
<li>
<p>0xBB13: addl $0x3, %edi</p>
<ul>
<li>TLB hit for 0xBB13 =&gt; 1 access more to get the instruction</li>
</ul>
</li>
<li>
<p>0x0519: movl %edi, 0xFF10</p>
<ul>
<li>
<p>TLB miss for 0x0519 =&gt; 3 memory access for page table + 1 more to get the instruction</p>
</li>
<li>
<p>TLB hit for 0xFF10 =&gt; 1 access more to get the instruction</p>
</li>
<li>
<p>Total: 5 memory accesses</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="inverted-page-table"><a class="markdownIt-Anchor" href="#inverted-page-table"></a> Inverted Page Table</h3>
<ul>
<li>
<p>Only need entries for virtual pages w/ valid physical mappings</p>
</li>
<li>
<p>Naïve approach:</p>
<ul>
<li>Search through data structure &lt;ppn, vpn+asid&gt; to find match</li>
<li>Too much time to search entire table</li>
</ul>
</li>
<li>
<p>Better:</p>
<ul>
<li>Find possible matches entries by hashing vpn+asid</li>
<li>Smaller number of entries to search for exact match</li>
</ul>
</li>
<li>
<p>Managing inverted page table requires software-controlled TLB</p>
</li>
</ul>
<h2 id="swapping"><a class="markdownIt-Anchor" href="#swapping"></a> Swapping</h2>
<h3 id="motivation-2"><a class="markdownIt-Anchor" href="#motivation-2"></a> Motivation</h3>
<ul>
<li>Support processes when not enough physical memory</li>
<li>Single process with very large address space</li>
<li>Multiple processes with combined address spaces</li>
</ul>
<h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> Idea</h3>
<ul>
<li>
<p>OS keeps unreferenced pages on disk</p>
<ul>
<li>Slower, cheaper backing store than memory</li>
</ul>
</li>
<li>
<p>Process can run when not all pages are loaded into main memory</p>
</li>
<li>
<p>OS and hardware cooperate to make large disk seem like memory</p>
<ul>
<li>Same behavior as if all of address space in main memory</li>
</ul>
</li>
</ul>
<h3 id="locality-of-reference"><a class="markdownIt-Anchor" href="#locality-of-reference"></a> Locality of Reference</h3>
<ul>
<li>
<p>Leverage locality of reference within processes</p>
<ul>
<li>Spatial: reference memory addresses near previously referenced addresses</li>
<li>Temporal: reference memory addresses that have referenced in the past</li>
<li>Processes spend majority of time in small portion of code</li>
</ul>
</li>
<li>
<p>Implication:</p>
<ul>
<li>Process only uses small amount of address space at any moment</li>
<li>Only small amount of address space must be resident in physical memory</li>
</ul>
</li>
<li>
<p>Memory Hierarchy</p>
<p><img src="https://i.imgur.com/pi58bfR.png" alt=""></p>
</li>
</ul>
<h3 id="mechanism-2"><a class="markdownIt-Anchor" href="#mechanism-2"></a> Mechanism</h3>
<ul>
<li>
<p>Each page in virtual address space maps to one of three locations:</p>
<ul>
<li>Physical main memory: Small, fast, expensive</li>
<li>Disk (backing store): Large, slow, cheap</li>
<li>Nothing (error): Free</li>
</ul>
</li>
<li>
<p>Extend page tables with an extra bit: present</p>
<ul>
<li>permissions (r/w), valid, present</li>
<li>Page in memory: present bit set in PTE</li>
<li>Page on disk: present bit cleared
<ul>
<li>PTE points to block on disk</li>
<li>Causes trap into OS when page is referenced</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Procedure</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hardware checks TLB</span><br><span class="line"><span class="keyword">if</span> TLB hit</span><br><span class="line">    address translation is done</span><br><span class="line">    page in physical memory</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB miss</span></span><br><span class="line">    Hardware <span class="keyword">or</span> OS walk page tables</span><br><span class="line">    <span class="keyword">if</span> PTE designates page is present</span><br><span class="line">        page in physical memory (i.e., present bit is cleared)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// page fault</span></span><br><span class="line">        Trap into OS (<span class="keyword">not</span> handled by hardware)</span><br><span class="line">        OS selects victim page in memory to replace</span><br><span class="line">        <span class="keyword">if</span> victim page is modified</span><br><span class="line">            write victim page out to disk</span><br><span class="line">        OS reads referenced page from disk into memory</span><br><span class="line">        Page table is updated, present bit is <span class="built_in">set</span></span><br><span class="line">        Process continues execution</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="policy-page-selection"><a class="markdownIt-Anchor" href="#policy-page-selection"></a> Policy: Page selection</h3>
<ul>
<li>
<p>When should a page on disk be brought into memory?</p>
</li>
<li>
<p>Demand paging: Load page only when page fault occurs</p>
<ul>
<li>Intuition: Wait until page must absolutely be in memory</li>
<li>When process starts: No pages are loaded in memory</li>
<li>Problems: Pay cost of page fault for every newly accessed page</li>
</ul>
</li>
<li>
<p>Prepaging (anticipatory, prefetching): Load page before referenced</p>
<ul>
<li>OS predicts future accesses (oracle) and brings pages into memory early</li>
<li>Works well for some access patterns (e.g., sequential)</li>
</ul>
</li>
<li>
<p>Hints: Combine above with user-supplied hints about page references</p>
<ul>
<li>User specifies: may need page in future, don’t need this page anymore, or sequential access pattern, …</li>
<li>Example: madvise() in Unix</li>
</ul>
</li>
</ul>
<h3 id="policy-page-replacement"><a class="markdownIt-Anchor" href="#policy-page-replacement"></a> Policy: Page replacement</h3>
<ul>
<li>
<p>Which resident page in memory should be thrown out to disk?</p>
</li>
<li>
<p>OPT: Replace page not used for longest time in future</p>
<ul>
<li>Advantages: Guaranteed to minimize number of page faults</li>
<li>Disadvantages: Requires that OS predict the future; Not practical, but good for comparison</li>
</ul>
</li>
<li>
<p>FIFO: Replace page that has been in memory the longest</p>
<ul>
<li>Intuition: First referenced long time ago, done with it now</li>
<li>Advantages: Fair: All pages receive equal residency; Easy to implement</li>
<li>Disadvantage: Some pages may always be needed</li>
</ul>
</li>
<li>
<p>LRU: Replace page not used for longest time in past</p>
<ul>
<li>Intuition: Use past to predict the future</li>
<li>Advantages: With locality, LRU approximates OPT</li>
<li>Disadvantages: Harder to implement and does not handle all workloads well</li>
</ul>
</li>
<li>
<p>Comparison</p>
<table>
<thead>
<tr>
<th>LRU, OPT</th>
<th>FIFO</th>
</tr>
</thead>
<tbody>
<tr>
<td>Guaranteed to  have fewer page faults<br>Smaller memory sizes ⊆ larger memory sizes<br>Smaller cache ⊆ bigger cache</td>
<td>Usually have fewer page faults <br>May actually have more page faults!</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="implementing-lru"><a class="markdownIt-Anchor" href="#implementing-lru"></a> Implementing LRU</h3>
<ul>
<li>
<p>Software Perfect LRU</p>
<ul>
<li>OS maintains ordered list of physical pages by reference time</li>
<li>When page is referenced: Move page to front of list</li>
<li>When need victim: Pick page at back of list</li>
<li>Trade-off: Slow on memory reference, fast on replacement</li>
</ul>
</li>
<li>
<p>Hardware Perfect LRU</p>
<ul>
<li>Associate timestamp register with each page</li>
<li>When page is referenced: Store system clock in register</li>
<li>When need victim: Scan through registers to find oldest clock</li>
<li>Trade-off: Fast on memory reference, slow on replacement (especially as size of memory grows)</li>
</ul>
</li>
<li>
<p>Approximating LRU: Clock Algorithm</p>
<ul>
<li>
<p>Hardware</p>
<ul>
<li>Keep use (or reference) bit for each page frame</li>
<li>When page is referenced: set use bit (page was used recently)</li>
</ul>
</li>
<li>
<p>Operating System</p>
<ul>
<li>Page replacement: Look for page with use bit cleared (has not been referenced for a while)</li>
</ul>
<ol>
<li>Keep pointer to last examined page frame</li>
<li>Traverse pages in circular buffer</li>
<li>Clear use bits as search</li>
<li>Stop when find page with already cleared use bit, replace this page</li>
</ol>
</li>
</ul>
</li>
</ul>
<img src="https://i.imgur.com/WYNCIhZ.png" style="margin:auto; display: block;">
<h2 id="summary-3"><a class="markdownIt-Anchor" href="#summary-3"></a> Summary</h2>
<ul>
<li>
<p>Abstraction: Virtual address space with code, heap, stack</p>
</li>
<li>
<p>Address translation</p>
<ul>
<li>Contiguous memory: base, bounds, segmentation</li>
<li>Using fixed sizes pages with page tables</li>
</ul>
</li>
<li>
<p>Challenges with paging</p>
<ul>
<li>Extra memory references: avoid with TLB</li>
<li>Page table size: avoid with multi-level paging, inverted page tables etc.</li>
</ul>
</li>
<li>
<p>Larger address spaces: Swapping mechanisms, policies (LRU, Clock)</p>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-process control" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/11/process control/"
    >Process Control</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/02/11/process control/" class="article-date">
  <time datetime="2019-02-10T20:15:32.000Z" itemprop="datePublished">2019-02-10</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h1>
<ul>
	<li>pid</li>
	<li>fork</li>
	<li>wait</li>
	<li>exec</li>
</ul>
<h2 id="pid"><a class="markdownIt-Anchor" href="#pid"></a> pid</h2>
<p>每一个进程都有一个独特的非负整型pid</p>
<p>pid可以用来生成独特的文件名</p>
<p>进程终止时 pid会被回收重用</p>
<p>大部分unix系统会有代码来延迟重用从而保证新创建的进程和刚刚终止的进程pid相同</p>
<p>pid 1 通常为init process， 会在启动结束时被kernel invoke
	其program file在/etc/init （老版本的UNIX系统）或者/sbin/init   （较新版本。 这个进程负责bring up unix system after kernel has been bootstrapped by reading system-dependent initialization files: the /etc/rc* files or /etc/inittab and the files in /etc/init.d. 来带系统进入一定的状态：比如多用户状态。
</p>
<p>init process is a user process (with superuser privileges) that never dies.</p>
<p>例子： mac os X 10.4里的launchd process</p>
<p>通常每个unix系统有自己的内核进程， 有的系统pid2时pagedaemon 负责支持系统虚拟内存paging</p>
<p>以下所有函数都没有error return</p>
<p><img src="/img_rand/a1.png" alt=""></p>
<h2 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h2>
<p>现存进程可以用fork来创建新进程</p>
<p><img src="/img_rand/a2.png" alt=""></p>
<p>这个函数被call一次会返回两次</p>
<p>在子进程中返回值为0 原因：子进程只能有一个父进程 可以getppid来获得</p>
<p>parent process返回值为子进程pid 原因：避免子进程pid被其他进程获
</p>
<p>子进程父进程在fork之后会继续执行接下来的命令</p>
<p>The child is a copy of the parent. For example, the child gets a copy of the parent’s data space, heap, and stack. 但是会share text segment</p>
<p>Modern implementations don’t perform a complete copy of the parent’s data, stack, and heap, since a fork is often followed by an exec. Instead, a technique called copy-on-write (COW) is used. These regions are shared by the parent and the child and have their protection changed by the kernel to read-only. If either process tries to modify these regions, the kernel then makes a copy of that piece of memory only, typically a ‘‘page’’ in a virtual memory system. </p>
<p><img src="/img_rand/a3.png" alt=""></p>
<p>通常父子进程执行顺序是nondeterministic的 这取决与kernel的调度算法</p>
<p>若需要sychronize action 可以使用如上代码中的sleep来使父进程等待子进程的执行， 但我们没有保证2秒的时间是合适的</p>	
<p>其他同步方式 race conditions section 8.9  signal section 10.16</p>
<p>sizeof 和 strlen的 区别：</p>
<p>When we write to standard output, we subtract 1 from the size of buf to avoid writing the terminating null byte. Although strlen will calculate the length of a string not including the terminating null byte, sizeof calculates the size of the buffer, which does include the terminating null byte. </p>
<p>Another difference is that using strlen requires a function call, whereas sizeof calculates the buffer length at compile time,(更快) as the buffer is initialized with a known string and its size is fixed.</p>
<p>为什么打印了两遍？write是没有缓冲的。 stdio库是有缓冲的：stdout如果连接着terminal device 会被line buffered 否则会被fully buffered</p>
<p>所以刚开始的printf缓存区被清空了 但当我们重定向输出到文件的时候 printf打印了两行。 在第二个情况下 printf在fork前被呼叫了1次，但在呼叫fork后buffer里缓存还在，buffer里的内容被拷贝到子进程 此时父子进程都有这个相同的 内容没被清空的buffer。 最后一个printf appends its data to the existing buffer.进程终止时 缓存区清空.
</p>
### file shareing
<p>当我们重定向父进程的stdout输出的时候 子进程stdout也被重定向</p>
<p>这是fork的一个特性： all file descriptors that are open in the parent are duplicated in the child. The parent and the child share a file table entry for every open descriptor </p>
<p>也就是说 父子进程同时进行输出到stdout时 一定要共享file offset. 若父进程输出被重定向，我们需要子进程在输出到stdout时更新父进程file offset。 这样不仅子进程可以在父进程wait时候输出到stdout，在子进程结束输出时父进程可以在同位置继续之前的输出。 如果没有共享file offset 
这种互动会很难实现</p>
<p><img src="/img_rand/a4.png" alt=""></p>
<p>通常有两种情况来处理 fork之后的descriptors的使用</p>
<ol>
	<li>父进程等待子进程结束：parent need to do nothing. 任何共享的descriptors会被子进程更新</li>
	<li>父进程子进程都有自己的事情要干：fork之后父子进程各自关闭其不需要的descriptors，open descriptors互不干涉 这种情况常见于网络服务器</li>
</ol>
<p>其他被子进程继承的属性：</p>	
<ul>
	<li>Real user ID, real group ID, effective user ID, and effective group ID</li>
	<li>Supplementary group IDs</li>
	<li>Process group ID</li>
	<li>Session ID</li>
	<li>Controlling terminal</li>
	<li>The set-user-ID and set-group-ID flags</li>
	<li>Current working directory</li>
	<li>Root directory</li>
	<li>File mode creation mask</li>
	<li>Signal mask and dispositions</li>
	<li>The close-on-exec flag for any open file descriptors</li>
	<li>Environment</li>
	<li>Attached shared memory segments</li>
	<li>Memory mappings</li>
	<li>Resource limits</li>
</ul>
<p>父子进程的区别：</p>
<ul>
	<li>fork返回值</li>
	<li>pid</li>
	<li>ppid</li>
	<li>子进程的tms_utime, tms_stime, tms_cutime, and tms_cstime值为0</li>
	<li>父进程的文件锁不会被子进程继承</li>
	<li>Pending alarms are cleared for the child.</li>	
	<li>The set of pending signals for the child is set to the empty set.</li>
</ul>
<p>fork通常失败的原因有 太多进程存在于系统或者 对于当前用户进程数量超过系统限制： CHILD_MAX specifies the maximum number of simultaneous processes per real user ID.</p>
<p>fork 的两种使用</p>
<ul>
	<li>当一个进程想要自我复制从而 父子进程同时执行一片相同的代码时：常见于网络服务器 the parent waits for a service request from a client. When the request arrives, the parent calls fork and lets the child handle the request. The parent goes back to waiting for the next service request to arrive. </li>
	<li>当一个进程想要执行一个不同的程序 这种情况下通常子进程使用exec right after it returns from the fork.（spawn by some other OS）</li>
</ul>
## wait
<p>When a process terminates, either normally or abnormally, the kernel notifies the parent by sending the SIGCHLD signal to the parent.</p>
<p>Because the termination of a child is an asynchronous event—it can happen at any time while the parent is running—this signal is the asynchronous notification from the kernel to the parent.</p>
<p>The parent can choose to ignore this signal, or it can provide a function that is called when the signal occurs: a signal handler. </p>
<p>The default action for this signal is to be ignored.</p>
<p>For now, we need to be aware that a process that calls wait or waitpid can:</p>
<ul>
	<li>Block, if all of its children are still running</li>
	<li>Return immediately with the termination status of a child, if a child has terminated and is waiting for its termination status to be fetched</li>
	<li>Return immediately with an error, if it doesn’t have any child processes</li>
</ul>
<p>If the process is calling wait because it received the SIGCHLD signal, we expect wait to return immediately. But if we call it at any random point in time, it can block.</p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-TCS" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/25/TCS/"
    >Automata, language, and computational complexity</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/12/25/TCS/" class="article-date">
  <time datetime="2018-12-25T01:22:41.000Z" itemprop="datePublished">2018-12-24</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="参考课程内容-httpscoursesengrillinoiseducs373sp2013lectures"><a class="markdownIt-Anchor" href="#参考课程内容-httpscoursesengrillinoiseducs373sp2013lectures"></a> <strong>参考课程内容</strong> <a href="https://courses.engr.illinois.edu/cs373/sp2013/Lectures/" target="_blank" rel="noopener">https://courses.engr.illinois.edu/cs373/sp2013/Lectures/</a></h2>
<h4 id="nfa-to-dfa-subset-construction"><a class="markdownIt-Anchor" href="#nfa-to-dfa-subset-construction"></a> <strong>NFA to DFA subset construction</strong></h4>
<p><a href="https://www.youtube.com/watch?v=Y92dtMnarAU&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;index=19" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Y92dtMnarAU&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;index=19</a></p>
<h4 id="ε-nfa-to-nfa-algorithm"><a class="markdownIt-Anchor" href="#ε-nfa-to-nfa-algorithm"></a> <strong>ε-NFA to NFA Algorithm</strong></h4>
<p><a href="https://www.youtube.com/watch?v=Jz4YQ09nOxA&amp;index=44&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Jz4YQ09nOxA&amp;index=44&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev</a></p>
<h4 id="dfa-to-regular-expression-state-elimination"><a class="markdownIt-Anchor" href="#dfa-to-regular-expression-state-elimination"></a> <strong>DFA to regular expression State Elimination</strong></h4>
<p><a href="https://www.youtube.com/watch?v=fyJumUElTGY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=fyJumUElTGY</a></p>
<h4 id="dfa-to-regex-dynamic-programmingtransitive-closure-method"><a class="markdownIt-Anchor" href="#dfa-to-regex-dynamic-programmingtransitive-closure-method"></a> <strong>DFA to regex Dynamic programming/transitive closure method</strong></h4>
<p><a href="https://www.classes.cs.uchicago.edu/archive/2015/winter/28000-1/Lec2.pdf" target="_blank" rel="noopener">https://www.classes.cs.uchicago.edu/archive/2015/winter/28000-1/Lec2.pdf</a><br>
<a href="https://www.cs.dartmouth.edu/~ac/Teach/CS39-Winter09/SlidesAndNotes/lec09dfa2regexp.pdf" target="_blank" rel="noopener">https://www.cs.dartmouth.edu/~ac/Teach/CS39-Winter09/SlidesAndNotes/lec09dfa2regexp.pdf</a><br>
<a href="https://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions</a></p>
<h4 id="closure-properties-of-regular-language-regular-expression"><a class="markdownIt-Anchor" href="#closure-properties-of-regular-language-regular-expression"></a> <strong>Closure properties of regular language &amp; regular expression</strong></h4>
<p><img src="/img_520/1.png" alt=""><br>
<img src="/img_520/2.png" alt=""><br>
<img src="/img_520/3.png" alt=""></p>
<h4 id="regex-to-nfa-translation"><a class="markdownIt-Anchor" href="#regex-to-nfa-translation"></a> <strong>Regex to nfa translation</strong></h4>
<p><img src="/img_520/4.png" alt=""></p>
<h4 id="dfa-minimization-algorithm"><a class="markdownIt-Anchor" href="#dfa-minimization-algorithm"></a> <strong>Dfa minimization algorithm</strong></h4>
<p>Minimization of DFA - Table Filling Method (Myhill-Nerode Theorem)<br>
<img src="/img_520/5.png" alt=""></p>
<h4 id="myhill-nerode-theorem"><a class="markdownIt-Anchor" href="#myhill-nerode-theorem"></a> <strong>Myhill-nerode theorem</strong></h4>
<p><img src="/img_520/6.png" alt=""><br>
Further more there is a minimized dfa having precisely one state for each equivalence class!!!<br>
<strong>equivalence classes classification</strong>: how to tell what equivalence classes are there?<br>
<a href="https://courses.cs.washington.edu/courses/cse322/05wi/handouts/MyhillNerode.pdf" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse322/05wi/handouts/MyhillNerode.pdf</a><br>
Regular: we can use above algorithm on DFA minimization to find out each equivalence classes<br>
Nonregular:<br>
<img src="/img_520/7.png" alt=""></p>
<h4 id="pumping-lemma-prove-nonregular-language"><a class="markdownIt-Anchor" href="#pumping-lemma-prove-nonregular-language"></a> <strong>Pumping lemma prove nonregular language</strong></h4>
<p><img src="/img_520/8.png" alt=""></p>
<p>Testing regularity finite language is regular  infinite language can be tested by pumping lemma</p>
<h4 id="testing-whether-a-language-is-regular-or-not"><a class="markdownIt-Anchor" href="#testing-whether-a-language-is-regular-or-not"></a> <strong>Testing whether a language is regular or not</strong></h4>
<p><a href="https://www.youtube.com/watch?v=KSczX111n3U" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KSczX111n3U</a></p>
<h4 id="cfg-design-regular-language-to-cfg"><a class="markdownIt-Anchor" href="#cfg-design-regular-language-to-cfg"></a> <strong>CFG DESIGN  Regular language to CFG,</strong></h4>
<p><img src="/img_520/9.png" alt=""><br>
对每一个dfa的state设计一个nonterminal variable；<br>
对于每个transition  add 相应的rule   （根据不同的input）<br>
对于accepting state的nonterminal variable 让他生成空的string<br>
This cfg generates the same language that dfa recognizes.</p>
<h4 id="ambiguity"><a class="markdownIt-Anchor" href="#ambiguity"></a> <strong>AMBIGUITY</strong></h4>
<p>A string is derived ambiguously if it has one or more left/right most derivation tree.<br>
A Grammar G is ambiguous if it generates some string ambiguously.</p>
<h4 id="chompsky-normal-form"><a class="markdownIt-Anchor" href="#chompsky-normal-form"></a> <strong>Chompsky Normal Form</strong></h4>
<p>(CFG simplification: removal of null ε production + unit production elimination + adding auxiliary variable &amp; rewrite)<br>
<a href="https://www.youtube.com/watch?v=EF09zxzpVbk&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;t=5s&amp;index=76" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EF09zxzpVbk&amp;list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&amp;t=5s&amp;index=76</a><br>
<img src="/img_520/10.png" alt=""></p>
<p><img src="/img_520/11.png" alt=""><br>
<img src="/img_520/12.png" alt=""><br>
For each direct null production A-&gt; null , look for all productions whose right hand side contains A. Replace each occurrences of A in these production with null.  By each occurences, it means all possible location of A that can be nullified. Finsh the resulting productions without A-&gt;null, looking for the next one for ex B-&gt;null until no null productions exist.</p>
<p><strong>Or a graph-algorithm:</strong><br>
Create a directed cyclic graph where each vertex represent a nonterminal for all nonterminals.<br>
Add an edge if there is a unit production.<br>
Collapse all strongly connected components into a single vertex (meaning these nonterminal are equivalent, merge their production rules in the grammar)<br>
Start from sink S, augment production rules of the sink to all nonterminals that go to sink, then remove the edges from all nonterminals that go to sink.  Repeat this until no edges exist</p>
<p><strong>CYK algorithm O(n^3)<br>
(Dynamic Programming parsing/recognizing if a string is in the language of cfg)<br>
Assume in put is in CNF form.</strong><br>
<img src="/img_520/13.png" alt=""><br>
For example, to parse <strong>“id ( id , id )” 6 character sequence,</strong> we construct 6 by 6 grid with diagonals filled in all possible nonterminal that can derive the i-th symbol for i=1 to i=6.<br>
<img src="/img_520/14.png" alt=""><br>
Then we fill in each successive diagonals bottom up:<br>
For each square, consider ALL possible ordered pair of the nonterminals one from left one from below, for each pair, if it can be derived from a rule(notice we have cnf), we put the lhs nonterminal of that rule to that squares<br>
<img src="/img_520/15.png" alt=""><br>
If the starting nonterminal appear in the upper right corner of the grid we accept the string</p>
<p><strong>Non determinstic Push down automata<br>
Equivalence of cfg and nondeterminstic pda :</strong><br>
A language is generated by a cfg = it is recognized by a npda<br>
<a href="https://people.eecs.berkeley.edu/~sseshia/172/lectures/Slides8.pdf" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sseshia/172/lectures/Slides8.pdf</a><br>
<img src="/img_520/16.png" alt=""></p>
<p>For example.<br>
<img src="/img_520/17.png" alt=""><br>
<img src="/img_520/18.png" alt=""><br>
<img src="/img_520/19.png" alt=""><br>
<img src="/img_520/20.png" alt=""></p>
<p><strong>Non context-free language</strong>:<br>
<img src="/img_520/21.png" alt=""></p>
<blockquote>
<p>For any context free language L, there is a pumping length p such that for any string<br>
z ∈  L of sufficient length p≥1 or more, there is a decomposition of string z into 5−PART uvwxy s.t.:</p>
<ol>
<li>|vwx|≤p    middle three≤p (not too far apart)</li>
<li>|vx|&gt;0 pumping part of length nonegative</li>
<li>for any i≥0  uv^i wx^i y  stays in L<br>
<img src="/img_520/22.png" alt=""><br>
<strong>Both CFG-PL AND REG-PL are necessary but not sufficient conditions for context-freeness/regularity.</strong></li>
</ol>
</blockquote>
<p><strong>pumping lemma proof idea:</strong> for a sufficiently long string and its parse tree, the longest path in the tree by pigenhole principle must have nonterminals that repeat. Therefore Pumping up or down vx, it will remains a valid parse tree</p>
<p><strong>Language hierarchy &amp; Decidable and recognizable language</strong><br>
<img src="/img_520/23.png" alt=""><br>
A <strong>decision problem</strong> can be expressed as a language, which is a set<br>
A language is called a Recursively enumerable set (language) [also recognizable, partially decidable, semidecidable, Turing-acceptable or Turing-recognizable] if it is a recursively enumerable subset in the set of all possible words over the alphabet of the language, i.e., if there exists a Turing machine which will enumerate all valid strings of the language.</p>
<p>Recursive set, decidable set, computable set refers to the set of decision problem that are decidable in polynomial time</p>
<p>A complete set is a set of problems that are “hard”:<br>
Np hard: every problem in np can reduce to it<br>
Ex. To prove np-complete  first show it is np, then prove it is np hard, namely choose a np complete problem and reduce to it<br>
<img src="/img_520/24.png" alt=""><br>
<a href="https://en.wikipedia.org/wiki/Complete_(complexity)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Complete_(complexity)</a></p>
<p><img src="/img_520/25.png" alt=""><br>
<img src="/img_520/26.png" alt=""><br>
<img src="/img_520/27.png" alt=""></p>
<p><strong>Proving problems undecidable<br>
Turing machine and halting problem</strong><br>
Refers to handouts<br>
<img src="/img_520/28.png" alt=""><br>
<img src="/img_520/29.png" alt=""><br>
<strong>多带图灵机与单带图灵机等价</strong><br>
A turing machine accepts input if there is a sequence of configuration from starting config to accepting config<br>
A turing machine is decidable if there is some decider for it(always halt and acc or rej).<br>
Every NDTM has a equivalent DTM<br>
ATM, HaltTM, Etm, Eqtm, PCP is undecidable but Turing-recognizable/recursively enumerable<br>
<img src="/img_520/30.png" alt=""><br>
<img src="/img_520/31.png" alt=""></p>
<p><strong>Undecidability and Rice’s theorem<br>
Rice’s theorem:</strong><br>
<img src="/img_520/32.png" alt=""><br>
A property is a set of Turing machine. A TM satisfies P means TM is in the set.<br>
A property P is nontrivial means there is a TM that satisfies it and there is a TM that does not satisfies it.<br>
A property P is trivial means either it is satisfied by all TMs or it is satisfied by no TMs.</p>
<p>Any nontrivial property about the r.e. language recognized by a Turing machine is undecidable.</p>
<p><strong>Reduction</strong> <a href="https://en.wikipedia.org/wiki/Reduction_(complexity)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reduction_(complexity)</a><br>
A reduces to B means we can use an efficient solution of B as a subroutine to solve A     hardness of B 大于等于 A<br>
<strong>Computational complexity</strong><br>
<a href="https://blog.csdn.net/golden1314521/article/details/51470999" target="_blank" rel="noopener">https://blog.csdn.net/golden1314521/article/details/51470999</a></p>
<p>NP completeness theory is designed to be applied only to decision problem.<br>
解决一个decision problem 等价于recognizing a corresponding language<br>
A language is a set that contains all strings accepted by the turing machine.<br>
<strong>Class P</strong>： 以单带图灵机定义的【 所有多项式时间内deterministically recognizable language】<br>
<strong>Class NP</strong>: NTM Augmented Model of one tape turing machine with guessing ability<br>
NTM 定义了 class NP: All languages recognizable nondeterministically in Polynomial time / there is a polynomial time NDTM program that accepts the language<br>
NP is the class of languages that have polynomial time verifiers for the membership of an arbitrary instance given.<br>
<img src="/img_520/33.png" alt=""></p>
<p>A p-time mapping reduce to B means:  there is a transformation function that given an instance a of A 包装成 instance of B f(a)=b in polynomial time such that membership of  a and b in A and B. resp 同进同出</p>
<p>多项式时间于伪多项式时间<br>
动态规划解决subsetsum</p>
<h4 id="textbook-reference"><a class="markdownIt-Anchor" href="#textbook-reference"></a> <strong>Textbook Reference</strong></h4>
<p>Computers and Intractability A Guide to the Theory of NP Completeness -  Michael R. Garey and David S. Johnson<br>
Introduction to the theory of computation third edition - Michael Sipser<br>
Introduction To Automata Theory, Languages, And Computation 3rd - John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman</p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Theory-of-computation/">Theory of computation</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-real-analysis" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/10/real-analysis/"
    >real analysis</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/12/10/real-analysis/" class="article-date">
  <time datetime="2018-12-09T18:00:41.000Z" itemprop="datePublished">2018-12-09</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>summary and notes upon compeletion of the course and self study notes.<br>
<a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/real_analysis.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/real_analysis.pdf</a><br>
Textbook reference<br>
Principles of Mathematical Analysis - Rudin<br>
Analysis I - Terrence Tao</p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Compiler" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/09/Compiler/"
    >Programming language and Compiler</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/12/09/Compiler/" class="article-date">
  <time datetime="2018-12-09T03:40:41.000Z" itemprop="datePublished">2018-12-08</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>summary &amp; notes upon compeletion of course on programming language and compiler<br>
<a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/CS536.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/CS536.pdf</a><br>
Textbook reference<br>
Engineering a compiler. [Keith_D._Cooper_Linda_Torczon]</p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Compiler/">Compiler</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-probability" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/02/probability/"
    >Math431-probability theory</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/12/02/probability/" class="article-date">
  <time datetime="2018-12-02T04:30:02.000Z" itemprop="datePublished">2018-12-01</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>notes collection<br>
<a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/probability.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/probability.pdf</a></p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Digital-system-fundamental" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/05/22/Digital-system-fundamental/"
    >Digital system fundamental</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/22/Digital-system-fundamental/" class="article-date">
  <time datetime="2018-05-22T00:43:32.000Z" itemprop="datePublished">2018-05-21</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>summary and notes upon compeletion of the course.<br>
<a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/digital_circuit.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/digital_circuit.pdf</a></p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Science/">Computer Science</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-ai" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/05/20/ai/"
    >CS540 Intro to AI Notesheet</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/20/ai/" class="article-date">
  <time datetime="2018-05-19T18:00:41.000Z" itemprop="datePublished">2018-05-19</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <img width="1000" src="/img_540/1.png">
<img width="1000" src="/img_540/2.png">
<img width="1000" src="/img_540/3.png">
<img width="1000" src="/img_540/4.png">
<img width="1000" src="/img_540/5.png">
<img width="1000" src="/img_540/6.png">
<img width="1000" src="/img_540/7.png">
<img width="1000" src="/img_540/8.png">
<img width="1000" src="/img_540/9.png">

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Science/">Computer Science</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-algorithm" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/05/06/algorithm/"
    >CS577 Algorithm Notesheet</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/06/algorithm/" class="article-date">
  <time datetime="2018-05-06T00:00:01.000Z" itemprop="datePublished">2018-05-05</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <img width="1000" src="/img_algo/1.png">
<img width="1000" src="/img_algo/2.png">
<img width="1000" src="/img_algo/3.png">
<img width="1000" src="/img_algo/4.png">
<img width="1000" src="/img_algo/5.png">
<img width="1000" src="/img_algo/6.png">

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Linear-algebra" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/12/12/Linear-algebra/"
    >Linear algebra</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/12/12/Linear-algebra/" class="article-date">
  <time datetime="2017-12-11T19:45:24.000Z" itemprop="datePublished">2017-12-11</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>summary and notes upon compeletion of the course &amp; self study notes.<br>
<a href="https://github.com/th2zz/th2zz.github.io/blob/master/notes/linear_algebra.pdf" target="_blank" rel="noopener">https://github.com/th2zz/th2zz.github.io/blob/master/notes/linear_algebra.pdf</a></p>
<p>Textbook Reference<br>
Introduction to Linear Algebra 4th Edition by Gilbert Strang<br>
Applied Linear Algebra (Undergraduate Texts in Mathematics) 2nd ed. 2018 Edition by Peter J. Olver, Chehrzad Shakiban</p>

      
      <!-- reward -->
      
    </div>
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2016-2020
        th2zz
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="th2zz"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Suche">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['生きるとはつまり螺旋のことだったんだよ！','',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>