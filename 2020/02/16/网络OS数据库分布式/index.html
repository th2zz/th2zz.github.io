<!DOCTYPE html>
<html lang="en">

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    总结 |  th2zz
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/assets/torr3.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

</head>

</html>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-网络OS数据库分布式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  总结
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/16/网络OS数据库分布式/" class="article-date">
  <time datetime="2020-02-15T18:14:41.000Z" itemprop="datePublished">2020-02-15</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">15.7k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">59分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="网络模型"><a class="markdownIt-Anchor" href="#网络模型"></a> 网络模型</h1>
<ul>
<li>电路交换
<ul>
<li>不灵活 成本高 需要专有物理线路 需要建立专有连接 线路利用率低 没有转发机制</li>
<li>容易受网络中断影响</li>
</ul>
</li>
<li>包交换
<ul>
<li>更灵活 成本低 不需要专用线路 可以线路复用  线路利用率高</li>
<li>不容易受网络中断影响</li>
</ul>
</li>
<li>我们的网络：**统计复用包交换网络 ** 统计复用=排队
<ul>
<li>Internet:<strong>不可靠网络</strong> IP-service model / IP best-effort network /最大努力网络
<ul>
<li>包可以<strong>丢失重复重排</strong> packets may <strong>lose, duplicate, reorder</strong></li>
<li><strong>无连接最大努力目的地转发</strong> connectionelss best-effort destination based forwarding.</li>
</ul>
</li>
<li>可靠：保证包能够<strong>不丢失 不重复 按序到达 无差错</strong></li>
</ul>
</li>
</ul>
<h1 id="传输过程和基本术语"><a class="markdownIt-Anchor" href="#传输过程和基本术语"></a> 传输过程和基本术语</h1>
<p><img src="https://img-blog.csdnimg.cn/20181201104548931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTkyMDQ4,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>包在每个网络节点传输方式：<strong>上至下层层封装header 下至上层层解包</strong>
<ul>
<li>Message “报文” <strong>应用层</strong>的名称</li>
<li>Segment “报文段”  起始于<strong>传输层</strong>的信息单元</li>
<li>Datagram  “数据报 ” 使用<strong>udp等无连接服务</strong>的<strong>网络层</strong>信息单元</li>
<li>Packet “分组/包” 起始于<strong>网络层</strong>的信息单元</li>
<li>Frame“帧” 起始于<strong>链路层</strong>的传输单元</li>
<li>bit “比特” <strong>物理层</strong>单元</li>
</ul>
</li>
<li>Links: 链路 连接节点的物理介质</li>
<li>服务/接口: 不同层之间</li>
<li>协议：平级的peer之间</li>
<li>端对端 Client to Server  点对点 otherwise | 应用和传输层端对端
<ul>
<li>E2E总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</li>
<li>P2P总时延 = 传输时延 + 传播时延</li>
</ul>
</li>
<li>连接建立断开：通常需要多次握手/挥手</li>
<li><strong>两个port+ip 定义一个tcp stream / udp message</strong></li>
<li><strong>流量控制：保证接受者buffer能承受住  拥塞控制： 保证网络不过于堵塞</strong></li>
<li>可靠：保证包能够<strong>不丢失不重复按序到达无差错</strong>   重发丢失/损坏的包</li>
<li>根据信息在传输线上的传送方向，分为以下三种通信方式：
<ul>
<li>单工通信Simplex：单向传输</li>
<li>半双工通信Half-duplex：双向<strong>交替</strong>传输</li>
<li>全双工通信Duplex：双向<strong>同时</strong>传输</li>
</ul>
</li>
<li>局域网：多种不同结构
<ul>
<li>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。有多种局域网技术，其中以太网占主导地位。可以按照网络拓扑结构对局域网进行分类：星 环 直线</li>
</ul>
</li>
<li>以太网：星形结构局域网 中间使用集线器或交换机连接</li>
<li>MAC地址 链路层地址 48位 设备网卡的唯一标识 有多少个适配器=多少个mac地址 os可更换</li>
<li>网络设备
<ul>
<li>Hub 集线器 <strong>[layer 1 物理层]</strong>  作用于物理层的 能使多个主机 创建一个广播频道(only floods)的设备 具备多个网口，专门实现多台计算机的互联作用。</li>
<li>Repeater 中继器**[layer 1 物理层]** 接收并重复信号</li>
<li>Switch 交换机 <strong>[layer 2 数据链路层]</strong> 收处理转发以太网帧到网络中的其他设备 会维护一个&lt;mac link/接口&gt; 表 “交换表” 表类似一个LRU缓存 因此能够实现mac地址识别=说它具有“学习能力”. 支持同时存在多个点对点连接。</li>
<li>Bridge 网桥**[layer 2 数据链路层]** 连接两个局域网</li>
<li>Router 路由 <strong>[layer 3 网络层]</strong> 根据routing table提供转发和路由两种功能 转发：将数据包移送到合适输出端 路由：决定数据包的路由路径。</li>
<li>Gateway 网关 <strong>[layer 3 物理层]</strong>  两个不同网络之间的关口设备</li>
</ul>
</li>
</ul>
<h1 id="网络io模型"><a class="markdownIt-Anchor" href="#网络io模型"></a> 网络IO模型</h1>
<ul>
<li>同步
<ul>
<li>阻塞IO  更高CPU利用率  进程被阻塞 内核代替进程完成操作后返回状态码 进程恢复</li>
<li>非阻塞IO 浪费cpu  轮询 不可用则内核返回错误代码</li>
<li>IO复用: 让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O
<ul>
<li>早期的实现
<ul>
<li>select 等待固定数量的fd中1个或多个成为就绪状态  适用于实时性要求高的情况</li>
<li>poll 等待一组描述符中1个成为就绪状态   适合实时性要求相对宽松情况</li>
</ul>
</li>
<li>更现代的事件驱动实现
<ul>
<li>epoll linux的io事件通知机制 监视多个fd等待任意一个可用  使用红黑树管理监视中的fd <strong>适用于linux上管理大量长连接情况</strong>
<ul>
<li>epoll_create创建一个epoll实例 epoll_ctl把一个事件添加到epoll列表 epoll_wait等待一个io事件就绪 否则阻塞calling thread</li>
<li>默认level triggered: epoll_wait监测到事件发生通知进程 进程可以不处理 下次调用时再处理</li>
<li>edge triggered发生事件立即通知 进程要立即处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信号驱动 使用较少 非阻塞等待创建signal handler 数据就绪后 os 发信号代表可以开始io 比非阻塞cpu利用率更高</li>
</ul>
</li>
<li>异步: 进程调用aio_read后立即返回 当io完成后os内核向进程发信号</li>
</ul>
<h1 id="分层架构"><a class="markdownIt-Anchor" href="#分层架构"></a> 分层架构</h1>
<ul>
<li>OSI architecture 7层协议 注重通信协议必要功能
<ul>
<li>应用层：<strong>e2e 用户服务</strong>  <strong>HTTP FTP DNS DHCP</strong> 远程登录 邮件
<ul>
<li>表示层：数据表示, 压缩, 加密</li>
<li>会话层：建立及管理会话 <strong>SSL RPC</strong></li>
</ul>
</li>
<li>传输层：<strong>e2e 为应用进程提供端对端通信+在应用层网络层之间multiplexing和demultiplexing TCP UDP</strong></li>
<li>网络层：<strong>p2p 无连接通讯，寻址，路由</strong> 控制数据在子网中的运行.  <strong>IP ICMP RIP OSPF BGP</strong> ARP</li>
<li>数据链路层： <strong>p2p 相邻网络节点/主机的数据的格式化与传输控制</strong> <strong>LAN WAN LLC MAC</strong> ARP MTU</li>
<li>物理层：点对点比特流传输 01=电流强弱 数模转换 模数转换</li>
</ul>
</li>
<li>TCP/IP architecture 4层协议 计算机上实现应关心的 除了传输层 网络层 其他上下合并
<ul>
<li>应用层：应用+表示+会话</li>
<li>传输层，网络层</li>
<li>链路层：数据链路+物理</li>
</ul>
</li>
</ul>
<h2 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h2>
<p>Data Link Layer 点对点<strong>相邻网络节点/主机的数据的格式化与传输控制</strong> e.g. <strong>LAN WAN LLC MAC</strong> ARP MTU</p>
<ul>
<li>包装成帧<strong>Framing</strong> 把网络层传下来的包封装成帧 加个开始和结束</li>
<li>点对点传输控制<strong>P2P transmission control</strong>: <strong>Logical link control (LLC)</strong>
<ul>
<li><strong>Error Detection</strong> CRC checksum</li>
<li><s><strong>Flow Control</strong> &quot; only used in wireless networks</s></li>
</ul>
</li>
<li>广播控制<strong>Broadcast</strong>: <strong>Media access control (MAC)</strong>
<ul>
<li><strong>Frames synchronization</strong> 帧的同步 clock based, character counting, byte stuffing. STX ETX</li>
<li><strong>Channel sharing</strong> 信道共享方法:
<ul>
<li>信道复用：时分，频分，码分</li>
<li>交替：轮询，令牌传递</li>
<li>随机访问   主要例子：Aloha, Ethernet
<ul>
<li>Ethernet MAC采用CSMA/CD协议 (Carrier Sense Multiple Access / Collision Detection) 载波监听多点接入/碰撞检测
<ul>
<li>线路空闲立即发送 (Carrier Sense 载波监听)</li>
<li>如果繁忙等待 “inter-frame gap” = 96 bit time</li>
<li>冲突发现，发送 jam signal, 进行二进制指数后退{1,2,4,8,…}, 然后延迟k*51.2 μs&quot; collision domain 冲突域 = 1 RTT</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h2>
<p><strong>点对点无连接通讯，寻址，路由</strong> 控制数据在子网中的运行. 涉及协议： IP, ARP, ICMP, RIP, OSPF, BGP  IP是个不可靠的协议因为无连接 它的可靠性需要通过上层如TCP实现</p>
<ul>
<li>寻址
<ul>
<li>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom:40%;">
</li>
<li>IP: 沙漏结构的中点，连接异构网络，使之看起来统一
<ul>
<li><strong>地址系统</strong>
<ul>
<li>Class-based addressing (过去版本):  lead to problem of large# networks in routing table</li>
<li>Subnetting and supernetting 子网与超网
<ul>
<li>子网 方便管理和路由效率 subnet ip = subnet mask &amp; host ip address</li>
<li>超网 用于跨网路由 CIDR 无分类跨网地址系统
<ul>
<li>ip地址=网络前缀+主机号 128.14.35.7/20 表示前 20 位为网络前缀。</li>
<li>意义：减少了路由表项   查找时采取最长前缀匹配原则选择哪一个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>路由
<ul>
<li><strong>ARP：Broadcast &amp; Responds路由器确定设备MAC</strong>
<ul>
<li>routers and hosts maintain an <strong>dynammic &lt;IP, MAC&gt; LRU cache</strong> called ARP table. For unkown IP, router <strong>broadcast ARP request</strong>, <strong>hosts</strong> with that IP address <strong>reply its MAC</strong></li>
</ul>
</li>
<li>Routing types and protocols
<ul>
<li>网内路由Intra-domain
<ul>
<li>RIP Routing Information Protocol:  rely on local computation in all nodes
<ul>
<li>Distance Vector Protocol (based on <strong>Bellman-ford</strong>)</li>
</ul>
</li>
<li>OSPF Open Shortest Path First Protocol: no local computation  <strong>faster nonegative edge weight-loop-free convergence</strong>
<ul>
<li>Link state Protocol (based on <strong>Dijkstra’s shortest path</strong>)</li>
</ul>
</li>
</ul>
</li>
<li>跨网路由Inter-domain: <strong>BGP Border Gateway Protocol</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>报文的拆分重组</strong> Fragmentation/Reassembly: 使得异构网络能够以最大传输大小传输包
<ul>
<li>和tcp合作 tcp负责mtu discovery
<ul>
<li>TCP MTU Discovery: 不断增大发送数据包大小直到获得数据包过大的ICMP响应得出mtu</li>
</ul>
</li>
<li>和数据链路层合作 mtu协议定义链路支持最大传输大小</li>
</ul>
</li>
<li><strong>错误报告和控制</strong> ICMP</li>
<li>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" alt="img" style="zoom:30%;">
- **封装在 IP 数据报中**，但是不属于高层协议。
</li>
<li>ping 用来测试两台主机之间的连通性 通过icmp echo实现</li>
<li>Traceroute 追踪一个数据包路径: 封装一个<strong>无法交付的udp包</strong>, 利用IP协议的**“ttl”字段**，尝试从每个网关到某个主机的路径引发ICMP 超时响应。</li>
</ul>
<h2 id="传输层tcpudp"><a class="markdownIt-Anchor" href="#传输层tcpudp"></a> 传输层TCP/UDP</h2>
<p><strong>端对端为应用进程提供端到端的通信服务 在应用层和网络层之间multiplexing和demultiplexing</strong> e.g. TCP UDP</p>
<ul>
<li>UDP: bare-bone protocol
<ul>
<li><strong>无连接 不可靠 无流量拥塞控制</strong> 无时限吞吐量安全保证</li>
<li>但更可控更自由 可以在应用层实现可靠传输: RUDP</li>
<li>UDP header：src port, dest port, header length, checksum</li>
</ul>
</li>
<li>TCP: 面向连接 可靠 流量拥塞控制 基于字节流 全双工 差错校验
<ul>
<li><strong>TCP header:</strong>
<ul>
<li>SRC，DST ports (16-bit each)</li>
<li><strong>Sequence #序号,     Ack #确认号</strong>(32-bit each) 序号：当前数据段第一个字节编号 tcp要用序号拼接数据 确认号：期望下个数据段第一个字节编号</li>
<li>Header length(data offset), reserve</li>
<li>Flags(indicate pkt types): <strong>SYN FIN ACK</strong> URG(紧急指针) PSH(不在接受者缓冲区等待) RST重制连接标志</li>
<li><strong>Receive window</strong> (16-bits 发送者接收窗口的大小) 用于<strong>流量控制flow control</strong></li>
<li><strong>Check sum: for error detection</strong></li>
<li><strong>Urgent Ptr: 优先级</strong></li>
<li>Options</li>
</ul>
</li>
<li>全双工：建立连接后可以双向收发数据</li>
<li>以连接为导向： 意味着需要主动建立连接</li>
<li>TCP提供包级别的可靠传输 (IP最大努力网络不能保证)
<ul>
<li>UDP只提供位级别的可靠传输 由checksum实现 只能进行简单的检测看看数据是否污染</li>
</ul>
</li>
<li><strong>如何实现可靠传输</strong>：不丢失 不重复 按序到达 无差错
<ul>
<li>不丢失
<ul>
<li>确定包收到了：ack机制</li>
<li>确定包没收到：<strong>计时器/超时检测机制Retransmission Timeout</strong> 制定了超时标准要比RTT稍微多一点尽量接近RTT, RTO新= RTO旧*2  by karn’s algorithm</li>
<li>丢包补救：快重传+urgent ptr</li>
</ul>
</li>
<li>不重复 按序到达
<ul>
<li>滑动窗口</li>
</ul>
</li>
<li>无差错
<ul>
<li>Check sum</li>
</ul>
</li>
</ul>
</li>
<li>提供流量控制：确保接收方的buffer不会overflow
<ul>
<li>receiver发送的ack报文中的receiver window表示自己仍可缓存的容量 若超过这个限制 sender必须等待receiver的ack和更新。将窗口字段设置为 0，则sender停止发送数据。这实际上调整了sender发送窗口大小和发送速率。</li>
</ul>
</li>
<li>提供拥塞控制：与整个网络有关, 网络比较拥挤的时候控制发送方的窗口。增加一个congestion window CWND
<ul>
<li><strong>send window (#unacknowledge pkts in flight) = min(CWND, RWND</strong>) 当cwnd更小时，我们就进入了一个拥塞控制的模式
<ul>
<li>慢开始与拥塞避免
<ul>
<li>cwnd := 1, cwnd++ for each ack == cwnd*=2 each RTT 慢慢探测网络容量 指数增长 但是又被临界值限制 到达临界值后线性增长避免拥塞</li>
<li>cwnd &gt;= ssthresh do congestion avoidance: cwnd++ for each RTT;</li>
</ul>
</li>
<li>快重传和快恢复： 快重传解决丢包重发问题（3个重复包=包丢失），快恢复临界值减半后线性增长拥塞窗口：适应性的避免网络拥塞 on dupack (pkt loss) fast retransmit the next sequence from receiver side.  Fast recover it by setting ssthresh = cwnd/2, cwnd = ssthresh, do congestion avoidance</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三次握手-四次挥手"><a class="markdownIt-Anchor" href="#三次握手-四次挥手"></a> 三次握手 四次挥手</h3>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:35%;">
<ul>
<li>
<p><strong>为什么三次握手</strong>：TCP是一个<strong>全双工</strong>通信协议，也就是说它是<strong>双向收发</strong>的。<strong>初始序号是两边都要随机选择</strong>:因为安全问题要避免TCP sequence prediction attack。<strong>所以双方都要告诉对方自己的初始序号</strong> = 也就是<strong>通信双方数据原点的位置</strong>，<strong>所以至少要4次握手</strong>。SYN  ACK SYN ACK, <strong>然后因为tcp header里reserve flags部分SYN ACK是可以同时为1的 中间两个步骤可以合并</strong> 所以3次就够。</p>
</li>
<li>
<p>第三次握手过程中sender可以piggypack data而receiver只能在这次握手结束才可以。</p>
</li>
<li>
<p>在linux socket编程中，客户端执行connect()时，将触发三次握手。<br>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom:50%;"></p>
</li>
<li>
<p><strong>为什么四次挥手</strong>因为tcp全双工+tcp半关闭造成的。假如client主动关闭，那么直到client收到server的ack前，数据传输仍然可以从server—&gt;client进行，tcp是半关闭的client-server关了但server-client方向还没关，这也是为什么有close-wait状态的原因，服务器端要等待最后这一波数据传输的完成。所以这也解释了中间两次为什么不能像建立连接一样合并。当服务器没有数据要传时他就可以通过fin来释放自己方向的连接了。</p>
</li>
<li>
<p><strong>TIME_WAIT / 2MSL等待状态</strong>:</p>
<ul>
<li>确保server收到ack
<ul>
<li>server接受了ack不需要TIME_WAIT，因为它已经完成同步了可以释放资源了。</li>
<li>client必须等待确定server收到ack，否则client直接关闭server会可能收不到ack无法正常关闭。</li>
<li>ack最久要1MSL到达server或者最坏情况没收到。取上界=1MSL</li>
<li>等待server回复的超时重传消息=最坏情况又1MSL</li>
<li>最坏要2MSL client才知道ack有没有到达</li>
</ul>
</li>
<li>避免新旧连接混淆</li>
</ul>
</li>
<li>
<p>在linux socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
</li>
</ul>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3>
<ul>
<li>TCP使用滑动窗口实现流量控制和乱序重排和去重 (虽然tcp byte-oriented 以下为了方便说明 改为包/sequence 而不是字节)
<ul>
<li>流量控制：
<ul>
<li>Receive window用于接收方通知发送方自己还有可用缓冲区大小，发送方据此调整发送数据多少, 从而保证流量控制</li>
</ul>
</li>
<li>sender缓存：<strong>已发送但未确认的包</strong></li>
<li>receiver缓存：<strong>未按序到达的包</strong></li>
<li>sender发送流水线化  提高信道利用率</li>
<li>receiver回复cumulative ack:
<ul>
<li>receiver只对窗口内最后一个按序到达的包进行确认 = 之前全部按序到达窗口向右滑动</li>
<li>对于按序未到达的包 sender收不到ack超时重传</li>
<li>receiver收到该包，如果【该包+已缓存的未按序到达的包 】构成一段连续有序的segment 那么他们可以被交付给应用进程，窗口向右滑动</li>
</ul>
</li>
</ul>
</li>
<li>sender</li>
</ul>
<table>
<thead>
<tr>
<th>窗口外已发送并收到确认</th>
<th><strong>已发送未确认</strong></th>
<th><strong>可发但未发</strong></th>
<th>窗口外不可发送</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>receiver</li>
</ul>
<table>
<thead>
<tr>
<th>窗口外按序到达acked且交付的</th>
<th><strong>按序未到达</strong></th>
<th><strong>未按序到达</strong></th>
<th>允许接受</th>
<th>窗口外不许接收</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" style="zoom:40%;">
<h3 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h3>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" alt="img" style="zoom:30%;"><br>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" alt="img" style="zoom:30%;"></p>
<h4 id="慢开始与拥塞避免"><a class="markdownIt-Anchor" href="#慢开始与拥塞避免"></a> 慢开始与拥塞避免</h4>
<ul>
<li>Slow start: 初始 cwnd = 1，每收到1个ack cwnd++，cwnd指数增长：2、4、8 …</li>
<li>为cwnd避免过快，设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免-每个轮次cwnd++ 线性增长</li>
<li>若超时: 令 ssthresh = cwnd / 2，重新执行慢开始。</li>
</ul>
<h4 id="快重传与快恢复"><a class="markdownIt-Anchor" href="#快重传与快恢复"></a> 快重传与快恢复</h4>
<ul>
<li>如何确定报文丢失：接收方只对最后一个收到的有序报文段进行确认。在发送方，如果收到<strong>三个重复确认</strong>，那么可以知道接收方下一个报文段丢失，此时执行快重传</li>
<li>只是丢失个别报文段而不是网络拥塞：执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，直接进入拥塞避免cwnd线性增长<br>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" alt="img" style="zoom:40%;"></li>
<li>SYN flood: client发第一个syn后下线server没收到ack不断尝试直到超时 linux:5次 1+2+…+32=63秒才断开连接，可被恶意利用
<ul>
<li>防护:linux提供tcp_syncookies的参数 当syn队列满了 server通过该参数回发SYN cookie 若client非恶意会回复SYN cookie 直到连接成功建立</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h2>
<ul>
<li>2种架构: Client Server / Peer to Peer平级</li>
<li>Socket = 门, 传输层 = 走廊</li>
<li>主机和进程可以被ip+端口定义</li>
<li>远程登录： SSH  TELNET</li>
<li>邮件： 发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</li>
<li>不同情况下应用有不同需求 数据丢失 vs 实时性 vs 吞吐量</li>
</ul>
<h3 id="常用端口"><a class="markdownIt-Anchor" href="#常用端口"></a> 常用端口</h3>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>端口号</th>
<th>传输层协议</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>域名解析</strong></td>
<td><strong>DNS</strong></td>
<td><strong>53</strong></td>
<td><strong>UDP/TCP</strong></td>
<td><strong>长度超过 512 字节时使用 TCP</strong></td>
</tr>
<tr>
<td><strong>动态主机配置协议</strong></td>
<td><strong>DHCP</strong></td>
<td><strong>67/68</strong></td>
<td><strong>UDP</strong></td>
<td></td>
</tr>
<tr>
<td><strong>超文本传送协议</strong></td>
<td><strong>HTTP</strong></td>
<td><strong>80</strong></td>
<td><strong>TCP</strong></td>
<td></td>
</tr>
<tr>
<td><strong>文件传送协议</strong></td>
<td><strong>FTP</strong></td>
<td><strong>20/21</strong></td>
<td><strong>TCP</strong></td>
<td>数据连接 20，控制连接 21</td>
</tr>
<tr>
<td>远程终端协议</td>
<td>TELNET</td>
<td>23</td>
<td>TCP</td>
<td>ssh = 22</td>
</tr>
<tr>
<td>简单邮件传送协议</td>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>邮件读取协议</td>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>网际报文存取协议</td>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> FTP</h3>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg" alt="img" style="zoom:50%;">
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg" alt="img" style="zoom:50%;">
<ul>
<li>
<p>服务器主动(客户端配置服务端firewall) 服务器被动(只需开放端口号 不安全)</p>
</li>
<li>
<p>2个TCP连接： TCP数据连接端口20, TCP控制连接端口21.</p>
</li>
</ul>
<h3 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h3>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg" alt="img" style="zoom:50%;">
<p>只适用于动态ip分配的情形，如进入一个新的移动网络。 主机不知道自己ip地址 ask dhcp server, 配置好IP地址,子网掩码,网关 IP 地址.</p>
<ul>
<li>client使用udp同子网内广播discover报文</li>
<li>dhcp server返回offer 包括多种选择</li>
<li>client选择一个ip 发送request</li>
<li>dhcp server返回ack</li>
</ul>
<h3 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h3>
<img src="https://s2.ax1x.com/2020/02/03/1NTl4S.png" alt="dns" style="zoom:31%;">
<img src="https://s2.ax1x.com/2020/02/03/1NTMAf.png" alt="dns" style="zoom:31%;">
<img src="https://s2.ax1x.com/2020/02/03/1NTuHP.png" alt="recdns" style="zoom:30%;">
DNS 可以使用 **UDP 或者 TCP** 进行传输，**使用的端口号都为 53**。大多数情况下 DNS 使用 **UDP** 进行传输，这就要求域名解析器和域名服务器都必须**自己处理超时和重传**从而保证可靠性。在两种**特殊情况下会使用 TCP** 进行传输：
<ul>
<li>如果返回的响应超过 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>DNS zone transfer</li>
</ul>
<h4 id="dns-负载均衡"><a class="markdownIt-Anchor" href="#dns-负载均衡"></a> DNS 负载均衡</h4>
<p>同一主机在dns服务器里配置多个主机记录=多个不同服务器ip，dns服务器解析域名时会轮询，这就完成了简单的负载均衡。</p>
<h3 id="http-https"><a class="markdownIt-Anchor" href="#http-https"></a> HTTP HTTPS</h3>
<ul>
<li>URI 包含 URL 和 URN。</li>
<li>HTTP是无状态的
<ul>
<li>请求互相独立， 类似事务</li>
<li>编程，本地储存，cookie，session是用来提高用户体验的</li>
</ul>
</li>
<li>HTTPS 并不是新协议，而是让 <strong>HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信</strong>，也就是说 HTTPS 使用了隧道进行通信。
<ul>
<li>SSL使用RSA算法 public key加密 private key解密</li>
</ul>
</li>
<li>API
<ul>
<li>Get 从服务器获取数据</li>
<li>Post 提交数据给服务器</li>
<li>Head 获取报文头部</li>
<li>Put/Delete 上传文件/删除文件 不安全没有验证机制</li>
<li>Patch 部分修改资源</li>
</ul>
</li>
<li>状态码
<ul>
<li>200 OK</li>
<li>3XX 重定向</li>
<li>4XX 客户端错误 如 404 NOT FOUND</li>
<li>5XX 服务端错误</li>
</ul>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png" width=""> </div><br>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png" width=""> </div><br>
<table>
<thead>
<tr>
<th>HTTP1.0</th>
<th>http1.1</th>
<th>http2.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认短连接: 一次TCP连接进行一次HTTP通信. 如需使用长连接，使用 <code>Connection : Keep-Alive</code></td>
<td>默认长连接persistent connection: 建立一次 TCP 连接就能进行多次 HTTP 通信. 断开连接需要client/server使用 <code>Connection : close</code></td>
<td>Header压缩</td>
</tr>
<tr>
<td>请求发出后需要等待响应才能发下一个请求</td>
<td>引入流水线: 同一条长连接上不等待响应连续发出请求, 减少延迟</td>
<td>解决了流水线情况下HOL blocking 类似饥饿现象</td>
</tr>
<tr>
<td>N/A</td>
<td>引入cookie保存状态信息</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<h3 id="get-post比较"><a class="markdownIt-Anchor" href="#get-post比较"></a> Get Post比较</h3>
<ul>
<li>get将请求信息放url里 post放报文体中</li>
<li>get符合<strong>幂等性</strong>和<strong>安全性</strong>(只读) post不符合(因为是修改操作)</li>
<li>get<strong>可被缓存 绝大多数get请求都被cdn缓存 减少web服务器压力</strong> 可被储存到浏览器记录和书签中 而post不行</li>
</ul>
<h3 id="cookie-session"><a class="markdownIt-Anchor" href="#cookie-session"></a> cookie session</h3>
<ul>
<li>cookie: 存在于client边的保存用户状态信息的文本文件，由浏览器储存到client本地。 方便未来向服务器查询用户信息使用。渐渐被淘汰，现在新的浏览器直接支持将数据储存在client本地。存在浏览器中不加密会不安全。但可以减少服务器负担。
<ul>
<li>http request - http response &amp; set-cookie</li>
<li>http request &amp; cookie - http response</li>
</ul>
</li>
<li>session：存在于server边，用于维护用户登录状态，关闭浏览器 一定时间后会失效
<ul>
<li>由cookie实现
<ul>
<li>server分配给每个session唯一的jsessionID server从redis缓存中验证用户信息密码 key=session id</li>
<li>返回http response set-cookie包含session id client收到后将cookie值存入浏览器 之后对sever的请求会包含该cookie值 = session id</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="web页面请求过程"><a class="markdownIt-Anchor" href="#web页面请求过程"></a> Web页面请求过程</h3>
<ul>
<li>DHCP配置基本信息(假设主机最开始没有 IP 地址及其它信息)
<ul>
<li>DHCP udp broadcast - DHCP server offer - select IP - ack(assigned ip, dns server ip, 网关ip, 子网掩码)</li>
<li>因为我们广播过了 ethernet learning switch knows host’s &lt;MAC, link&gt;</li>
<li>DHCP ack到达主机，主机得到ip地址 DNS服务器地址 网关IP 子网掩码 完成配置</li>
</ul>
</li>
<li>需要知道域名IP地址, 先看DNS缓存(browser-os-router-isp), 如果缓存没有, DNS根服务器查询IP 迭代或递归的 从顶级域名到次级域名</li>
<li>得知ip地址，主机通过浏览器和服务器三次握手生成一个 TCP socket，向服务器发送HTTP GET</li>
<li>层层路由  (通过IP获取设备MAC-ARP broadcast &amp; responds) 路由取决于要不要跨网 涉及不同协议</li>
<li>到达服务器，服务器从socket读取 HTTP GET 报文，回复 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<ul>
<li>使用代理服务器或client浏览器进行缓存</li>
<li>http 1.1 使用cache-control字段控制缓存  no-store no-cache(使用缓存先验证有效性) private public
<ul>
<li>max-age: 可在server缓存最大时间  expires 过期时间</li>
</ul>
</li>
<li>验证缓存是否有效：If-none-match: + etag: 资源的唯一标识   备用方案：last modified</li>
</ul>
<h1 id="os"><a class="markdownIt-Anchor" href="#os"></a> OS</h1>
<h2 id="进程线程"><a class="markdownIt-Anchor" href="#进程线程"></a> 进程线程</h2>
<ol>
<li>进程是资源分配的基本单位：正在执行中的指令和上下文。实体：pcb</li>
<li>上下文：pcb里的内容 对应着 用户堆栈 内核堆栈 代码段 寄存器</li>
<li>进程切换=<strong>上下文切换成本高</strong> <strong>IPC通信成本高且困难</strong> 故引入线程</li>
<li>线程同进程内一个执行单元/可调度实体 共享同进程资源：代码段，堆，pid, open fds, 当前目录, 用户和用户组id</li>
<li>线程独立内容：tid, 寄存器(pc, ip, esp)，本地栈</li>
<li>用户内核线程管理取决于内核支不支持内核级线程：多对1，1对1</li>
<li>并行parallelism强调多核和硬件支持是并发的子集: 并发concurrency仅表示<strong>多线程/多进程交替执行</strong>，不要求同时，也不限定cpu数量  =  <strong>同时处理</strong>多任务 <strong>vs</strong> <strong>轮流处理</strong>多任务</li>
<li>fork COW
<ul>
<li>实现：把页表里某些<strong>页标记为</strong><br>
<strong>只读</strong>，count references 只有当write实际发生才分配新页进行拷贝<br>
其他例子：内存的获取：弄一页对应全0的物理内存共享给所有malloc但还没写的引用，使得系统有更多可用虚拟内存</li>
</ul>
</li>
</ol>
<h2 id="6种ipc方式"><a class="markdownIt-Anchor" href="#6种ipc方式"></a> 6种IPC方式</h2>
<p><strong>Pipe</strong> ⾮非命名管道，⽣命周期属于对应的⽗⼦进程</p>
<p><strong>Named Pipe</strong> 命名管道(FIFO)不同于无名管道之处在于它提供了一个路径名,与之关联， 以 FIFO 的⽂件形式存在于文件系统中，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不不相关的进程也能交换数据。 常用于客户**-**服务器应用程序中，FIFO ⽤作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char *path, mode_t mode);</span><br><span class="line">int mkfifoat(int fd, const char *path, mode_t mode);</span><br></pre></td></tr></table></figure>
<p><strong>Message queue</strong> 消息队列列，主要是提供⼀一种<strong>异步</strong>通信方式，消息被保存到队列里，接受者有需要就取回 有很多开源的实现:<strong>Apache activeMQ rocketMQ</strong> 但是异步的缺点是 接受者要进行<strong>polling</strong> 轮询操作才能接受到最近消息。 优点:⽐信号传递更多信息， ⽐管道 可以提供有格式的消息 不需要同步。<br>
<strong>Semaphore</strong><br>
<strong>Shared Memory</strong> 实现困难 要os层面支持 而且要同步不同进程对内存的访问<br>
<strong>Socket</strong> 不同机器</p>
<h2 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h2>
<ul>
<li>合作机制：中断interrupt
<ul>
<li>硬件设备中断：异步的到来 但会被同步 timer / io设备等</li>
<li>软件中断：同步的 系统调用或异常(trap实现)。均有handler处理</li>
</ul>
</li>
<li>cpu虚拟化：公平，高效，安全的分配计算资源</li>
<li>安全机制：用户内核双态转换 通过系统调用作为interface 涉及cpu上下文切换
<ul>
<li>系统调用由trap机制实现 通过索引syscall table呼叫对应trap</li>
</ul>
</li>
<li>调度: 在io的时候充分利用cpu    快速响应=RR=高周转时间 tradeoff 可调度进程在ready queue里
<ul>
<li>批处理：需求-高吞吐量/短周转时间
<ul>
<li>FCFS 非抢占 护送效应“短等长”</li>
<li>SJF 非抢占 长作业饥饿</li>
<li>SCTF 抢占 贪婪 较优</li>
</ul>
</li>
<li>交互式系统：快速响应
<ul>
<li>RR 抢占 低响应时间 高周转时间 时间片太小 上下文切换开销大 太大 不能保证实时性</li>
<li>MLFQ 可抢占 同时保证吞吐量和响应性 多级队列 高级有先同级RR 用完demote 周期性boost防饥饿</li>
</ul>
</li>
<li>实时系统： 一个确定时间段内响应
<ul>
<li>多用抢占式保证及时响应</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="并发控制"><a class="markdownIt-Anchor" href="#并发控制"></a> 并发控制</h2>
<ul>
<li>
<p>cpu pipeline有效提高性能 但有pipeline hazards问题:</p>
<ul>
<li>数据依赖hazards | 分支hazards</li>
</ul>
</li>
<li>
<p>解决方式：cpu指令重排序/乱序执行 | 分支预测</p>
</li>
<li>
<p>缓存不一致：多核cpu上多级缓存不同步</p>
</li>
<li>
<p>内存可见性/一致性问题：缓存内容未同步至主存  cpu编译器指令重排 <strong>内存乱序访问</strong></p>
</li>
<li>
<p>内存屏障: <strong>编译时防止指令重排 运行时保证内存可见性</strong></p>
</li>
<li>
<p>锁实现</p>
<ul>
<li>软件：困难 peterson算法 <strong>过时</strong> 现代处理器会乱序执行</li>
<li>硬件:
<ul>
<li>原子操作：
<ul>
<li>TestAndSet xchgl 更新并返回旧值供外层循环检测</li>
<li>CompareAndSwap CAS 满足期望值则更新。返回旧值供外层循环检测 cmpxchgl</li>
<li>FetchAndAdd xaddl 加上1个数 返回旧值共外层循环检测</li>
</ul>
</li>
<li>内存屏障</li>
</ul>
</li>
</ul>
</li>
<li>
<p>锁类型：<strong>公平=无饥饿</strong></p>
<ul>
<li>自旋忙等待：需搭配抢占式调度 适合多核短持锁时间 <strong>饥饿</strong></li>
<li>yield自旋：自旋很短时间然后yield 减少了响应时间 <strong>饥饿</strong></li>
<li>排号自旋锁: 使用faa，新来拿号，不到回合自旋，<strong>fifo公平 饥饿</strong> | 改进：排号yield</li>
<li>队列锁: os支持 饥饿者扔到waiting queue挂起 锁可用再放回ready queue <strong>公平</strong></li>
<li>混合锁: 定时自旋+队列 linux futex  <strong>公平</strong></li>
</ul>
</li>
</ul>
<h3 id="条件变量管程信号量协程"><a class="markdownIt-Anchor" href="#条件变量管程信号量协程"></a> 条件变量，管程，信号量，协程</h3>
<ul>
<li>
<p>cv: 条件等待队列</p>
<ul>
<li>wait(mutex,cv) 放锁挂起caller，醒后拿锁返回</li>
<li>signal(cv) 唤醒一个挂起的线程</li>
</ul>
</li>
<li>
<p>sv：用于检测状态变化 从而进行wait/signal</p>
</li>
<li>
<p>monitor: mutex + cv + sv 任何时刻只有1个线程进入管程 属于高级同步原语</p>
<ul>
<li>mesa: 唤醒和线程恢复执行非原子 sv可变 需while检测</li>
<li>hoare: 原子唤醒+恢复执行 sv不变 if检测即可</li>
<li>java在语言层级上支持通过管程机制同步 同步方式有两种：<strong>互斥lock sychronized 合作cv Object.wait( ) Object.notify( )</strong>  <strong>每个java对象都有一个锁和cv</strong></li>
<li>2 cvs [empty + fill] + 1 mutex 解决pc问题
<ul>
<li>p wait(empty, mutex) put(i) signal(fill)</li>
<li>c wait(fill, mutex) get() signal(empty)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>semaphore: 初始非负的同步计数器 power(sem) = power(cv + lock)</p>
<ul>
<li>–wait: sem-- &lt;0挂起 &gt;=0通过</li>
<li><ins>signal: sem</ins> 唤醒一个挂起的线程</li>
<li>0=占用 正=最多几个线程同时访问 负=等待中线程数量</li>
<li>sem(1) = mutex, sem(0) = cv, sem(可用资源量) = 共享资源访问控制</li>
<li>3 sem 解决pc问题</li>
</ul>
</li>
<li>
<p>2 sem read lock + write lock + reader_counter 实现读写锁<br>
- 读锁：拿起rl, [若reader_counter=0,拿起wl], 放下rl  同理释放<br>
- 写锁：拿起wl，同理释放</p>
</li>
<li>
<p>协程：用户态特殊函数 可挂起恢复 threadlocal不需要同步 多协程-串行执行</p>
</li>
</ul>
<h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3>
<ul>
<li>哲学家就餐：不可同时拿左手叉子 会造成环形等待 只让<strong>最后一个哲学家先拿右手叉子</strong>即可破解环形等待 | 原子化吃饭</li>
<li>条件与预防 | os调度预防：银行家算法
<ul>
<li>互斥: 获得资源的独占控制            |  预防：不使用锁</li>
<li>占有且等待： 拿着这个还等别的  | 预防：2 phase locking或大粒度锁</li>
<li>不可抢占 | 预防： 得不到锁就释放资源</li>
<li>环形等待 | 预防：决定好锁获得顺序</li>
</ul>
</li>
<li>解决：
<ul>
<li>鸵鸟策略</li>
<li>检测 | 恢复：抢占，回滚，kill，重启系统
<ul>
<li>单个资源：资源waits-for图环判断(拓拓扑排序/dfs)</li>
<li>多个资源：超时检测 标记清除[满足所有可满足+释放资源 长时间不可满足=死锁]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存管理虚拟化"><a class="markdownIt-Anchor" href="#内存管理虚拟化"></a> 内存管理虚拟化</h2>
<ul>
<li>
<p><strong>动态加载</strong>: 调⽤时加载 lazy loading | <strong>动态链接</strong>: 函数执行时lazy定位和链接</p>
</li>
<li>
<p>静态重定位: 进程装⼊入内存前一次性完成逻辑/物理地址的变换 固定的不可变不安全</p>
</li>
<li>
<p>动态重定位：内存虚拟化 访问内存前转换</p>
</li>
<li>
<p><strong>内部碎片</strong>： 分配单元内部的浪费 如padding | <strong>外部碎片</strong>：对于os的无法被分配的小内存洞</p>
</li>
<li>
<p><strong>虚拟化内存</strong>：物理内存通过<strong>分页分段 + on-demand paging</strong>映射为更大逻辑内存</p>
</li>
<li>
<p>页表：映射关系 + 元信息</p>
</li>
<li>
<p>分页：逻辑和物理空间分为固定大小页 4KB=blocksize of disk</p>
<ul>
<li>消除物理内存外部碎片，造成逻辑内存空间连续的假象</li>
<li>按需置换提供更多可用虚拟内存</li>
</ul>
</li>
<li>
<p>分段：地址空间分段code, stack,heap 每个段分配一些固定大小页，每段都有对应页表</p>
<ul>
<li>模块化方便共享保护</li>
</ul>
</li>
<li>
<p>分页分表合用好处：段自由生长，模块化方便共享保护，稀疏地址空间有效减少页表大小</p>
</li>
<li>
<p>TLB: cpu上缓存 mmu组件 含最近访问页表项翻译内容 减少内存访问</p>
</li>
<li>
<p>MMU: cpu上负责逻辑物理地址转换的部分 table walk unit + 多个tlb</p>
</li>
<li>
<p>页置换策略：按需加载：代价page fault 提前加载：只适用于sequential workload 可与用户暗示结合advise</p>
<ul>
<li>OPT: 未来最⻓长时间不不⽤用的 理论最优不实际</li>
<li>FIFO: 进入内存最久的 可能把最常用的踢掉</li>
<li>LRU: 若workload合适 近似opt 但实现困难 要维护一个所有页面链表</li>
<li>Clock: LRU近似 遍历环形buffer ref_bit=0停 清除经过的1</li>
</ul>
</li>
</ul>
<h2 id="文件系统和linux"><a class="markdownIt-Anchor" href="#文件系统和linux"></a> 文件系统和Linux</h2>
<ul>
<li>
<p>硬连接/实体链接: <strong>两路径同inode号</strong> 不可链接⽬录/跨文件系统 ln file hardlink</p>
</li>
<li>
<p>软连接/符号链接: <strong>data block指向路径</strong> ln <strong>-s</strong> file softlink</p>
</li>
<li>
<p>fd_table - file table(各种访问模式read/write/r&amp;w) - inode table  | <strong>stdin out err 0 1 2</strong></p>
</li>
<li>
<p>sigchld: 供父进程用wait/waitpid等子进程的信号</p>
</li>
<li>
<p>孤儿进程：父进程先退出 子进程仍在运行</p>
</li>
<li>
<p>僵尸进程：⼦进程先退出 子进程资源未释放。处理：kill⽗进程使之成为孤⼉ init会回收资源。</p>
</li>
<li>
<p><img src="https://s2.ax1x.com/2020/03/07/3jNHbV.png" alt="3jNHbV.png"></p>
</li>
</ul>
<h1 id="数据库架构"><a class="markdownIt-Anchor" href="#数据库架构"></a> 数据库架构</h1>
<ul>
<li>储存管理storage manager： 将数据库文件以数据库pages形式表示 管理pages读写 pages内可用空间使用 数据库的一页通常和os虚拟内存中的页或硬件的页不同 大小取决于数据库设置
<ul>
<li>文件的表示形式：heapfile sortedfile 说的是pages内记录有序或无序</li>
<li>pages的管理：链表 或 page directory（一个包含所有pages元信息的特殊page）</li>
<li>不同数据类型的表示 固定长度的整数浮点数 不定长度的VARCHAR TEXT BLOB。 数据库系统元信息表</li>
<li>储存模型：row-store适合OLTP workloads, column-store适合OLAP workloads</li>
</ul>
</li>
<li>缓存管理 buffer manager  管理数据库缓存池(磁盘中读来的数据库页)
<ul>
<li>实现：使用哈希表维护当前内存中的页  每个页被修改了就要标记为脏, 此外还有pin counter计数正在使用他的线程数量  正在使用中的页不可以被淘汰</li>
<li>策略：<strong>LRU-k</strong> 普通的LRU和clock会存在sequential flooding问题：顺序扫描冲掉缓存中所有内容</li>
<li>优化：顺序读取情况下根据query plan预读</li>
</ul>
</li>
<li>解析引擎SQL parser：创建语法树 制定logical query plan  &amp; physical query plan(如各种join算法block nested join, hash join)</li>
<li>优化器衡量不同plan的优劣: cost-based search, 抽样统计, 大的策略是尽量走索引。</li>
<li>执行引擎: 按照query plan从上到下执行</li>
<li>锁管理： HashMap&lt;obj_name, &lt;granted_set_txns, lock_mode, wait_queue&gt; + lock upgrade等多粒度锁控制</li>
<li>日志管理：UNDO log: 未完成/aborted事务  REDO log：
<ul>
<li>失败-事务失败 系统失败</li>
<li>策略：
<ul>
<li>shadow paging(COW)</li>
<li>Write-Ahead Logging 每个log entry:&lt;txn_id, obj_id, before_val, after_val&gt;
<ul>
<li>周期性设置检查点将内存中内容flush到disk 作为redo undo操作新起点</li>
<li>physical logging 记录在数据库页的位置  logical logging 记录高层的操作如insert delete update和元数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>容灾机制 ARIES: analyze WAL records + redo starting from a check point + undo uncommitted txns</li>
<li>索引管理</li>
<li>权限管理</li>
</ul>
<h2 id="workloads-oltp-olap"><a class="markdownIt-Anchor" href="#workloads-oltp-olap"></a> Workloads: OLTP OLAP</h2>
<ul>
<li>OLTP online transaction processing （最常见）例如亚马逊购物车界面  只以事务方式<strong>简单查询</strong>语句访问/更新数据库的一 <strong>小范围数据  较少读 较多写 简单查询</strong></li>
<li>OLAP analytical 已经通过oltp取得了数据 通过复杂查询语句在大范围内 进行数据分析 通常不涉及更新数据 kept query by oltp通常以只读方式提供        <strong>大范围数据 较多读 较少写 复杂查询</strong></li>
<li>HTAP hybrid transaction analytical  中间位置， 混合workload</li>
<li>oltp at frontend =&gt;  extract&amp;transform&amp;load =&gt;  olap at back end with datawarehouse</li>
<li>htap db: oltp and olap at same side complicated not easy to build</li>
</ul>
<h1 id="关系数据库设计理论"><a class="markdownIt-Anchor" href="#关系数据库设计理论"></a> 关系数据库设计理论</h1>
<h2 id="函数依赖异常范式"><a class="markdownIt-Anchor" href="#函数依赖异常范式"></a> 函数依赖,异常,范式</h2>
<ul>
<li>
<p>X函数依赖于Y 意味着Y独特的决定X Y是当前表的候选键</p>
</li>
<li>
<p>X完全函数依赖于Y意味着X不函数依赖于Y的任何子集</p>
</li>
<li>
<p>X部分函数依赖Y = Y的一部分可以决定X Y作为键存在冗余</p>
</li>
<li>
<p>X-&gt;Z，Z-&gt;Y，X-&gt;Y是传递函数依赖</p>
</li>
</ul>
<p>不符合范式的关系，会产生很多异常，范式可以解决异常：</p>
<ul>
<li>冗余数据栏目：例如某个信息在不同行出现了多次 该schema设计有问题</li>
<li>insert异常：因为冗余信息的存在 我们想插入一条记录 就要包括/编造这些无关冗余信息 这往往不现实</li>
<li>delete异常：删除一个含冗余信息的行，导致丢失同行其他关键信息。</li>
<li>update异常：只改了一条记录中的信息，其他记录中相同的信息忘了改。</li>
</ul>
<p>通过无损分解消除没必要的函数依赖 产生更合理的schema 高级别范式依赖于低级别范式</p>
<ul>
<li>1NF：原子属性不可分。</li>
<li>2NF：1NF+消除部分函数依赖 （每个非主属性完全函数依赖于主键）</li>
<li>3NF：2NF +消除传递函数依赖（非主属性不存在“<strong>传递函数依赖</strong>”）</li>
</ul>
<h1 id="数据库并发控制"><a class="markdownIt-Anchor" href="#数据库并发控制"></a> 数据库并发控制</h1>
<h2 id="事务管理中的acid原则"><a class="markdownIt-Anchor" href="#事务管理中的acid原则"></a> 事务管理中的ACID原则</h2>
<ul>
<li>Atomicity 原子性 “all or none”: 事务所做操作要么全部提交要么全部失败回滚
<ul>
<li>实现： 日志undo log,   Shadow paging(COW)</li>
</ul>
</li>
<li>Consistency 一致性 “looks correct”
<ul>
<li>数据库一致性 仍遵循完整性约束 未来事务能看到过去事务造成的后果</li>
<li>事务一致性  事务前后数据库内容一致 一致意味着多个事务访问相同数据得到相同结果</li>
</ul>
</li>
<li>Isolation 隔离性 “lives alone”: 事务所作修改commit前对其他事务不可见
<ul>
<li>两种类别的并发控制协议来保证隔离性</li>
<li>悲观  从最初就避免问题的发生</li>
<li>乐观  设定某种事务执行顺序，假设冲突发生不常见，发生后再处理 lazy</li>
</ul>
</li>
<li>Durability 持久性 “survives failure”: 事务提交的修改应被持久化，即便系统崩溃也不受影响 redo log</li>
</ul>
<p>串行情况下 原子性=&gt;一致性   并行情况下  原子性+一致性=&gt;一致性</p>
<h2 id="一致性冲突"><a class="markdownIt-Anchor" href="#一致性冲突"></a> 一致性冲突</h2>
<ul>
<li>读写冲突：
<ul>
<li>不可重复读 “non-repeatable read”   两个读的中间数据被另一个事务<strong>覆写并提交</strong> 导致第二次读的<strong>同一行值</strong>不同
<ul>
<li>transaction reads committed <strong>UPDATES</strong> from another transaction. The same row now has different values than it did when your transaction began.</li>
<li>A non-repeatable read occurs, when during the course of a transaction, a row is retrieved twice and the <strong>values within the row differ</strong> between reads.</li>
</ul>
</li>
<li>幻读 “phantom read” 两个读的中间<strong>被另一个事务插入/删除行并提交</strong> 导致第二次读<strong>返回的行不同</strong>
<ul>
<li>Phantom reads are similar but when reading from committed <strong>INSERTS</strong> and/or <strong>DELETES</strong> from another transaction. There are new rows or rows that have disappeared since you began the transaction.</li>
<li>A phantom read occurs when, in the course of a transaction, two identical queries are executed, and the <strong>collection of rows</strong> returned by the second query is different from the first.</li>
</ul>
</li>
<li><strong>避免不可重复读锁行就足够，避免幻读需要锁表</strong></li>
</ul>
</li>
<li>写读冲突： 脏读 “dirty reads” Reading uncommitted data 读了另一个事务没有提交的数据</li>
<li>写写冲突：丢失修改 “lost updates” overwriting uncommitted data 一个事务覆盖另一个事务没有提交的数据</li>
</ul>
<h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h2>
<p><img src="https://s2.ax1x.com/2020/02/02/1J7MlR.png" alt="isl"></p>
<ul>
<li>RU: 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>RC: 一个事务只能读取已经提交的事务所做的修改。</li>
<li>RR: 保证在同一个事务中多次读取同一数据的结果是一样的。</li>
<li>S: 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。从MVCC并发控制退化为基于锁的并发控制。不区别快照读和当前读，所有的读操作都是当前读，读加读锁（S锁），写加写锁（X锁）。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</li>
<li>冲突可串行：一个调度是冲突可串行的意味着可以将其转换为串行调度
<ul>
<li>依赖关系图一定无环</li>
<li>这就是SERIALIZABLE隔离级别：将事务完全调度为串行执行</li>
</ul>
</li>
</ul>
<h2 id="悲观并发控制"><a class="markdownIt-Anchor" href="#悲观并发控制"></a> 悲观并发控制</h2>
<h3 id="二段锁"><a class="markdownIt-Anchor" href="#二段锁"></a> 二段锁</h3>
<ul>
<li>
<p><strong>Pessmistic 悲观的</strong> 假设事物存在高度竞争 使用锁 因此安全程度高 但并发能力会有所限制 (not allow all serializable schedules)</p>
</li>
<li>
<p>写锁互斥 X 读锁共享</p>
</li>
<li>
<p>2PL 总是保证冲突可串行调度 <strong>always</strong> gurantee conflicts-serializable schedule = grantee serializable schedule</p>
</li>
<li>
<p>二个阶段      “/\”</p>
<ul>
<li>生长期 只允许拿锁</li>
<li>收缩期 一旦释放第一个锁 进入收缩期
<ul>
<li>只允许放锁 或不放锁</li>
<li><strong>不允许拿锁</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>问题: 脏读情况下<strong>cascading abort</strong>例如t1写 t2读 此时t1还没commit便abort 此时t2不得不abort…如果t2也写了还没来的及提交后面还有读的那这个反应会连锁下去</p>
<ul>
<li>解决: Strong Strict 2PL  (SS2PL) 一个事务提交/abort后才允许放锁 一次放完</li>
</ul>
</li>
<li>
<p>死锁处理:</p>
<ul>
<li>检测:
<ul>
<li>后台周期性在waits-for graph中判环 / 超时检测</li>
<li>选择一个victim回滚打破环，选择标准和rollback程度取决于具体设计</li>
</ul>
</li>
<li>预防:
<ul>
<li>通过时间戳赋予优先度 FCFS</li>
<li>一个人得到锁后其他所有人进入等待队列 直接严格避免死锁发生</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁粒度和层次"><a class="markdownIt-Anchor" href="#锁粒度和层次"></a> 锁粒度和层次</h3>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。<br>
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>
但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>
在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<ul>
<li>一个事务想要更新1billion tuples = ask for locks 1 billion times  VERY SLOW</li>
<li>我们需要锁的层次来展现 行级表级处分别发生了什么</li>
</ul>
<h4 id="如何更方便的进行多粒度封锁-意向锁"><a class="markdownIt-Anchor" href="#如何更方便的进行多粒度封锁-意向锁"></a> 如何更方便的进行多粒度封锁： 意向锁</h4>
<ul>
<li>
<p>意向锁Intention lock: 表示想要对表加锁，与&quot;锁提升机制&quot;结合，细粒度锁太多时动态的分配可用的粗粒度锁  大大减少lock manager需要处理的锁的请求数量</p>
</li>
<li>
<p>意向锁在高层如表级告诉我们下面有什么样的锁 通过兼容矩阵 可以从hierarchy高处快速判断能不能读/写下层具体行的数据</p>
</li>
<li>
<p>Intention-Shared (IS):下面某个地方有读锁</p>
<ul>
<li>Intention-Exclusive (IX):下面某个地方有写锁</li>
</ul>
</li>
<li>
<p>Shared+Intention-Exclusive (SIX):  整个子树可共享读，下面某个孩子有写锁</p>
</li>
<li>
<p>表级锁兼容矩阵：<br>
|      | <code>X</code>  | <code>IX</code>   | <code>S</code>  | <code>IS</code>   |<br>
| ---- | ---- | ------ | ---- | ------ |<br>
| <code>X</code>  |      |        |      |        |<br>
| <code>IX</code> |      | <strong>OK</strong> |      | <strong>OK</strong> |<br>
| <code>S</code>  |      |        | OK   | OK     |<br>
| <code>IS</code> |      | <strong>OK</strong> | OK   | <strong>OK</strong> |</p>
</li>
<li>
<p>表和表：任意 IS/IX 锁兼容:  != 真正加锁 | S 和 IS 兼容</p>
</li>
<li>
<p>表和行：表级 IX 和行级 X 兼容：两个事务先对同表加IX锁，然后可以对同表两个不同数据行加 X 锁</p>
</li>
</ul>
<h3 id="mysql事务四级封锁-强2pl读写锁"><a class="markdownIt-Anchor" href="#mysql事务四级封锁-强2pl读写锁"></a> Mysql事务四级封锁: 强2PL+读写锁</h3>
<p>Mysql InnoDB引擎采用强2PL，根据当前隔离级别自动加锁=<strong>隐式锁定</strong></p>
<ul>
<li><strong>一级</strong>  修改加写锁，事务结束放写锁  = Read Uncommited级别</li>
<li>防止<strong>写写冲突</strong>问题Lost updates</li>
<li><strong>二级</strong>  一级 + 读加读锁，读完放读锁 = Read Commited级别</li>
<li>防止<strong>脏读</strong>问题Dirty Reads</li>
<li><strong>三级</strong>  二级 + 读加读锁，事务结束放读锁 = Repeatable Reads级别</li>
<li>防止<strong>不可重复读</strong>问题unrepeatable reads</li>
<li><strong>四级</strong> 全表锁，事务结束放锁 = Serializable级别</li>
</ul>
<p><strong>显式锁定</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取读锁： <span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>; </span><br><span class="line">获取写锁： <span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h2 id="乐观并发控制"><a class="markdownIt-Anchor" href="#乐观并发控制"></a> 乐观并发控制</h2>
<ul>
<li>不使用锁：对common case的一种优化, 大部分情况下事务只需持续很短时间，冲突没有那么容易发生。所以我们可以使用比较懒的策略，假设冲突不会发生，检测到发生再进行补救 如选择abort</li>
</ul>
<p>根据ACID原则 并发情况下实现一致性需要原子性和隔离性, 原子性通过CAS等原子操作解决, 隔离性通过时间戳机制赋予事务执行顺序</p>
<p>目前有三种主流乐观并发控制策略</p>
<ul>
<li>基于时间戳的 事务用时间戳编号排序 最早OCC论文内容
<ul>
<li>读写阶段：将更改存在私有空间</li>
<li>验证阶段：验证是否和其他事务冲突再提交</li>
<li>写阶段：验证成功 将私有空间更改同步至主空间  否则abort</li>
</ul>
</li>
<li>snapshot isolation: 朴素mvcc</li>
<li>CAS: 不仅是一种策略 也是一种实现
<ul>
<li>满足期望值(没有被占用)则更新。返回旧值供外层循环检测</li>
<li>外层while CAS(flag, 0, 1) == 1: Old value is 1, lock held by someone else, spin and wait. Otherwise go ahead do modification</li>
<li>硬件支持：x86架构下指令为cmpxchgl</li>
</ul>
</li>
</ul>
<h2 id="mvcc多版本并发控制"><a class="markdownIt-Anchor" href="#mvcc多版本并发控制"></a> MVCC多版本并发控制</h2>
<ul>
<li>
<p>当前最常见的数据库并发控制方法. 非常适合读多写少的OLTP workload 朴素MVCC<strong>解决了在REPEATABLE READ和READ COMMITTED两个隔离级别下读同一行和写同一行的两个事务的并发问题。</strong></p>
</li>
<li>
<p>朴素的MVCC在数据库领域可以说是乐观的 是不用锁的 单纯使用快照方式实现读写分离 类似COW</p>
</li>
</ul>
<p>mysql默认隔离级别为RR， InnoDB的mvcc是mvcc的改进版 引入(next-key lock]解决了朴素mvcc的幻读问题 能够实现RC RR S三个隔离级别</p>
<ul>
<li>
<p>即便是改进版MVCC也只是处理读写或写读的冲突属于整个四种Isolation level处理的问题。写写冲突 lost updates 一般通过first commiter/first updater win 解决</p>
</li>
<li>
<p>读=不加锁的非阻塞读 读旧版本快照   |     写(插入删除更新)=加锁更新一个最新的版本快照</p>
</li>
<li>
<p>系统版本号SYS_ID：通过时间戳机制单调递增分配</p>
</li>
<li>
<p>事务版本号TRX_ID：事务开始时的系统版本号</p>
</li>
<li>
<p>每个事务都有这两个版本号并被记录在undo日志中</p>
</li>
<li>
<p>RC RR隔离级别下使用版本链 多个版本的快照存在undo日志中，日志通过回滚指针把一个数据行的所有快照连起来</p>
</li>
<li>
<p>MVCC 维护一个read view结构 当前未提交事务列表trx_min_id…trx_max_id  一个数据行快照的trx_ID &lt;min则可用 &gt;max则不可用 位于中间取决于当前隔离级别  若该快照不可用则要沿undo日志中版本链找前一个可用快照</p>
</li>
<li>
<p>快照读select…不需要锁，当前读（数据修改insert/update/delete）操作需要锁</p>
</li>
<li>
<p>innodb为了解决rr级别下当前读(数据修改)的幻读问题，使用了next-key lock</p>
<ul>
<li>本质上是gap lock+ record lock</li>
<li>record lock锁定记录上的索引相当于一个单点锁 (使用unique index访问的情况)</li>
<li>gap lock锁定record lock单点之前的开区间(使用non-unique index / no index访问的情况)</li>
<li><code>(10, 15]</code> 每一个next-key lock锁定一个左开右闭区间</li>
</ul>
</li>
</ul>
<h1 id="索引和储存"><a class="markdownIt-Anchor" href="#索引和储存"></a> 索引和储存</h1>
<h2 id="bbhashbit-map"><a class="markdownIt-Anchor" href="#bbhashbit-map"></a> B,B+,Hash,Bit Map</h2>
<ul>
<li>
<p>哈希索引高效等值查询 位图索引适合静态low cardinality数据</p>
</li>
<li>
<p>B树平衡多路查找树 m度=m指针 m-1个键值(实际数据记录)  叶子层并非包括全部数据记录 节点半满压缩高度 节点内有序 叶子结点位于同层</p>
</li>
<li>
<p>b+树 叶子层(节点内外均有序)fixed-size数组的链表保存全部数据记录+非叶子层有序索引只存搜索键值 (储存指针多一个)</p>
</li>
<li>
<p>b+树与b树区别：</p>
<ul>
<li>b+叶子层有序fixed-size数组链表同时支持高效等值查询和范围查询 （节点内有序可以2分搜索）和bulk-loading (每个固定gap选最小值作为搜索键值 从下到上建树)</li>
<li>单叶子储存节点更多 高度压缩更明显 IO次数更少</li>
<li>所有查询都要找到叶子结点 查询性能更稳定</li>
</ul>
</li>
<li>
<p>为什么适合储存：非平衡树可以直接排除-skew情况下退化为链表 红黑只有2叉不适合高度太高io次数太多文件系统 b+结合b树优点节点半满多路平衡查找树 高度低IO次数少 同时叶子层支持外排序后bulk-loading 更适合文件系统和数据储存 更好利用磁盘预读性质</p>
</li>
</ul>
<h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2>
<p><strong>为什么要使用索引？避免全表扫描，使用更好的索引-减少数据访问量</strong></p>
<ul>
<li>索引键=索引项 搜索键：我们要查找的栏目名称</li>
<li><strong>clustered index / primary index / sparse index 主索引</strong>：记录顺序和索引键相同  整个文件要按索引键排序 indexed-sequential file 只能有1个主索引。例子：有序文件/hash表上的索引
<ul>
<li>primary index指用含主键的集合作索引键的索引 一般情况下将primary index和clustered视为相同</li>
<li>无论索引键是否有重复 可以是dense(trivial)也可以sparse 因为完全有序 可以每个disk block建一个索引指向第一个anchor record即可 找到合适位置后顺序扫描 因此一般默认为<strong>sparse</strong>
<ul>
<li>有序= 高效的范围查找 IO次数少</li>
<li>因为有序 插入删除更新 维护成本高：有空间直接插入 否则维护overflow chain 时间长了性能下降严重 因此多数数据库会定期重新组织记录结构将overflow chain展开 但这也要开销</li>
</ul>
</li>
</ul>
</li>
<li><strong>non-clustered index / secondary index 辅助索引</strong>：索引键和记录顺序不同
<ul>
<li><strong>must only be dense !</strong></li>
<li><strong>索引有序 按辅助索引键排序</strong> 不给记录排序 那是主索引的事！！！</li>
<li>可能涉及到不同磁盘区块 = 更多io + 寻道时间 更慢</li>
<li><strong>通常使用间接索引的方式避免重复key问题</strong> 这样最底层索引相同key有序排列 底层之上高层实现稀疏索引</li>
<li><s>sparse辅助索引没有意义 因为数据记录无序  什么都找不到 最后依赖全表扫描或主索引</s></li>
<li>例：mysql中当查询列上没有辅助索引 就走主索引</li>
</ul>
</li>
<li>dense index: 索引键出现在每个含搜索键值的记录上,
<ul>
<li>有序情况下支持范围查询 二分查找</li>
<li>有序情况下非常高效：1 disk IO = load everything into memory until exceed range</li>
<li><s>无序情况：需要全表扫描 不适用 现在的索引尤其是b+tree都是有序索引</s></li>
</ul>
</li>
<li>sparse index: 索引键出现在部分含搜索键值的记录上  <strong>必须是主索引</strong> 记录要按索引键顺序排序
<ul>
<li>1 key - ptr pair per disk block 1st record = anchor record</li>
<li>有序情况下 可用二分查找 <strong>MORE space-memory effcient</strong></li>
</ul>
</li>
<li>多列联合索引
<ul>
<li>通常策略：按最左边建立b+树有序索引 索引按优先级左到右字典序排序</li>
</ul>
</li>
</ul>
<h2 id="mysql索引"><a class="markdownIt-Anchor" href="#mysql索引"></a> Mysql索引</h2>
<p>InnoDB支持 B+树 哈希 全文索引  MyISAM支持全文索引 空间数据索引</p>
<ul>
<li>DDL部分 声明的key会自动创建辅助索引 主键会创建主索引</li>
<li>联合索引匹配遵循<strong>最左匹配原则</strong> idx1(a,b,c,d)
<ul>
<li>从左向右匹配直到遇到范围查询&lt;,&gt;,between,like e.g. a=3,b=4,c&gt;5,d=2   d会用不到索引</li>
<li>若查询均为等值查询 = , in 则可以乱序 如查询 a=1, c=3,b=2 (a,b,c) 甚至可以省略前面部分 直接查询c = 3 查询优化器会自动修改</li>
</ul>
</li>
<li>原因：B+树有序索引会建在a上 剩余内容b,c,d在前者基础上依次排序 叶子层记录以有序数组形式存在叶节点内 有序查询找到a后依次向后按序匹配
<ul>
<li>b的有序是基于a的有序 因此等值查询不受影响</li>
<li>当a为范围查询时,e.g. a&gt;1 的结果是一个多条记录的范围  此时b相对于这个范围是无序的 无法使用索引</li>
</ul>
</li>
<li>索引是建立越多越好吗？
<ul>
<li>数据量小的表不需要索引 增加额外开销</li>
<li>数据修改要维护索引 = 更多维护成本</li>
</ul>
</li>
</ul>
<h2 id="mysql引擎"><a class="markdownIt-Anchor" href="#mysql引擎"></a> Mysql引擎</h2>
<table>
<thead>
<tr>
<th>InnoDB  default</th>
<th>MyISAM</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>支持事务</strong>，适合OLTP  <strong>事务处理为主 小范围数据 简单查询 重复性高 增删查改写多于读</strong> 如购物车</td>
<td><strong>不支持事务</strong>，适合OLAP <strong>数据分析为主  大范围数据 复杂查询 重复性低 读多于写</strong> 如统计计算聚集函数。</td>
<td></td>
</tr>
<tr>
<td><strong>行锁设计</strong> MVCC+next-key lock提供四个级别安全和高并发性</td>
<td><strong>表锁设计</strong></td>
<td></td>
</tr>
<tr>
<td>支持外键</td>
<td>不支持外键</td>
<td></td>
</tr>
<tr>
<td>支持clustered index 全表按主键排序</td>
<td>不支持clustered index 索引文件单独储存：主键/其他方式所建索引的偏移量  数据库文件是无序的heapfile</td>
<td></td>
</tr>
<tr>
<td>提供了插入缓冲、二次写、自适应哈希索引、预读等高性能和高可用的功能。</td>
<td>它的缓冲池只缓冲<strong>索引文件</strong>，<strong>不缓冲数据文件</strong>。索引文件单独储存</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="sql调优"><a class="markdownIt-Anchor" href="#sql调优"></a> SQL调优</h2>
<p>索引调优基本heuristics</p>
<ul>
<li>修改sql尽量全走索引（<strong>覆盖索引</strong>）没索引的情况下考虑建合适的辅助索引
<ul>
<li>innoDB辅助索引 不覆盖会 访问主索引</li>
<li>myisam只缓存索引 不覆盖会 额外读文件-全表扫描-系统调用 page replacement</li>
</ul>
</li>
<li>选择性强的索引放前面，索引全覆盖的情况下尽量将<strong>范围查询移到末尾</strong> <strong>遵循最左匹配原则</strong>的原理 避免查询不走索引</li>
<li><strong>不要把想走索引的搜索码放表达式里</strong> 如actor_id + 1 = 5; 是错误的 不会走索引</li>
<li>性能： <strong>1个多列索引&gt;多个单列索引</strong></li>
<li>较长类型如blob, text, varchar 应使用<strong>前缀索引</strong> 只索引前几个字符</li>
</ul>
<p>需要注意的</p>
<ul>
<li>
<p>mysql optimizer会消除没有必要的数据行访问 因此不一定会走主索引或副索引</p>
</li>
<li>
<p>找慢的query show variables找到系统变量long_query_time slow_query_log(默认off)</p>
<ul>
<li>long_query_time 超过则加入slow query log, set slow_query_log为on</li>
</ul>
</li>
<li>
<p>查看query plan, explain query显示栏目</p>
<ul>
<li>id=子查询执行顺序 type=找到数据行/join的方式:  all全表扫描 index扫了index树</li>
<li>extra里面有各种状态比如using index = 索引完全覆盖了查询 using index for group-by部分使用索引等  using file-sort用了外排序（比如order by） using temporary 用了临时表</li>
</ul>
</li>
<li>
<p>explain xxx force index(primary) / force index(xxx) 尝试使用别的索引</p>
</li>
<li>
<p>加索引 alter table xxx add index idxname(字段名); 或者在ddl里create index xxx</p>
</li>
</ul>
<p>查询优化</p>
<ul>
<li>切分大的事务(查询) 避免小的饥饿 或使用多粒度意向锁</li>
<li>大连接查询切分为 单表查询 + 关联  更好利用已有缓存 提高自身缓存可用性  减少锁竞争</li>
</ul>
<h1 id="分布式和系统设计"><a class="markdownIt-Anchor" href="#分布式和系统设计"></a> 分布式和系统设计</h1>
<h2 id="模型和概论"><a class="markdownIt-Anchor" href="#模型和概论"></a> 模型和概论</h2>
<ul>
<li>重要假设: 容错模型 <strong>假设我们可以相信节点(we write them)</strong>（若不相信需要使用拜占庭容错协议 blockchain）</li>
<li>基本架构
<ul>
<li>shared everything: 单点</li>
<li>shared memory: <strong>no one does this</strong>, need OS support 多用于HPC超算中心</li>
<li>shared disk: common for cloud DBMS</li>
<li>shared nothing: most common. better performance, hard to manage ex. most nosql sys</li>
<li>同构vs异构：集群内节点可否执行相同任务</li>
</ul>
</li>
<li>两种设计monolith vs microservice 组件耦合程度
<ul>
<li>monolith: 单机负责多种功能
<ul>
<li>适合小团队</li>
<li>简单： 更少解耦，维护</li>
<li>快：少/无 RPC</li>
<li>部署复杂</li>
<li>单点故障波及范围大</li>
</ul>
</li>
<li>microservice：单机负责单一功能 + 小型分布式缓存数据库 适合大型系统
<ul>
<li>easy to scale (easy for new team member)</li>
<li>decoupled : easy to reason about</li>
<li>hard to design: s1 only talks to s2 = they need to be merged</li>
</ul>
</li>
</ul>
</li>
<li>两种拓展模型</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>水平扩展 更多机器</th>
<th>垂直拓展 更强机器</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>需要负载均衡</td>
<td><strong>N/A</strong></td>
</tr>
<tr>
<td>容错</td>
<td>可靠</td>
<td>单点故障</td>
</tr>
<tr>
<td></td>
<td>RPC</td>
<td><strong>IPC</strong></td>
</tr>
<tr>
<td></td>
<td>易数据不一致</td>
<td><strong>通常一致</strong></td>
</tr>
<tr>
<td></td>
<td><strong>scales well as users increase</strong></td>
<td>硬件限制</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>优化方法</p>
<ul>
<li>优化单点能力：vertical scaling</li>
<li>解决单点故障  horizontal scaling - 备用服务器转换 / replication</li>
<li>多节点集群负载均衡 减少单点负荷: load balancer responsible</li>
<li>微服务架构提高可拓展性: 解耦系统组件, 各司其责</li>
<li>日志和评估系统</li>
</ul>
</li>
<li>
<p>事件驱动模型:  ex. git, game server csgo headshot</p>
<ul>
<li>publisher-subscriber: relies on message queues to pass events
<ul>
<li>Good: decoupled, easy to identify failure ONLY SPOF, easy to add / remove</li>
<li>Bad: extra level of indirection = slow, <strong>does not gurantee strong consistency</strong>, cost for learning and maintaining message queues</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="原则和协议"><a class="markdownIt-Anchor" href="#原则和协议"></a> 原则和协议</h2>
<ul>
<li>
<p>CAP： 分布式系统不能同时满足一致性 可用性 分区容忍性</p>
<ul>
<li>Consistency一致性：保持数据一致和最新 Linearizability</li>
<li>Availability可用性：系统可用时间占总时间的比值 All up nodes can satisfy all requests</li>
<li>Partial tolerant分区容忍性：局部网络故障消息丢失时能否继续提供一致性和可用性服务 still operates despite message loss</li>
<li>分区容忍性一般必不可少 CAP实际上是在一致性和可用性CA间进行权衡
<ul>
<li>不可以cp 因为存在k-safety限制 不得不放弃可用性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BASE理论 CAP的拓展 CA的协调结果 Basically avaiable, Soft State, Eventually Consistent</p>
<ul>
<li>ACID要求强一致性(数据更新后 用户能够读取到最新值) 用于单机传统数据库</li>
<li>BASE要求最终一致性 中间软状态可以看情况适当妥协 保证始终提供核心基础服务即可</li>
</ul>
</li>
<li>
<p><strong>分布式死锁检测</strong> 周期性union所有waits-for-graph</p>
</li>
<li>
<p>如何实现共识 agree on commit abort ? quorum (voting)</p>
</li>
<li>
<p>分布式事务协调  原子性提交相关协议2PC, Paxos, Raft, ZAB</p>
<ul>
<li>中心化:  global traffic cop as <strong>middleware / coordinator</strong> route query as needed to partitions
<ul>
<li>2PC: 相当于paxos的弱化版
<ul>
<li>
<p>prepare phase: 协调者询问参与者事务是否准备好提交 参与者投票Y/N 全票=提交</p>
</li>
<li>
<p>commit phase: 协调者决定结果 如果可以就都提交-否则回滚 参与者回复ack</p>
</li>
<li>
<p>可以和 2PL结合</p>
</li>
<li>
<p>问题</p>
<ul>
<li><strong>不能解决dead coordinator问题</strong>  paxos 可以解决</li>
<li>同步过程中阻塞问题 要等待其他参与者响应</li>
<li>网络问题导致只有部分参与者commit ？</li>
<li>一个节点失败=失败  容错率低</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>去中心化: 节点自行组织产生分布式共识
<ul>
<li>没有协调者</li>
<li>服务器和master node交流 如果是同构架构 所有节点都可以是master node</li>
<li>query request发送到master node / partition</li>
<li>提交时master node和其他节点交流safe to commit？ 投票选择
<ul>
<li>paxos 分布式共识算法 无需全票 多数投票通过即通过 <strong>如果多数存活non-blocking 高容错 解决dead coordinator问题</strong>
<ul>
<li>proposer 提议提交 OK? 1个或多个proposer</li>
<li>acceptor reply  只需多数即可提交  see n+1 reject n</li>
<li>learner: 被告知投票的结果，不参与投票过程。</li>
<li><strong>持续处理新来的proposal</strong> 即便之前的已经同意 也当即拒绝之前的proposal和commit请求</li>
<li><strong>解决饥饿问题</strong>：multi-paxos 选择1个leader, 规定若如果只有一个proposer propose阶段可以跳过 周期性选举当前leader</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>raft 选举主节点</p>
</li>
</ul>
<h2 id="组件和机制"><a class="markdownIt-Anchor" href="#组件和机制"></a> 组件和机制</h2>
<ul>
<li>
<p>异步消息机制： message/task queue</p>
<ul>
<li>接受任务后分配给不同服务器，若花时间太长=dead，assign to next server to avoid duplication</li>
</ul>
</li>
<li>
<p>分布式缓存</p>
<ul>
<li>缓存：avoid network calls, repeated computation, db load
<ul>
<li>置换策略不好或缓存太大都会导致缓存无用</li>
<li>thrashing: constantly input &amp; output withhout using the result = sequential flooding ?</li>
<li>server-side, client-side : fast but cache consistency?</li>
<li>全局缓存global cache (redis): 解耦！微服务！
<ul>
<li>consistently accurate but slightly slower</li>
<li>can scale independently</li>
</ul>
</li>
<li>write through: …on hit, update cache &amp; database  <strong>keep db always consistent but slow</strong></li>
<li>write back: write to cache, mark dirty(inconsistent). lazily update db when dirty-cache entry is evicted <strong>db can be temporarily inconsistent but fast</strong></li>
<li>hybrid: 重要的更新write through, 批缓存不重要的更新到cache, 低峰时间一次性同步到db</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分区 usually logical</p>
<ul>
<li>垂直切分/naive table partitioning ：如果查询分布不均匀集中到一个点 单点计算能力可能扛不住</li>
<li>水平切分/round-robin sharding / load balancing ：query fragment分布到集群不同节点上作相同处理最后合并 有效缓解单数据库压力 多采用哈希取模方式划分
<ul>
<li><strong>可拓展 无重复的</strong> 一致性哈希：集群增删一个节点后如何避免rehash&amp;trash our caches？
<ul>
<li>绕环线性探测到下一个节点</li>
<li>节点少数据倾斜？每台服务器做多个虚拟节点replication 实现相对均匀分布</li>
<li>哈希函数不好 服务器分布不均not uniformly distributed：
<ul>
<li>完美哈希 使用哈希函数族（嵌套一致性哈希 + multilevel sharding ）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据库的分库分表：大连接慢 可与主从复制结合提高分片容错 可与和索引结合 consistency is hard 建议优先使用nosql等其他系统再考虑这种primritive
<ul>
<li>表的垂直切分：一张表按列切分成多个表  分到不同库里</li>
<li>表的水平切分：同一个表中的记录拆分到多个结构相同的表中 可以分布到集群不同节点上 配合服务器的负载均衡 减少单库压力</li>
</ul>
</li>
</ul>
</li>
<li>
<p>复制 Replication</p>
<ul>
<li>
<p>创建冗余备用节点储存相同信息提高系统可用性</p>
</li>
<li>
<p>k-safety: 最少k可用复制品 #replicas &lt; k DBMS halts go offline</p>
</li>
<li>
<p>主从架构</p>
</li>
<li>
<p>更新集中到master</p>
</li>
<li>
<p>master更新内容到replica</p>
<ul>
<li>更新方式
<ul>
<li>同步： 主等待从完成日志并回复ack 保证<strong>强一致性</strong>strong consistency 数据是即时的</li>
<li>异步：不等待 主直接返回ack给client 保证最终一致性eventual consistency 数据snapshot</li>
</ul>
</li>
<li>更新timing
<ul>
<li>连续的：生成日志=》直接发送</li>
<li>提交时</li>
</ul>
</li>
<li>从者主动被动？
<ul>
<li>主动：事务在从处自行执行 需要检测不同从的结果匹配</li>
<li>被动：事务在1处执行后传递给所有replicas</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可允许只读事务访问replica</p>
<ul>
<li>可实现读写分离: 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。从服务器可以分布到离用户较近的地方 降低延迟 提高用户体验</li>
<li>采用快照隔离能保证弱一致性, 增加冗余提高可用性</li>
</ul>
</li>
<li>
<p>master故障 选举新master</p>
</li>
<li>
<p>多主人</p>
<ul>
<li>replica和主人平级（没有主人=多主人）- 事务可在任何replica处更新 replica们<strong>自行使用原子性提交/分布式共识协议2PC/Paxos互相同步</strong></li>
</ul>
</li>
<li>
<p>网络故障包丢失 分区paxos选主后 <strong>split-brain</strong>双主如何在网络恢复后同步?</p>
<ul>
<li>传统/newsql dbms：多数节点连接完好<strong>才允许更新</strong> 不存在这个问题</li>
<li>nosql：需要某种形式上的中心化处理
<ul>
<li>乐观：选择可用性，牺牲部分一致性，之后在合适的时间自动或人为处理 hazelcast</li>
<li>悲观：选择一致性，牺牲部分可用性，投票下线存在问题的网络分区 mongoDB</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>总结：分区和复制通常一起使用：如水平切分的数据库分布到集群不同单点上 并作复制 复制品可以是slave(主从结构)也可以是master (distributed-consensus based).</p>
</li>
</ul>
<h1 id="no-sql-in-memory-db"><a class="markdownIt-Anchor" href="#no-sql-in-memory-db"></a> No-sql &amp; in-memory DB</h1>
<ul>
<li>
<p>NoSQL: not-only relation: <strong>k-v, document(json, csv), graph</strong> cassandra redis mongodb</p>
<ul>
<li>优点
<ul>
<li>插入删除涉及所有相关数据 此时使用nosql开销较低</li>
<li>schema比较灵活 方便更改</li>
<li>内部支持水平切分 scales well</li>
<li>built for OLAP</li>
</ul>
</li>
<li>缺点
<ul>
<li>no acid guarantee</li>
<li>not read optimized  join is hard 涉及大量扫描相关对象</li>
<li>no relation no constriants</li>
</ul>
</li>
</ul>
</li>
<li>
<p>In-memoryDB: very modern, lack durability support from ACID, store things in volatile meory. e.g. Oracle IMDB</p>
</li>
</ul>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://th2zz.github.io/2020/02/16/网络OS数据库分布式/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络-操作系统-数据库-分布式总结/">网络, 操作系统, 数据库, 分布式总结</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
    
      <a href="/2019/12/02/computer_network/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">计网总结</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'mBc25X7r6Py8UqVWPpKhl5b9-gzGzoHsz',
        app_key: 'IsGMjzFd8QEgy8MACTl8eVu9',
        path: window.location.pathname,
        avatar: 'retro',
        placeholder: '说点什么吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2016-2020
        th2zz
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="th2zz"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Rechercher">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="Flux RSS">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['生きるとはつまり螺旋のことだったんだよ！','',''],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>